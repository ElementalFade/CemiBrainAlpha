<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Demihypercube/Simplex Coxeter-Plane + Hebbian Adaptive Edges (ONE FILE)</title>
<style>
  :root{
    --bg: #000;
    --panel: rgba(10,10,10,.62);
    --panel2: rgba(10,10,10,.78);
    --stroke: rgba(255,255,255,.14);
    --stroke2: rgba(255,255,255,.10);
    --text: rgba(255,255,255,.92);
    --muted: rgba(255,255,255,.68);
    --muted2: rgba(255,255,255,.54);
    --accent: rgba(120,180,255,.95);
    --radius: 14px;
    --pad: 10px;
    --pad2: 12px;
    --rowH: 30px;
    --shadow: 0 10px 40px rgba(0,0,0,.45);
  }
  html,body{margin:0;height:100%;overflow:hidden;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  #wrap{position:relative;width:100%;height:100%}
  canvas{width:100%;height:100%;display:block;touch-action:none}

  /* Floating gear */
  #uiToggle{
    position:absolute;right:12px;top:12px;z-index:40;
    width:42px;height:42px;border-radius:12px;
    background:rgba(0,0,0,.55);color:#fff;border:1px solid rgba(255,255,255,.18);
    display:flex;align-items:center;justify-content:center;font-size:18px;cursor:pointer;
    backdrop-filter:blur(8px);
    box-shadow:0 8px 26px rgba(0,0,0,.35);
    user-select:none
  }

  /* Sidebar panel */
  #ui{
    position:absolute;left:12px;top:12px;z-index:30;
    width:360px;max-width:min(560px, calc(100vw - 24px));
    height:min(820px, calc(100vh - 24px));
    display:flex;flex-direction:column;
    overflow:hidden;
    background:var(--panel);
    color:var(--text);
    border:1px solid var(--stroke);
    border-radius:var(--radius);
    backdrop-filter:blur(10px);
    box-shadow:var(--shadow);
  }
  #ui.hidden{display:none}
  #ui.compact{width:300px}
  #ui.wide{width:480px}
  #ui.max{width:min(760px, calc(100vw - 24px))}

  /* header */
  #uiHeader{
    position:sticky;top:0;z-index:5;
    display:flex;flex-direction:column;gap:8px;
    padding:12px 12px 10px 12px;
    background:linear-gradient(to bottom, rgba(12,12,12,.86), rgba(12,12,12,.58));
    border-bottom:1px solid var(--stroke2);
  }
  #uiTitleRow{display:flex;align-items:center;gap:10px}
  #uiPresetRow{display:flex;align-items:center;gap:8px;margin-top:8px}
  #presetSel{flex:1;min-width:0;height:30px;border-radius:12px;background:rgba(0,0,0,.25);color:var(--text);border:1px solid var(--stroke);padding:0 10px;font-size:12px;outline:none}
  #presetSel:focus{border-color:rgba(120,180,255,.55)}
  #presetApply{height:30px;padding:0 12px}
  #uiTitle{
    font-size:12.5px;font-weight:650;letter-spacing:.2px;line-height:1.1;
    white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
  }
  #uiTitleRow .spacer{flex:1}
  .miniBtn{
    height:30px;min-width:30px;padding:0 10px;border-radius:10px;
    border:1px solid rgba(255,255,255,.16);
    background:rgba(255,255,255,.06);color:var(--text);
    display:inline-flex;align-items:center;justify-content:center;
    cursor:pointer;user-select:none;
  }
  .miniBtn:hover{background:rgba(255,255,255,.10)}
  .miniBtn:active{transform:translateY(1px)}

  #uiSearchRow{display:flex;gap:8px;align-items:center}
  #uiSearch{
    flex:1;height:30px;border-radius:12px;
    border:1px solid rgba(255,255,255,.14);
    background:rgba(0,0,0,.35);color:var(--text);
    padding:0 12px;font-size:12.5px;outline:none;
  }
  #uiSearch::placeholder{color:rgba(255,255,255,.45)}

  /* Tabs */
  #uiTabs{
    display:flex;gap:6px;flex-wrap:wrap;
  }
  .tab{
    height:30px;padding:0 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background:rgba(255,255,255,.05);
    color:var(--muted);font-size:12px;cursor:pointer;
    user-select:none;
  }
  .tab[aria-selected="true"]{
    color:#fff;border-color:rgba(255,255,255,.22);
    background:rgba(120,180,255,.16);
    box-shadow:0 0 0 1px rgba(120,180,255,.10) inset;
  }

  /* content scroll */
  #uiBody{flex:1;overflow:auto;padding:10px 12px 12px 12px}
  #uiBody::-webkit-scrollbar{width:10px}
  #uiBody::-webkit-scrollbar-thumb{background:rgba(255,255,255,.12);border-radius:999px}
  #uiBody::-webkit-scrollbar-track{background:rgba(255,255,255,.04)}

  /* sections / details */
  details.section{
    border:1px solid rgba(255,255,255,.10);
    border-radius:12px;
    padding:8px 10px;
    margin:10px 0;
    background:rgba(0,0,0,.18);
  }
  details.section[open]{background:rgba(0,0,0,.26)}
  summary{
    cursor:pointer;
    font-size:12px;
    color:var(--text);
    list-style:none;
    display:flex;align-items:center;gap:8px;
    user-select:none;
  }
  summary::-webkit-details-marker{display:none}
  summary .sumDot{
    width:8px;height:8px;border-radius:99px;background:rgba(120,180,255,.60);
    box-shadow:0 0 0 2px rgba(120,180,255,.14);
    flex:none;
  }
  summary .sumText{flex:1;opacity:.92}
  summary .sumMeta{font-size:11px;color:var(--muted2)}
  details.section[open] summary .sumMeta{opacity:.75}

  /* button rows */
  .btns{display:grid;grid-template-columns:repeat(2, minmax(0,1fr));gap:6px;margin:6px 0 4px}
  .btns.wide{grid-template-columns:repeat(4, minmax(0,1fr))}
  button{
    height:30px;border:1px solid rgba(255,255,255,.16);
    background:rgba(0,0,0,.35);color:#fff;border-radius:12px;
    padding:0 10px;font-size:12px;cursor:pointer;
  }
  button:hover{background:rgba(255,255,255,.08)}
  button:active{transform:translateY(1px)}

  /* rows */
  .row{
    display:grid;
    grid-template-columns: 1fr auto;
    gap:8px;
    align-items:center;
    min-height:var(--rowH);
    margin:4px 0;
  }
  .row .left{
    display:flex;align-items:center;gap:8px;min-width:0;
  }
  .row label{
    font-size:12px;color:var(--muted);
    line-height:1.2;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
    flex:1;min-width:0;
  }
  .row .right{
    display:flex;align-items:center;gap:6px;justify-content:flex-end;
  }
  .row select,.row input[type="number"],.row input[type="range"], .row input[type="text"]{
    width:170px;max-width:170px;
    background:rgba(0,0,0,.35);color:#fff;
    border:1px solid rgba(255,255,255,.16);
    border-radius:10px;
    padding:6px 8px;font-size:12px;
  }
  .row input[type="range"]{padding:0;height:26px}
  .row input[type="checkbox"]{transform:scale(1.05)}
  .chk{display:flex;align-items:center;gap:8px}

  .infoBtn{
    width:20px;height:20px;border-radius:999px;border:1px solid rgba(255,255,255,.20);
    background:rgba(255,255,255,.06);color:#fff;font-size:12px;line-height:18px;
    display:flex;align-items:center;justify-content:center;cursor:pointer;
    user-select:none;backdrop-filter:blur(6px)
  }
  .infoBtn:hover{background:rgba(255,255,255,.10)}
  .valBox{
    font-variant-numeric:tabular-nums;
    padding:3px 8px;border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background:rgba(0,0,0,.25);
    text-align:right;font-size:11.5px;color:rgba(255,255,255,.85)
  }

  /* Re-enable value/info layout inserted by JS */
  .row{grid-template-columns: 1fr auto}
  .row.enhanced{
    grid-template-columns: 1fr auto;
  }

  /* tooltip */
  .tip{
    position:absolute;max-width:360px;
    background:rgba(10,10,10,.92);color:#fff;
    border:1px solid rgba(255,255,255,.18);
    border-radius:12px;padding:10px 11px;font-size:12px;line-height:1.25;
    box-shadow:0 10px 40px rgba(0,0,0,.55);
    z-index:9999;pointer-events:none;opacity:0;transform:translateY(-4px);
    transition:opacity .12s ease, transform .12s ease
  }
  .tip.show{opacity:1;transform:translateY(0)}

  #status{
    margin-top:8px;font-size:12px;opacity:.92;white-space:pre-wrap;line-height:1.25;
    padding:8px 10px;border-radius:12px;background:rgba(0,0,0,.22);border:1px solid rgba(255,255,255,.10)
  }
  .progressBox{margin-top:10px}
  progress{width:100%;height:12px}

  #progText{font-size:12px;opacity:.92;margin-top:4px;white-space:pre-wrap}

  /* resizer grip */
  #uiResizer{
    position:absolute;top:0;right:-6px;width:12px;height:100%;
    cursor:ew-resize;z-index:50;
  }

  #hud{
    position:absolute;left:12px;bottom:12px;z-index:25;
    background:rgba(0,0,0,.55);color:#fff;border:1px solid rgba(255,255,255,.12);
    border-radius:14px;padding:10px 12px;font-size:12px;line-height:1.25;
    backdrop-filter:blur(8px);
    max-width:min(1020px, calc(100vw - 24px));
    white-space:pre-wrap;
  }

  /* Bottom field toggle (outside menu) */
  #fieldToggleBtn{
    position:absolute;right:12px;bottom:12px;z-index:30;
    height:36px;min-width:132px;padding:0 14px;
    border-radius:999px;border:1px solid rgba(255,255,255,.14);
    background:rgba(0,0,0,.55);color:rgba(255,255,255,.92);
    font-weight:650;letter-spacing:.2px;
    display:flex;align-items:center;justify-content:center;gap:8px;
    box-shadow:0 10px 28px rgba(0,0,0,.35);
    backdrop-filter:blur(8px);
    user-select:none;
  }
  #fieldToggleBtn:hover{background:rgba(0,0,0,.65)}
  #fieldToggleBtn:active{transform:translateY(1px)}
  #fieldToggleBtn.off{opacity:.78}
  #fieldToggleBtn .dot{width:10px;height:10px;border-radius:999px;background:rgba(120,180,255,.95)}
  #fieldToggleBtn.off .dot{background:rgba(255,255,255,.35)}

  /* Inspector Tooltip */
  #inspector{
    position:absolute;z-index:45;
    background:var(--panel2);
    border:1px solid var(--stroke);
    border-radius:var(--radius);padding:12px 14px;
    color:var(--text);font-size:12px;line-height:1.4;
    backdrop-filter:blur(10px);box-shadow:var(--shadow);
    pointer-events:none;transform:translate(-50%,-100%);
    margin-top:-15px;transition:opacity 0.15s;min-width:160px;
  }
  #inspector.hidden{opacity:0;}
  .insp-row{display:flex;justify-content:space-between;gap:12px;margin-top:5px;}
  .insp-lbl{color:var(--muted);}
  .insp-val{font-variant-numeric:tabular-nums;font-family:monospace;font-size:12px;}
  .insp-title{font-weight:650;color:var(--accent);border-bottom:1px solid var(--stroke2);padding-bottom:6px;margin-bottom:6px;text-align:center;}
  .insp-bar{height:4px;border-radius:2px;background:rgba(255,255,255,.1);margin-top:4px;margin-bottom:6px;overflow:hidden;}
  .insp-fill{height:100%; transition: width 0.1s linear;}

  @media (max-width: 720px){
    #ui{left:12px;right:12px;top:auto;bottom:12px;width:auto;height:min(76vh, 720px)}
    #hud{bottom:auto;top:12px;left:12px}
    .btns.wide{grid-template-columns:repeat(2, minmax(0,1fr))}
    .row select,.row input[type="number"],.row input[type="range"]{width:150px;max-width:150px}
  }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>
  <div id="uiToggle" title="Tap: show/hide settings • Hold: toggle field overlay">⚙️</div>
  <div id="ui">

  <div id="uiResizer" title="Drag to resize panel"></div>
  <div id="uiHeader">
    <div id="uiTitleRow">
      <div id="uiTitle">Dₙ/Aₙ Coxeter-plane • Graph↔Field • Hebbian Adaptive Edges</div>
      <div class="spacer"></div>
      <div class="miniBtn" id="uiSize" title="Toggle panel width">⤢</div>
      <div class="miniBtn" id="uiClose" title="Close (same as ⚙️)">✕</div>
    </div>

    <div id="uiPresetRow">
      <select id="presetSel" title="Presets (apply a tuned configuration)">
        <option value="custom">Presets… (custom)</option>
        <option value="fast">Fast Preview (stable)</option>
        <option value="slow">Slow Motion (stable)</option>
        <option value="quiet">Quiescent (low activity)</option>
        <option value="critical">Critical-ish (avalanches)</option>
        <option value="culture">Culture Dish (burst + plastic)</option>
        <option value="waves">Traveling Waves (field-driven)</option>
        <option value="neuromod">Neuromod Storm (bath-driven)</option>
        <option value="sync">Global Sync (coherent)</option>
        <option value="seizure">Overdrive Sync (seizure-y)</option>
        <option value="chaos">Edge Chaos (STP stress-test)</option>
      </select>
      <button id="presetApply" class="smallBtn" title="Apply selected preset">Apply</button>
    </div>

    <div id="uiSearchRow">
      <input id="uiSearch" type="text" placeholder="Search controls… (Press /)" autocomplete="off" spellcheck="false">
      <div class="miniBtn" id="uiClear" title="Clear search">⌫</div>
    </div>
    <div id="uiTabs" role="tablist" aria-label="Panels">
      <button class="tab" data-tab="all" aria-selected="true" type="button">All</button>
      <button class="tab" data-tab="sim" aria-selected="false" type="button">Run</button>
      <button class="tab" data-tab="build" aria-selected="false" type="button">Build</button>
      <button class="tab" data-tab="graph" aria-selected="false" type="button">Graph</button>
      <button class="tab" data-tab="field" aria-selected="false" type="button">Field</button>
      <button class="tab" data-tab="render" aria-selected="false" type="button">Render</button>
    </div>
  </div>
  <div id="uiBody">

<div class="btns wide">
      <button id="build">Build / Rebuild</button>
      <button id="stop">Stop build</button>
      <button id="reset">Reset view</button>
      <button id="seedAll">Seed ALL</button>
    </div>

    <details open class="section" data-tab="sim">
      <summary><span class="sumDot"></span><span class="sumText">Run + Gain</span><span class="sumMeta">runtime</span></summary>
      <div class="btns">
        <button id="run">Run</button>
        <button id="pause">Pause</button>
        <button id="kick">Kick (nudge)</button>
      </div>
      <div class="row"><label>steps / frame</label><input id="steps" type="range" min="1" max="40" step="1" value="16"></div>
      <div class="row"><label>GLOBAL GAIN</label><input id="globalGain" type="range" min="0" max="4" step="0.01" value="1.00"></div>
      <div class="row" style="margin-top:8px; color:var(--accent);"><small><b>ATP Energy Economy</b></small></div>
      <div class="row"><label>Thermodynamics ON</label><div class="chk"><input id="atp_on" type="checkbox" checked></div></div>
      <div class="row"><label>ATP Regen (Glucose)</label><input id="atp_regen" type="range" min="0.001" max="0.1" step="0.001" value="0.035"></div>
      <div class="row"><label>ATP Cost (Burn rate)</label><input id="atp_cost" type="range" min="0.01" max="0.5" step="0.01" value="0.12"></div>
      <div class="row"><label>ATP Diffusion (Blood Flow)</label><input id="atp_diff" type="range" min="0" max="1.0" step="0.01" value="0.35"></div>
      <div class="row"><label>Glial Buffer ON</label><div class="chk"><input id="glia_on" type="checkbox" checked></div></div>
      <div class="row"><label>Glial activation rate</label><input id="glia_drive" type="range" min="0" max="2.0" step="0.01" value="0.45"></div>
      <div class="row"><label>Glial clearance τ</label><input id="glia_tau" type="range" min="0.5" max="60" step="0.1" value="8.0"></div>
      <div class="row"><label>Glial diffusion</label><input id="glia_diff" type="range" min="0" max="0.5" step="0.01" value="0.08"></div>
      <div class="row"><label>Glia → ATP yield</label><input id="glia_yield" type="range" min="0" max="0.5" step="0.01" value="0.08"></div>
      <div class="row"><label>Glia mop strength</label><input id="glia_mop" type="range" min="0" max="1.0" step="0.01" value="0.35"></div>
      <div class="row"><label>Active Inference ON</label><div class="chk"><input id="ai_on" type="checkbox" checked></div></div>
      <div class="row"><label>Surprise threshold</label><input id="ai_thresh" type="range" min="0" max="1" step="0.01" value="0.22"></div>
      <div class="row"><label>Theta→Gamma PAC</label><div class="chk"><input id="pac_on" type="checkbox" checked></div></div>
      <div class="row"><label>PAC peak threshold</label><input id="pac_thresh" type="range" min="0" max="1" step="0.01" value="0.62"></div>
      <div class="row" style="margin-top:8px; color:var(--accent);"><small><b>Embodied Cognition (Retina)</b></small></div>
      <div class="row"><label>Webcam Retina</label><div class="chk"><input id="retina_cam" type="checkbox"></div></div>
      <div class="row"><label>Image Retina</label><div class="chk"><input id="retina_img" type="checkbox"></div></div>
      <div class="row"><label>Upload Image</label><input id="retina_file" type="file" accept="image/*" style="width:140px; font-size:11px; padding:4px;"></div>
      <div class="row"><label>Retina Gain (Forcing)</label><input id="retina_gain" type="range" min="0" max="40" step="0.1" value="15.0"></div>
      <div class="row" style="justify-content:center; margin-top:4px;"><canvas id="retina_preview" width="128" height="128" style="width:100px; height:100px; border:1px solid var(--stroke); border-radius:8px; display:none;"></canvas></div>
      <div class="row" style="margin-top:8px; color:var(--accent);"><small><b>Audio Sonification</b></small></div>
      <div class="row"><label>Audio ON</label><div class="chk"><input id="audio_on" type="checkbox"></div></div>
      <div class="row"><label>Volume</label><input id="audio_vol" type="range" min="0" max="1" step="0.01" value="0.30"></div>
      <div class="row"><label>Warmth</label><input id="audio_reverb" type="range" min="0" max="1" step="0.01" value="0.55"></div>
      <div class="row"><label>Brightness</label><input id="audio_bright" type="range" min="0" max="1" step="0.01" value="0.45"></div>
      <div class="row"><label>Root note</label>
        <select id="audio_root">
          <option value="48">C3</option>
          <option value="50">D3</option>
          <option value="52">E3</option>
          <option value="53" selected>F3</option>
          <option value="55">G3</option>
          <option value="57">A3</option>
        </select>
      </div>
      <div class="row"><label>Scale</label>
        <select id="audio_scale">
          <option value="penta_min" selected>Pentatonic minor</option>
          <option value="penta_maj">Pentatonic major</option>
          <option value="aeolian">Aeolian (natural minor)</option>
          <option value="mixolydian">Mixolydian</option>
          <option value="whole">Whole tone</option>
        </select>
      </div>
    </details>

    <details open class="section" data-tab="build">
      <summary><span class="sumDot"></span><span class="sumText">Build</span><span class="sumMeta">shape / wiring</span></summary>

      <div class="row"><label>shape</label>
        <select id="shape">
                    <option value="demihypercube" selected>demihypercube (Dₙ half-cube)</option>
          <option value="simplex">simplex (Aₙ)</option>
          <option value="hypercube">hypercube (Bₙ / Cₙ)</option>
          <option value="crosspolytope">cross-polytope / orthoplex</option>

        </select>
      </div>

      <div class="row"><label>dimension n (Dₙ / Aₙ)</label><input id="n" type="number" min="2" step="1" value="16"></div>
      <div class="row"><label>Exact Isomorphic build (n ≤ 18)</label><div class="chk"><input id="exactFull" type="checkbox" checked></div></div>

      <div class="row" style="margin-top:8px; color:var(--accent);"><small><b>Cortical Columns (Lobes)</b></small></div>
      <div class="row"><label>Lobes (Modules)</label><input id="lobes" type="range" min="1" max="8" step="1" value="4"></div>
      <div class="row"><label>White Matter (Inter-lobe %)</label><input id="whiteMatter" type="range" min="0.001" max="0.1" step="0.001" value="0.015"></div>

      <div class="row" style="margin-top:8px; color:var(--accent);"><small><b>Approximation Limits</b></small></div>
      <div class="row"><label>shells (orbit layers) — non-exact only</label><input id="shells" type="number" min="1" step="1" value="20"></div>

      <div class="row"><label>pairs (for demihypercube edges)</label>
        <select id="pairs">
          <option value="chain" selected>chain (sparse, faster)</option>
          <option value="chain2">chain2 (moderate)</option>
          <option value="random">random pairs (cap)</option>
          <option value="allpairs">ALL (dense, accurate)</option>
        </select>
      </div>
      <div class="row"><label>pair cap (0=auto)</label><input id="paircap" type="number" min="0" step="1" value="0"></div>

      <div class="row"><label>candidates (raw orbit verts) — non-exact only</label><input id="cands" type="number" min="256" step="256" value="250000"></div>

      <div class="row"><label>merge target (node count) — non-exact only</label><input id="mergeQ" type="range" min="300" max="100000" step="25" value="65536"></div>
      <div class="row"><label>edge stride (keep 1/N edges)</label><input id="edgeStride" type="range" min="1" max="20" step="1" value="1"></div>
      <div class="row"><label>max degree (neighbors/node)</label><input id="degK" type="range" min="4" max="32" step="1" value="32"></div>
    </details>

    <details open class="section" data-tab="graph">
      <summary><span class="sumDot"></span><span class="sumText">Graph</span><span class="sumMeta">oscillators</span></summary>
      <div class="row"><label>Inhibitory % (Dale's Law)</label><input id="g_inhib" type="range" min="0" max="1" step="0.01" value="0.20"></div>
      <div class="row"><label>graph dt</label><input id="g_dt" type="range" min="0.001" max="0.05" step="0.001" value="0.012"></div>
      <div class="row"><label>graph K1</label><input id="g_K1" type="range" min="0" max="14" step="0.01" value="2.80"></div>
      <div class="row"><label>graph α1</label><input id="g_a1" type="range" min="0" max="1.4" step="0.01" value="0.72"></div>
      <div class="row"><label>graph K2</label><input id="g_K2" type="range" min="0" max="14" step="0.01" value="1.40"></div>
      <div class="row"><label>graph α2</label><input id="g_a2" type="range" min="0" max="1.4" step="0.01" value="0.32"></div>
      <div class="row"><label>gauge γ</label><input id="g_gauge" type="range" min="0" max="6" step="0.01" value="1.20"></div>
      <div class="row"><label>vector wind</label><input id="g_wind" type="range" min="-10" max="10" step="0.1" value="0.0"></div>
      <div class="row"><label>node motility (move)</label><input id="g_move" type="range" min="0" max="2.0" step="0.01" value="0.0"></div>
      <div class="row"><label>inertial (2nd order)</label><input id="g_inertialOn" type="checkbox" checked></div>
      <div class="row"><label>damping η</label><input id="g_eta" type="range" min="0" max="4" step="0.01" value="0.85"></div>
      <div class="row"><label>vmax</label><input id="g_vmax" type="range" min="1" max="40" step="0.1" value="18"></div>
      <div class="row"><label>topo ON</label><div class="chk"><input id="topoOn" type="checkbox" checked></div></div>
      <div class="row"><label>flux→K</label><input id="fluxBoost" type="range" min="0" max="6" step="0.01" value="0.40"></div>
      <div class="row"><label>flux→field</label><input id="Kflux" type="range" min="-6" max="6" step="0.01" value="0.40"></div>
      <div class="row"><label>flux→infl</label><input id="fluxSwirl" type="range" min="0" max="6" step="0.01" value="0.40"></div>

      <div class="row"><label>defects ON</label><div class="chk"><input id="defectOn" type="checkbox" checked></div></div>
      <div class="row"><label>defect→K</label><input id="defBoost" type="range" min="0" max="6" step="0.01" value="0.40"></div>
      <div class="row"><label>defect→field</label><input id="Kdef" type="range" min="-6" max="6" step="0.01" value="0.40"></div>
      <div class="row"><label>defect→infl swirl</label><input id="defSwirl" type="range" min="0" max="8" step="0.01" value="0.60"></div>
      <div class="row"><label>defect→infl inject</label><input id="defInject" type="range" min="0" max="8" step="0.01" value="0.35"></div>
      <div class="row"><label>delay ON</label><div class="chk"><input id="g_delayOn" type="checkbox"></div></div>
      <div class="row"><label>delay steps</label><input id="g_delaySteps" type="range" min="0" max="24" step="1" value="12"></div>
      <div class="row"><label>delay mix</label><input id="g_delayMix" type="range" min="0" max="1" step="0.01" value="0.90"></div>
      <div class="row" style="margin-top:8px; color:var(--accent);"><small><b>Axonal Conduction Delays</b></small></div>
      <div class="row"><label>Axonal delay ON</label><div class="chk"><input id="axon_on" type="checkbox"></div></div>
      <div class="row"><label>Conduction speed</label><input id="axon_speed" type="range" min="0.05" max="3.0" step="0.01" value="1.00"></div>
      <div class="row"><label>global coupling Kg</label><input id="g_Kg" type="range" min="0" max="14" step="0.01" value="0.00"></div>
      <div class="row"><label>global lag αg</label><input id="g_ag" type="range" min="0" max="1.4" step="0.01" value="0.20"></div>
      <div class="row"><label>noise</label><input id="g_noise" type="range" min="0" max="3.0" step="0.01" value="0.18"></div>
      <div class="row"><label>omega spread</label><input id="g_omega" type="range" min="0" max="1.8" step="0.01" value="0.36"></div>

      <details open>
        <summary>Gating</summary>
        <div class="row"><label>gating ON</label><div class="chk"><input id="gate_on" type="checkbox" checked></div></div>
        <div class="row"><label>gate low</label><input id="gate_lo" type="range" min="0" max="2.0" step="0.01" value="0.06"></div>
        <div class="row"><label>gate high</label><input id="gate_hi" type="range" min="0" max="2.0" step="0.01" value="0.18"></div>
        <div class="row"><label>gate boost</label><input id="gate_boost" type="range" min="0" max="4.0" step="0.01" value="0.80"></div>
      </details>

      <details open>
        <summary>Intrinsic Plasticity (Homeostasis)</summary>
        <div class="row"><label>Homeostasis ON</label><div class="chk"><input id="homeo_on" type="checkbox" checked></div></div>
        <div class="row"><label>Target Activity A₀</label><input id="homeo_target" type="range" min="0.05" max="0.8" step="0.01" value="0.30"></div>
        <div class="row"><label>Adaptation Rate</label><input id="homeo_rate" type="range" min="0.001" max="0.5" step="0.001" value="0.08"></div>
        <div class="row"><label>Dynamic Target (Metaplasticity)</label><div class="chk"><input id="homeo_meta" type="checkbox" checked></div></div>
      </details>

      <details open>
        <summary>Hebbian Learning</summary>
        <div class="row"><label>Hebbian ON</label><div class="chk"><input id="hebb_on" type="checkbox" checked></div></div>
        <div class="row"><label>learning rate η</label><input id="hebb_lr" type="range" min="0" max="0.1" step="0.0001" value="0.0080"></div>
        <div class="row"><label>decay λ</label><input id="hebb_decay" type="range" min="0" max="0.05" step="0.0001" value="0.0040"></div>
        <div class="row"><label>rest weight w₀</label><input id="hebb_w0" type="range" min="0.1" max="2.0" step="0.01" value="1.00"></div>
        <div class="row"><label>weight min</label><input id="hebb_wmin" type="range" min="0" max="1.0" step="0.01" value="0.05"></div>
        <div class="row"><label>weight max</label><input id="hebb_wmax" type="range" min="0.5" max="4.0" step="0.01" value="2.50"></div>
        <div class="row"><label>competition rate</label><input id="hebb_norm" type="range" min="0" max="0.1" step="0.0001" value="0.0150"></div>
        <div class="row"><label>STDP asym</label><input id="hebb_stdp" type="range" min="0" max="1.0" step="0.01" value="0.00"></div>
        <div class="row"><label>Inhibitory anti-sync</label><input id="hebb_inhib" type="range" min="0" max="2.0" step="0.01" value="0.85"></div>
        <div class="row"><label>edge glow (weight→vis)</label><input id="hebb_glow" type="range" min="0" max="1.0" step="0.01" value="0.70"></div>
        <div class="row"><label>structural plasticity (rewire)</label><div class="chk"><input id="hebb_rewire" type="checkbox" checked></div></div>
        <div class="row"><label>Reset weights</label><button id="hebbReset" style="flex:none;min-width:80px">Reset</button></div>

      <details open>
        <summary>Short‑Term Plasticity (STP)</summary>
        <div class="row"><label>STP ON</label><div class="chk"><input id="stp_on" type="checkbox" checked></div></div>
        <div class="row"><label>baseline utilization U</label><input id="stp_U" type="range" min="0.02" max="0.9" step="0.01" value="0.25"></div>
        <div class="row"><label>depression τD</label><input id="stp_tauD" type="range" min="0.05" max="8.0" step="0.01" value="1.20"></div>
        <div class="row"><label>facilitation τF</label><input id="stp_tauF" type="range" min="0.05" max="8.0" step="0.01" value="0.90"></div>
        <div class="row"><label>activity gain</label><input id="stp_actGain" type="range" min="0" max="6.0" step="0.01" value="1.60"></div>
        <div class="row"><label>STP max factor</label><input id="stp_max" type="range" min="0.5" max="4.0" step="0.01" value="2.20"></div>
        <div class="row"><label>Reset STP</label><button id="stpReset" style="flex:none;min-width:80px">Reset</button></div>
      </details>
      </details>
    </details>

    <details open class="section" data-tab="field">
      <summary><span class="sumDot"></span><span class="sumText">Field + Coupling</span><span class="sumMeta">PDE</span></summary>
      <div class="row"><label>field size (N×N)</label>
        <select id="f_N">
          <option>128</option>
          <option>192</option>
          <option selected>256</option>
          <option>320</option>
          <option>4096</option>
        </select>
      </div>
      <div class="row"><label>field dt</label><input id="f_dt" type="range" min="0.001" max="0.05" step="0.001" value="0.012"></div>
      <div class="row"><label>field Ke</label><input id="f_Ke" type="range" min="0" max="6" step="0.01" value="2.45"></div>
      <div class="row"><label>field Ki</label><input id="f_Ki" type="range" min="0" max="6" step="0.01" value="1.65"></div>
      <div class="row"><label>field α1</label><input id="f_a1" type="range" min="0" max="1.4" step="0.01" value="1.10"></div>
      <div class="row"><label>field K2</label><input id="f_K2" type="range" min="0" max="6" step="0.01" value="1.85"></div>
      <div class="row"><label>field α2</label><input id="f_a2" type="range" min="0" max="1.4" step="0.01" value="0.42"></div>
      <div class="row"><label>field delay ON</label><div class="chk"><input id="f_delayOn" type="checkbox"></div></div>
      <div class="row"><label>field delay steps</label><input id="f_delaySteps" type="range" min="0" max="24" step="1" value="12"></div>
      <div class="row"><label>field omega spread</label><input id="f_omega" type="range" min="0" max="1.0" step="0.01" value="0.20"></div>

      <div class="row"><label>show field background</label><div class="chk"><input id="f_show" type="checkbox" checked></div></div>
      <div class="row"><label>field alpha (render)</label><input id="f_alphaDraw" type="range" min="0" max="1" step="0.01" value="0.22"></div>

      <div class="row"><label>curvature warp</label><input id="phiWarp" type="range" min="-3" max="3" step="0.01" value="0.25"></div>
      <div class="row" style="margin-top:8px; color:var(--accent);"><small><b>CEMI Theory (Wave Dynamics)</b></small></div>
      <div class="row"><label>CEMI EM Emission</label><input id="cemi_emit" type="range" min="0" max="10" step="0.01" value="0.80"></div>
      <div class="row"><label>CEMI Ephaptic Force</label><input id="cemi_couple" type="range" min="0" max="15" step="0.01" value="1.20"></div>
      <div class="row"><label>wave speed (c)</label><input id="wave_speed" type="range" min="0.1" max="5.0" step="0.01" value="2.00"></div>
      <div class="row"><label>wave damping</label><input id="wave_damp" type="range" min="0.01" max="1.0" step="0.01" value="0.28"></div>
      <div class="row"><label>curvature diff</label><input id="phiDiff" type="range" min="0" max="0.5" step="0.001" value="0.06"></div>
      <div class="row"><label>curvature relax</label><input id="phiRelax" type="range" min="0" max="1.0" step="0.001" value="0.08"></div>
      <div class="row"><label>defects→curvature</label><input id="phiInject" type="range" min="0" max="2.5" step="0.001" value="0.15"></div>

      <div class="row"><label>global curvature ON</label><div class="chk"><input id="phiGlobalOn" type="checkbox" checked></div></div>
      <div class="row"><label>curvature target mean</label><input id="phiTarget" type="range" min="-1" max="1" step="0.001" value="0.00"></div>
      <div class="row"><label>global curvature rate</label><input id="phiGlobalRate" type="range" min="0" max="2.0" step="0.001" value="0.25"></div>

      <div class="row"><label>Graph → Field ON</label><div class="chk"><input id="gf_on" type="checkbox" checked></div></div>
      <div class="row"><label>G→F strength Kgf</label><input id="Kgf" type="range" min="0" max="16" step="0.01" value="2.80"></div>
      <div class="row"><label>G→F phase lag αgf</label><input id="agf" type="range" min="0" max="1.4" step="0.01" value="0.48"></div>
      <div class="row"><label>splat radius (px)</label><input id="splatR" type="range" min="1" max="22" step="1" value="6"></div>
      <div class="row"><label>splat gain</label><input id="splatGain" type="range" min="0.05" max="12" step="0.01" value="1.40"></div>

      <div class="row"><label>influence decay</label><input id="inflDecay" type="range" min="0" max="0.99" step="0.01" value="0.970"></div>

      <div class="row"><label>Field → Graph ON</label><div class="chk"><input id="fg_on" type="checkbox" checked></div></div>
      <div class="row"><label>F→G strength Kfg</label><input id="Kfg" type="range" min="0" max="16" step="0.01" value="1.60"></div>
      <div class="row"><label>F→G phase lag αfg</label><input id="afg" type="range" min="0" max="1.4" step="0.01" value="0.26"></div>
      <div class="hr"></div>
      <div class="subttl">Multi-Chemical Baths (DA, GLU, GABA)</div>
      <div class="row"><label>chemicals ON</label><div class="chk"><input id="nm_on" type="checkbox" checked></div></div>
      <div class="row"><label>resting baseline</label><input id="nm_base" type="range" min="0.0" max="0.6" step="0.01" value="0.18"></div>
      <div class="row"><label>decay τ (clearance)</label><input id="nm_tau" type="range" min="0.5" max="60" step="0.1" value="5.0"></div>
      <div class="row"><label>diffusion D</label><input id="nm_D" type="range" min="0" max="3.0" step="0.01" value="0.55"></div>
      <div class="row"><label>release rate</label><input id="nm_drive" type="range" min="0" max="4.0" step="0.01" value="0.80"></div>
      <div class="row"><label>GLU/GABA → coupling</label><input id="nm_gainK" type="range" min="0" max="3.0" step="0.01" value="0.70"></div>
      <div class="row"><label>DA → plasticity</label><input id="nm_gainLR" type="range" min="0" max="3.0" step="0.01" value="2.00"></div>
      <div class="row"><button class="btn" id="nm_reset">Reset chemical baths</button></div>
    </details>

    <details open class="section" data-tab="render">
      <summary><span class="sumDot"></span><span class="sumText">Rendering</span><span class="sumMeta">visual</span></summary>
      <div class="row"><label>edge alpha</label><input id="edgeA" type="range" min="0.002" max="0.55" step="0.001" value="0.10"></div>
      <div class="row"><label>color mode</label><select id="colorMode">
        <option value="0">Phase Rainbow</option>
        <option value="1">Phase Diverging (Cool↔Warm)</option>
        <option value="2">Fire</option>
        <option value="3">Monochrome</option>
        <option value="4">E/I Cell Type</option>
        <option value="5">Synaptic Weight</option>
        <option value="6">Ocean</option>
        <option value="7">Neon Plasma</option>
        <option value="8">Phase Coherence</option>
        <option value="9">Frequency Band</option>
        <option value="10">CEMI EM Field</option>
        <option value="11">DA / GLU / GABA</option>
      </select></div>
      <div class="row"><label>edge color from FIELD</label><div class="chk"><input id="edgeFromField" type="checkbox" checked></div></div>
      <div class="row"><label>phase-only colors</label><div class="chk"><input id="phaseOnly" type="checkbox" checked></div></div>
      <div class="row"><label>animate palette</label><div class="chk"><input id="palOn" type="checkbox"></div></div>
      <div class="row"><label>palette speed</label><input id="palSpd" type="range" min="0" max="2.5" step="0.01" value="0.16"></div>
      <div class="row"><label>edge draw fraction (render-only)</label><input id="edgeFrac" type="range" min="0.05" max="1" step="0.01" value="1"></div>
      <div class="row"><label>adaptive edge culling (FPS save)</label><div class="chk"><input id="edgeAdaptive" type="checkbox" checked></div></div>
    </details>

    <div class="progressBox">
      <progress id="prog" max="1" value="0"></progress>
      <div id="progText">Idle.</div>
    </div>
    <div id="status">Booting…</div>
  
  </div>

</div>

  <div id="tip" class="tip"></div>
  <div id="hud">HUD…</div>
  <button id="fieldToggleBtn" type="button" title="Toggle field overlay"><span class="dot"></span><span class="txt">Hide Field</span></button>

  <div id="inspector" class="hidden">
    <div class="insp-title">Lobe Telemetry</div>
    <div class="insp-row"><span class="insp-lbl">Local ATP</span><span class="insp-val" id="insp_atp">0.00</span></div>
    <div class="insp-bar"><div class="insp-fill" id="insp_atp_bar" style="width:0%; background:#4aff8a"></div></div>

    <div class="insp-row"><span class="insp-lbl">Dopamine</span><span class="insp-val" id="insp_da">0.00</span></div>
    <div class="insp-bar"><div class="insp-fill" id="insp_da_bar" style="width:0%; background:#ff4a4a"></div></div>

    <div class="insp-row"><span class="insp-lbl">Glutamate</span><span class="insp-val" id="insp_glu">0.00</span></div>
    <div class="insp-bar"><div class="insp-fill" id="insp_glu_bar" style="width:0%; background:#4aa4ff"></div></div>

    <div class="insp-row"><span class="insp-lbl">GABA</span><span class="insp-val" id="insp_gaba">0.00</span></div>
    <div class="insp-bar"><div class="insp-fill" id="insp_gaba_bar" style="width:0%; background:#a44aff"></div></div>

    <div class="insp-row" style="margin-top:8px"><span class="insp-lbl">Field Phase</span><span class="insp-val" id="insp_phi">0.00</span></div>
    <div class="insp-row"><span class="insp-lbl">Field Velocity</span><span class="insp-val" id="insp_act">0.00</span></div>
  </div>
</div>

<script>
// Global shader source (declared in global scope so it is always defined)
var FULL_VS;

// Global error surfacing (helps debug black-screen failures)
window.addEventListener('error', (e)=>{
  try{
    const s=document.getElementById('status');
    const msg = (e && (e.message || (e.error && e.error.message))) || String(e);
    if(s) s.textContent = 'ERROR: ' + msg + (e && e.lineno ? `\n@${e.filename||''}:${e.lineno}:${e.colno||0}` : '');
    const h=document.getElementById('hud');
    if(h) h.textContent = (s?s.textContent:('ERROR: '+msg));
    const ui=document.getElementById('ui');
    if(ui) ui.classList.remove('hidden');
  }catch(_){/* noop */}
});
window.addEventListener('unhandledrejection', (e)=>{
  try{
    const s=document.getElementById('status');
    const r = e && e.reason;
    const msg = (r && (r.message||r.stack)) || String(r||e);
    if(s) s.textContent = 'UNHANDLED PROMISE: ' + msg;
    const h=document.getElementById('hud');
    if(h) h.textContent = (s?s.textContent:('UNHANDLED PROMISE: '+msg));
    const ui=document.getElementById('ui');
    if(ui) ui.classList.remove('hidden');
  }catch(_){/* noop */}
});

(() => {
  const canvas = document.getElementById('c');
  const gl = canvas.getContext('webgl2', { antialias:false, preserveDrawingBuffer:false, powerPreference:'high-performance', alpha:false, depth:false, stencil:false, premultipliedAlpha:false, desynchronized:true });
  const MAX_TEX_UNITS = gl ? (gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS) || 16) : 0;
  const hudEl = document.getElementById('hud');
  const ui = document.getElementById('ui');
  const uiToggle = document.getElementById('uiToggle');
  const $ = (id)=>document.getElementById(id);

  // ==== Better UI wiring (tabs/search/resize/hotkeys) ====
  const uiSearch = document.getElementById('uiSearch');
  const uiClear  = document.getElementById('uiClear');
  const uiClose  = document.getElementById('uiClose');
  const uiSize   = document.getElementById('uiSize');
  const uiResizer= document.getElementById('uiResizer');
  const presetSel = document.getElementById('presetSel');
  const presetApply = document.getElementById('presetApply');

  const TAB_ORDER = ['all','sim','build','graph','field','render'];
  let activeTab = 'all';

  function setTab(tab){
    activeTab = tab;
    for(const b of ui.querySelectorAll('#uiTabs .tab')){
      const on = (b.dataset.tab === tab);
      b.setAttribute('aria-selected', on ? 'true' : 'false');
    }
    applyFilters();
  }

  function applyFilters(){
    const q = (uiSearch?.value || '').trim().toLowerCase();

    // Filter sections by tab and query
    const sections = [...ui.querySelectorAll('details.section')];
    for(const sec of sections){
      const tab = sec.dataset.tab || 'all';
      const tabOk = (activeTab==='all' || tab===activeTab);

      // Query check: match section title OR any label text within
      let qOk = true;
      if(q){
        const sum = sec.querySelector('summary')?.innerText?.toLowerCase() || '';
        const labels = [...sec.querySelectorAll('label')].map(l=>l.innerText.toLowerCase()).join(' ');
        qOk = (sum.includes(q) || labels.includes(q));
      }

      sec.style.display = (tabOk && qOk) ? '' : 'none';
    }

    // Additionally filter individual rows inside visible sections (for finer search)
    if(q){
      for(const sec of sections){
        if(sec.style.display==='none') continue;
        for(const row of sec.querySelectorAll('.row')){
          const t = row.innerText.toLowerCase();
          row.style.display = t.includes(q) ? '' : 'none';
        }
      }
    }else{
      for(const sec of sections){
        for(const row of sec.querySelectorAll('.row')) row.style.display = '';
      }
    }
  }

  // Toggle show/hide panel
  function toggleUI(force){
    const willHide = (force!==undefined) ? !force : !ui.classList.contains('hidden');
    ui.classList.toggle('hidden', willHide);
  }
  
uiToggle.addEventListener('click', ()=>toggleUI());
  uiClose?.addEventListener('click', ()=>toggleUI(false)); // close means hide

  // Size cycle
  const SIZE_CLASSES = ['compact','wide','max'];
  uiSize?.addEventListener('click', ()=>{
    let i = SIZE_CLASSES.findIndex(c=>ui.classList.contains(c));
    if(i<0){ ui.classList.add(SIZE_CLASSES[0]); return; }
    ui.classList.remove(SIZE_CLASSES[i]);
    ui.classList.add(SIZE_CLASSES[(i+1)%SIZE_CLASSES.length]);
  });

  // Tabs
  for(const b of ui.querySelectorAll('#uiTabs .tab')){
    b.addEventListener('click', ()=>setTab(b.dataset.tab));
  }

  // Search
  uiSearch?.addEventListener('input', applyFilters, { passive:true });
  uiClear?.addEventListener('click', ()=>{
    if(uiSearch) uiSearch.value = '';
    applyFilters();
    uiSearch?.focus();
  });

  // Hotkeys: ` toggles panel, / focuses search, Esc clears/blur
  window.addEventListener('keydown', (e)=>{
    if(e.key==='`'){ toggleUI(); e.preventDefault(); }
    if(e.key==='/' && !e.ctrlKey && !e.metaKey && !e.altKey){
      const tag = (document.activeElement?.tagName || '').toLowerCase();
      if(tag!=='input' && tag!=='textarea'){
        uiSearch?.focus(); e.preventDefault();
      }
    }
    if(e.key==='Escape'){
      if(document.activeElement===uiSearch){
        uiSearch.value=''; uiSearch.blur(); applyFilters();
        e.preventDefault();
      }
    }
  });

  // Resizer (desktop)
  if(uiResizer){
    let startX=0, startW=0, dragging=false;
    const onMove = (ev)=>{
      if(!dragging) return;
      const dx = (ev.clientX - startX);
      const w = Math.max(260, Math.min(window.innerWidth - 24, startW + dx));
      ui.style.width = w + 'px';
    };
    const onUp = ()=>{
      if(!dragging) return;
      dragging=false;
      window.removeEventListener('pointermove', onMove);
      window.removeEventListener('pointerup', onUp);
    };
    uiResizer.addEventListener('pointerdown', (ev)=>{
      dragging=true;
      startX = ev.clientX;
      startW = ui.getBoundingClientRect().width;
      uiResizer.setPointerCapture?.(ev.pointerId);
      window.addEventListener('pointermove', onMove);
      window.addEventListener('pointerup', onUp);
    });
  }

  // Finally: enhance rows & apply initial filters
  enhanceUI();
  applyFilters();
  // ==== End Better UI wiring ====

  if (!gl) { $('status').textContent = "WebGL2 not available."; return; }

  const buildBtn=$('build'), stopBtn=$('stop'), resetBtn=$('reset'), seedAllBtn=$('seedAll');
  const runBtn=$('run'), pauseBtn=$('pause'), kickBtn=$('kick');
  const stepsEl=$('steps'), globalGainEl=$('globalGain');
  const atp_onEl=$('atp_on'), atp_regenEl=$('atp_regen'), atp_costEl=$('atp_cost'), atp_diffEl=$('atp_diff');
  const homeo_onEl=$('homeo_on'), homeo_targetEl=$('homeo_target'), homeo_rateEl=$('homeo_rate'), homeo_metaEl=$('homeo_meta');

  const glia_onEl=$('glia_on'), glia_driveEl=$('glia_drive'), glia_tauEl=$('glia_tau'), glia_diffEl=$('glia_diff'), glia_yieldEl=$('glia_yield'), glia_mopEl=$('glia_mop');
  const ai_onEl=$('ai_on'), ai_threshEl=$('ai_thresh'), pac_onEl=$('pac_on'), pac_threshEl=$('pac_thresh');
  const retina_camEl=$('retina_cam'), retina_imgEl=$('retina_img'), retina_fileEl=$('retina_file'), retina_gainEl=$('retina_gain'), retina_previewEl=$('retina_preview');

  const shapeEl=$('shape');
  const nEl=$('n'), shellsEl=$('shells'), pairsEl=$('pairs'), paircapEl=$('paircap'), candsEl=$('cands');
  const mergeQEl=$('mergeQ'), edgeStrideEl=$('edgeStride'), degKEl=$('degK'), exactFullEl=$('exactFull');

  const g_dtEl=$('g_dt'), g_K1El=$('g_K1'), g_a1El=$('g_a1'), g_K2El=$('g_K2'), g_a2El=$('g_a2'), g_gaugeEl=$('g_gauge'), g_windEl=$('g_wind'),
        g_inertialOnEl=$('g_inertialOn'), g_etaEl=$('g_eta'), g_vmaxEl=$('g_vmax');
  const topoOnEl=$('topoOn'), fluxBoostEl=$('fluxBoost'), KfluxEl=$('Kflux'), fluxSwirlEl=$('fluxSwirl');
  const defectOnEl=$('defectOn'), defBoostEl=$('defBoost'), KdefEl=$('Kdef'), defSwirlEl=$('defSwirl'), defInjectEl=$('defInject');
  const g_delayOnEl=$('g_delayOn'), g_delayStepsEl=$('g_delaySteps'), g_delayMixEl=$('g_delayMix');
  const axon_onEl=$('axon_on'), axon_speedEl=$('axon_speed');
  const g_KgEl=$('g_Kg'), g_agEl=$('g_ag'), g_noiseEl=$('g_noise'), g_omegaEl=$('g_omega');
  const gate_onEl=$('gate_on'), gate_loEl=$('gate_lo'), gate_hiEl=$('gate_hi'), gate_boostEl=$('gate_boost');
  const hebb_onEl=$('hebb_on'), hebb_lrEl=$('hebb_lr'), hebb_decayEl=$('hebb_decay');
  const hebb_w0El=$('hebb_w0'), hebb_wminEl=$('hebb_wmin'), hebb_wmaxEl=$('hebb_wmax');
  const hebb_normEl=$('hebb_norm');
  const hebb_inhibEl=$('hebb_inhib');
  const hebb_rewireEl=$('hebb_rewire');
  const hebb_stdpEl=$('hebb_stdp'), hebb_glowEl=$('hebb_glow'), hebbResetBtn=$('hebbReset');

  const stp_onEl=$('stp_on'), stp_UEl=$('stp_U'), stp_tauDEl=$('stp_tauD'), stp_tauFEl=$('stp_tauF'), stp_actGainEl=$('stp_actGain'), stp_maxEl=$('stp_max'), stpResetBtn=$('stpReset');

  const f_NEl=$('f_N'), f_dtEl=$('f_dt'), f_KeEl=$('f_Ke'), f_KiEl=$('f_Ki'), f_a1El=$('f_a1');
  const f_K2El=$('f_K2'), f_a2El=$('f_a2'), f_delayOnEl=$('f_delayOn'), f_delayStepsEl=$('f_delaySteps'), f_omegaEl=$('f_omega');
  const f_showEl=$('f_show'), f_alphaDrawEl=$('f_alphaDraw');
  const fieldToggleBtn=$('fieldToggleBtn');
  // Bottom field toggle button (outside menu)
  function syncFieldToggleBtn(){
    if(!fieldToggleBtn) return;
    const on = !!f_showEl.checked;
    fieldToggleBtn.classList.toggle('off', !on);
    const txt = fieldToggleBtn.querySelector('.txt');
    if(txt) txt.textContent = on ? 'Hide Field' : 'Show Field';
  }
  if(fieldToggleBtn){
    fieldToggleBtn.addEventListener('click', ()=>{
      f_showEl.checked = !f_showEl.checked;
      syncFieldToggleBtn();
    });
  }
  if(f_showEl){
    f_showEl.addEventListener('change', syncFieldToggleBtn);
  }


  const phiWarpEl=$('phiWarp'), phiDiffEl=$('phiDiff'), phiRelaxEl=$('phiRelax'), phiInjectEl=$('phiInject');
  const nm_onEl=$('nm_on'), nm_baseEl=$('nm_base'), nm_tauEl=$('nm_tau'), nm_DEl=$('nm_D'), nm_driveEl=$('nm_drive'), nm_gainKEl=$('nm_gainK'), nm_gainLREl=$('nm_gainLR'), nm_resetBtn=$('nm_reset');
  const phiGlobalOnEl=$('phiGlobalOn'), phiTargetEl=$('phiTarget'), phiGlobalRateEl=$('phiGlobalRate');

  const gf_onEl=$('gf_on'), KgfEl=$('Kgf'), agfEl=$('agf'), splatREl=$('splatR'), splatGainEl=$('splatGain');
  const inflDecayEl=$('inflDecay');
  const fg_onEl=$('fg_on'), KfgEl=$('Kfg'), afgEl=$('afg');

  const edgeAEl=$('edgeA'), edgeFromFieldEl=$('edgeFromField');
  const phaseOnlyEl=$('phaseOnly'), palOnEl=$('palOn'), palSpdEl=$('palSpd');
  const colorModeEl=$('colorMode');
  const edgeFracEl=$('edgeFrac');
  const edgeAdaptiveEl=$('edgeAdaptive');

  const statusEl=$('status'), progEl=$('prog'), progTextEl=$('progText');

  // ===== UI helpers: inline info + live values (auto for every row) =====
  const tipEl = $('tip');
  const UI_INFO = {
    // Run + Gain
    steps: "Simulation sub-steps per rendered frame. Higher = faster evolution but more GPU work.",
    globalGain: "Master multiplier applied to most coupling strengths and splat gain.",
    // Build
    shape: "Choose the polytope family. Demihypercube uses Dₙ Coxeter-plane. Simplex Aₙ becomes a regular (n+1)-gon here.",
    n: "Dimension parameter n. For simplex Aₙ, the projected polygon has (n+1) vertices.",
    exactFull: "Demihypercube only: build the full even-parity vertex set (n ≤ 16). Symmetric and accurate but can be heavy.",
    shells: "Non-exact demihypercube: BFS orbit depth. More shells = more raw vertices before merge.",
    pairs: "Which coordinate-pair flips generate the orbit / wiring. ALL is densest; chain modes are lighter and clearer.",
    paircap: "Limit number of pairs in random/allpairs approximations (0 = auto).",
    cands: "Maximum raw orbit vertices sampled before merging.",
    mergeQ: "Target merged node count (non-exact demihypercube). Higher keeps more detail.",
    edgeStride: "Keep 1/N edges for rendering and adjacency packing (performance knob).",
    degK: "Max neighbors per node used for coupling (caps work per step).",
    // Graph
    g_dt: "Graph integrator timestep.",
    g_K1: "1st-harmonic coupling strength.",
    g_a1: "Phase lag for 1st-harmonic coupling.",
    g_K2: "2nd-harmonic coupling strength.",
    g_a2: "Phase lag for 2nd-harmonic coupling.",
    g_delayOn: "Enable delayed neighbor phase mixing.",
    g_delaySteps: "Delay length in simulation steps.",
    g_delayMix: "0 = no delay, 1 = full delayed phase. Mix between current and delayed.",
    axon_on: "Enable distance-proportional axonal conduction delays. Near neighbors couple instantly; distant neighbors couple with a delay proportional to their spatial distance.",
    axon_speed: "Conduction velocity (higher = faster signal propagation = less delay for a given distance). At low values, distant connections are heavily delayed, producing traveling waves.",
    audio_on: "Enable sonification. 4 regional voices track network dynamics in real-time: volume follows activity bursts, pitch tracks velocity, harmony reflects synchronization.",
    audio_vol: "Master volume for the audio engine.",
    audio_reverb: "Warmth control. Higher = darker, more muffled. Lower = more open, airy. Works with brightness slider.",
    audio_bright: "Master brightness filter. Low = warm/dark, high = bright/airy. Network velocity also modulates brightness.",
    audio_root: "Root note for the musical scale. All voices quantize to scale degrees above this root.",
    audio_scale: "Musical scale for pitch quantization. Pentatonic scales are always consonant; modal scales add more color.",
    g_Kg: "Global order-parameter coupling strength.",
    g_ag: "Global coupling phase lag.",
    g_noise: "Additive phase noise amplitude.",
    g_omega: "Natural frequency spread (heterogeneity).",
    gate_on: "Enable gating using local influence amplitude (from splats).",
    gate_lo: "Gating lower threshold.",
    gate_hi: "Gating upper threshold.",
    gate_boost: "How strongly gating amplifies local coupling / F→G term.",
    // Hebbian Learning
    hebb_on: "Enable Hebbian/STDP adaptive edge weights. Synchronized edges strengthen; out-of-phase edges weaken.",
    hebb_lr: "Learning rate η. How quickly weights adapt to phase correlations.",
    hebb_decay: "Homeostatic decay λ. Pulls weights back toward rest weight w₀ to prevent runaway.",
    hebb_w0: "Rest weight w₀. Weights decay toward this value (1.0 = no net effect).",
    hebb_wmin: "Minimum allowed edge weight.",
    hebb_wmax: "Maximum allowed edge weight.",
    hebb_norm: "Synaptic competition. Forces the sum of a node's edge weights to normalize, carving out sparse networks.",
    hebb_stdp: "STDP asymmetry: 0 = pure Hebbian (cos), 1 = spike-timing (velocity-based directional bias).",
    hebb_glow: "How much edge rendering brightness is modulated by learned weights (0=off, 1=full).",
    // Field + Coupling
    f_N: "Field grid resolution (N×N). Higher = sharper field but heavier GPU cost.",
    f_dt: "Field integrator timestep.",
    f_Ke: "Excitatory neighbor coupling strength.",
    f_Ki: "Inhibitory neighbor coupling strength (larger footprint).",
    f_a1: "Field phase lag (1st harmonic).",
    f_K2: "Field 2nd-harmonic coupling strength.",
    f_a2: "Field 2nd-harmonic phase lag.",
    f_delayOn: "Enable delayed neighborhood sampling in the field.",
    f_delaySteps: "Field delay length in steps.",
    f_omega: "Field natural frequency spread.",
    f_show: "Render the field as a background overlay (also long-press ⚙️).",
    f_alphaDraw: "Field overlay opacity.",
    gf_on: "Graph → Field coupling: nodes splat their phase into the influence buffer.",
    Kgf: "Strength of Graph → Field coupling term.",
    agf: "Phase lag for Graph → Field coupling term.",
    splatR: "Splat radius in pixels (bigger = broader influence).",
    splatGain: "How much each node contributes to the influence buffer per step.",
    inflDecay: "Influence buffer decay per step (closer to 1 = longer memory).",
    fg_on: "Field → Graph coupling: sample field phase at each node’s UV.",
    Kfg: "Strength of Field → Graph coupling term.",
    afg: "Phase lag for Field → Graph coupling term.",
    // Rendering
    edgeA: "Edge opacity (render alpha).",
    edgeFromField: "If ON, edge colors come from the field phase at each vertex UV (otherwise graph phase).",
    phaseOnly: "If ON, lock palette to phase hue (disables animated palette).",
    palOn: "Animate the palette over time (disabled when phase-only is ON).",
    palSpd: "Palette animation speed.",
    colorMode: "Visualization palette. Phase Rainbow: standard HSV. Diverging: blue-white-red by phase. Fire: black-red-yellow-white. Monochrome: grayscale intensity. E/I Type: excitatory (cyan) vs inhibitory (magenta). Weight: Hebbian weight as heat map. Ocean: cool blue-teal. Neon Plasma: magenta-cyan-white. Coherence: edge sync brightness. Frequency Band: natural freq as color. CEMI EM Field: electromagnetic field potential (blue=neg, white=zero, red=pos) with velocity glow. DA/GLU/GABA: live neurotransmitter concentrations (red=Dopamine, green=Glutamate, blue=GABA).",
    edgeFrac: "Render-only fraction of edges drawn (does not change coupling).",
    edgeAdaptive: "Automatically hides edges to save performance if the framerate drops too low."
  };

  function showTip(btn, text){
    if(!tipEl) return;
    tipEl.textContent = text;
    tipEl.__anchor = btn;
    const r = btn.getBoundingClientRect();
    const uiR = ui ? ui.getBoundingClientRect() : {top:0,right:window.innerWidth};
    const x = Math.min(uiR.right - 12, r.left + 10);
    const y = Math.max(uiR.top + 12, r.bottom + 8);
    tipEl.style.left = x + "px";
    tipEl.style.top  = y + "px";
    tipEl.classList.add("show");
  }
  function hideTip(){ if(tipEl){ tipEl.classList.remove("show"); tipEl.__anchor = null; } }

  function formatValue(ctrl){
    const t = (ctrl.type||"").toLowerCase();
    if(t==="checkbox") return ctrl.checked ? "ON" : "OFF";
    if(ctrl.tagName==="SELECT") return ctrl.value;
    const v = parseFloat(ctrl.value);
    if(!isFinite(v)) return String(ctrl.value);
    const step = parseFloat(ctrl.step || "0");
    if(step>=1) return String(Math.round(v));
    if(step>0) return v.toFixed(Math.min(4, Math.max(2, Math.ceil(-Math.log10(step)))));
    return v.toFixed(3);
  }

  function enhanceUI(){
    // Tooltip text for the little “i” buttons.
    // Keyed primarily by control id (fallbacks apply below).
    const tips = {
      steps: "How many simulation substeps to run per rendered frame. Higher = faster dynamics, more cost.",
      globalGain: "Master gain that scales overall coupling energy (quick ‘wake up’ / calm control).",

      shape: "Base polytope family: demihypercube (Dₙ), simplex (Aₙ), hypercube (Bₙ/Cₙ), or cross-polytope (orthoplex).",
      n: "Dimension parameter n. Larger n increases graph complexity and orbit size.",
      exactFull: "Exact build enumerates the full demihypercube (recommended only for small n).",
      shells: "Orbit shells for approximate demihypercube build (more shells = more vertices).",
      pairMode: "Edge selection mode (how pairs/links are chosen).",
      paircap: "Hard cap on number of edge pairs (0 = auto).",
      cands: "Candidate vertex budget for non-exact demihypercube orbit sampling.",
      mergeQ: "Target node count after merge/decimation. Lower = faster, higher = richer.",
      edgeStride: "Keep 1 out of every N edges (after building). Increase to thin dense graphs.",
      degK: "Maximum neighbors per node (degree cap).",

      g_dt: "Graph integrator time step. Larger is faster but can destabilize.",
      g_K1: "Primary graph coupling strength.",
      g_a1: "Primary graph nonlinearity/exponent.",
      g_K2: "Secondary coupling strength.",
      g_a2: "Secondary nonlinearity/exponent.",
      g_gauge: "Gauge/transport term strength (local phase-like adjustment).",
      g_inertialOn: "2nd-order (inertial) motion: adds ringing/oscillation and richer dynamics.",
      g_eta: "Damping (friction). Higher = less ringing.",
      g_vmax: "Velocity clamp to help stability.",

      topoOn: "Enable topology feedback (flux/defects) that can alter curvature/coupling.",
      fluxBoost: "How strongly flux increases coupling/attraction.",
      Kflux: "How strongly flux injects into the field dynamics.",
      fluxSwirl: "Flux-driven swirl (rotational influence).",

      defectOn: "Enable topological defects (punctures/disclinations) in the coupling.",
      defBoost: "How strongly defects increase coupling/attraction.",
      Kdef: "How strongly defects inject into the field.",
      defSwirl: "Defect-driven swirl contribution.",
      defInject: "Defect injection strength (localized impulses).",

      g_delayOn: "Enable delayed feedback (memory) in the graph.",
      g_delaySteps: "Delay length in steps.",
      g_delayMix: "Blend current vs delayed state.",
      g_Kg: "Global coupling gain (weak all-to-all component).",
      g_ag: "Global lag/phase parameter for global coupling.",
      g_noise: "Noise amplitude in graph updates.",
      g_omega: "Spread of intrinsic frequencies (heterogeneity).",

      gate_on: "Enable gating: boosts/suppresses coupling based on thresholds.",
      gate_lo: "Lower gating threshold.",
      gate_hi: "Upper gating threshold.",
      gate_boost: "Coupling boost when gating is active.",

      hebb_on: "Hebbian learning on edges (weights adapt based on activity correlation).",
      hebb_lr: "Hebbian learning rate η.",
      hebb_decay: "Weight decay λ (forgetting).",
      hebb_w0: "Baseline/resting weight.",
      hebb_wmin: "Minimum weight clamp.",
      hebb_wmax: "Maximum weight clamp.",
      hebb_stdp: "STDP asymmetry (0 = symmetric Hebb; >0 biases causal direction).",
      hebb_glow: "How much learned weight affects edge brightness.",
      hebbReset: "Reset all learned weights back to baseline.",
      stp_on: "Short‑term synaptic plasticity on edges (depression + facilitation).",
      stp_U: "Baseline utilization U.",
      stp_tauD: "Depression recovery τD.",
      stp_tauF: "Facilitation decay τF.",
      stp_actGain: "Activity gain for STP updates.",
      stp_max: "Clamp for the STP multiplier.",
      stpReset: "Reset STP state.",
    stp_on: "Short‑term synaptic plasticity on edges: per‑edge depression (resource depletion) + facilitation (utilization boost).",
    stp_U: "Baseline utilization U (how strongly an edge uses its available resources when active).",
    stp_tauD: "Depression recovery time constant τD (resources replenish back to 1).",
    stp_tauF: "Facilitation time constant τF (utilization relaxes back toward U).",
    stp_actGain: "Scales how strongly recent phase‑locking counts as \"activity\" for STP updates.",
    stp_max: "Clamp for the transient STP multiplier applied to coupling.",
    stpReset: "Reset per‑edge STP state (u,x) back to baseline.",

      f_dt: "Field integrator time step.",
      f_N: "Field resolution (N×N). Higher = sharper structures but more GPU cost.",
      f_Ke: "Excitatory coupling strength.",
      f_Ki: "Inhibitory coupling strength.",
      f_a1: "Primary field nonlinearity/exponent.",
      f_K2: "Secondary field coupling strength.",
      f_a2: "Secondary field nonlinearity/exponent.",
      f_delayOn: "Enable delayed feedback in the field.",
      f_delaySteps: "Delay length for the field’s memory.",
      f_omega: "Intrinsic frequency spread in the field.",

      f_show: "Render the field as a background texture.",
      f_alphaDraw: "Field opacity in the renderer.",
      phiWarp: "How strongly the field warps the global curvature/metric used by coupling.",
      phiDiff: "Curvature diffusion (smooths curvature changes).",
      phiRelax: "Curvature relaxation back toward baseline.",
      phiInject: "How strongly defects inject curvature changes.",
      edgeFrac: "Render-only fraction of edges drawn (does not change coupling).",
      edgeAdaptive: "Automatically hides edges to save performance if the framerate drops too low.",
      nm_base: "Tonic resting concentration for all chemicals. DA rests at 40% of this, GLU at 100%, GABA at 60%. With no neural activity, chemicals relax toward these levels.",
      nm_tau: "How quickly chemicals clear back toward resting baseline. Lower = faster response to activity changes.",
      nm_D: "Spatial diffusion rate for chemicals. Higher = chemicals spread further from release sites.",
      nm_drive: "Overall scaling of activity-driven chemical release. Self-limiting: release slows as concentration rises.",
      nm_gainK: "How strongly Glutamate (excitatory) and GABA (inhibitory) modulate graph coupling strength.",
      nm_gainLR: "How strongly Dopamine (phasic surprise signal) modulates Hebbian learning rate.",
      glia_drive: "How quickly glia activates in response to excess glutamate. Self-limiting growth prevents permanent saturation.",
      glia_diff: "How far glial activation spreads spatially. Astrocyte networks are local so this should be small.",
    };

    const rows = [...ui.querySelectorAll(".row")];

    for(const row of rows){
      // Skip if already enhanced
      if(row.classList.contains("enhanced")) continue;

      const label = row.querySelector("label");
      const ctrl  = row.querySelector("input, select, textarea");
      if(!label || !ctrl) continue;

      row.classList.add("enhanced");

      // Wrap existing children into left/right so layout stays compact even after inserting info/value.
      const left  = document.createElement("div"); left.className = "left";
      const right = document.createElement("div"); right.className = "right";

      // Move label into left
      left.appendChild(label);

      // Move ctrl (and any sibling text nodes) into right
      right.appendChild(ctrl);

      // If this row had additional controls (rare), move them too
      for(const extra of [...row.querySelectorAll("input, select, textarea, button")]){
        if(extra !== ctrl && !right.contains(extra)) right.appendChild(extra);
      }

      // Clear row and re-append
      row.textContent = "";
      row.appendChild(left);
      row.appendChild(right);

      // Info button + value box
      const info = document.createElement("div");
      info.className = "infoBtn";
      info.textContent = "i";
      info.title = "What is this?";

      const val = document.createElement("div");
      val.className = "valBox";
      val.textContent = formatValue(ctrl);

      // Prefer data-tip on label/control, else lookup by id/name, else use title.
      const key = (ctrl.id || ctrl.name || "").trim();
      const tipText = label.dataset.tip || ctrl.dataset.tip || (key && tips[key]) || ctrl.title || label.title || "";
      if(tipText){
        info.addEventListener("pointerenter", ()=>showTip(info, tipText));
        info.addEventListener("pointerleave", hideTip);
        // Tap/click toggles tooltip (good on touch too)
        info.addEventListener("pointerdown", (e)=>{
          e.stopPropagation();
          if(tipEl && tipEl.classList.contains('show') && tipEl.__anchor === info) hideTip();
          else showTip(info, tipText);
        });
      }else{
        info.style.opacity = .55;
      }

      // Value syncing
      const sync = ()=>{ val.textContent = formatValue(ctrl); };
      ctrl.addEventListener("input", sync, { passive:true });
      ctrl.addEventListener("change", sync, { passive:true });

      // Insert into left side (compact)
      left.appendChild(info);
      left.appendChild(val);
    }

    // Clicking anywhere else hides tip
    ui.addEventListener("pointerdown", (e)=>{
      if(!e.target.classList.contains("infoBtn")) hideTip();
    });
  }

  function setStatus(msg){ statusEl.textContent = msg; }
  function setProgress(frac, text){
    progEl.value = Math.max(0, Math.min(1, frac));
    progTextEl.textContent = text || "";
  }

  function updateShapeUI(){
    const isSimplex = (shapeEl.value === "simplex");
    exactFullEl.disabled = isSimplex;
    shellsEl.disabled = isSimplex;
    candsEl.disabled = isSimplex;
    mergeQEl.disabled = isSimplex;
    if(isSimplex){
      exactFullEl.checked = false;
    }
  }

// ==== Presets ====
// Presets set *simulation / plasticity / field* parameters only.
// They DO NOT change the built geometry (shape, dimension, sampling/merge, wiring caps).
// This means you can keep the same scaffold/graph and quickly explore different dynamical regimes.
const PRESETS = {
  fast: {
    // Small, stable, easy FPS (gentle coupling, conservative learning)
    steps: 12,
    globalGain: 0.95,
    g_dt: 0.010,
    g_noise: 0.010,
    g_K1: 1.2,
    g_a1: 0.32,
    g_K2: 0.0,
    g_a2: 0.0,

    hebb_on: true,
    hebb_lr: 0.020,
    hebb_decay: 0.0022,
    hebb_wmax: 1.2,

    stp_on: false,
    nm_on: false,

    gf_on: true,  Kgf: 1.2,  agf: 0.30,
    fg_on: true,  Kfg: 0.8,  afg: 0.18,

    f_dt: 0.70,
    phiDiff: 0.40,
    phiRelax: 0.26
  },

  slow: {
    // Same vibe as "fast" but slowed down so dynamics are readable
    steps: 16,
    globalGain: 1.00,
    g_dt: 0.006,
    g_noise: 0.008,
    g_K1: 1.5,
    g_a1: 0.34,
    g_K2: 0.10,
    g_a2: 0.03,

    hebb_on: true,
    hebb_lr: 0.028,
    hebb_decay: 0.0018,
    hebb_wmax: 1.4,

    stp_on: false,
    nm_on: false,

    gf_on: true,  Kgf: 1.4,  agf: 0.32,
    fg_on: true,  Kfg: 1.0,  afg: 0.20,

    f_dt: 0.60,
    phiDiff: 0.45,
    phiRelax: 0.22
  },

  quiet: {
    // Low activity / sparse interactions (good for seeing structure without saturating)
    steps: 14,
    globalGain: 0.80,
    g_dt: 0.007,
    g_noise: 0.004,
    g_K1: 0.65,
    g_a1: 0.55,
    g_K2: 0.0,
    g_a2: 0.0,

    hebb_on: true,
    hebb_lr: 0.012,
    hebb_decay: 0.0030,
    hebb_wmax: 1.1,

    stp_on: false,
    nm_on: false,

    gf_on: true,  Kgf: 0.8,  agf: 0.22,
    fg_on: true,  Kfg: 0.5,  afg: 0.12,

    f_dt: 0.55,
    phiDiff: 0.30,
    phiRelax: 0.35
  },

  critical: {
    // Near-critical / avalanche-y: moderate coupling + higher noise + STP to prevent lock-in
    steps: 20,
    globalGain: 1.10,
    g_dt: 0.008,
    g_noise: 0.020,
    g_K1: 2.0,
    g_a1: 0.62,
    g_K2: 0.35,
    g_a2: 0.14,

    hebb_on: true,
    hebb_lr: 0.055,
    hebb_decay: 0.0011,
    hebb_wmax: 1.8,

    stp_on: true,
    stp_U: 0.18,
    stp_tauD: 1.05,
    stp_tauF: 0.75,
    stp_actGain: 1.15,
    stp_max: 2.4,

    nm_on: true,
    nm_base: 0.18,
    nm_tau: 7.0,
    nm_D: 0.55,
    nm_drive: 0.55,
    nm_gainK: 0.30,
    nm_gainLR: 0.40,

    gf_on: true,  Kgf: 2.5,  agf: 0.45,
    fg_on: true,  Kfg: 2.0,  afg: 0.24,

    f_dt: 0.85,
    phiDiff: 0.62,
    phiRelax: 0.18
  },

  culture: {
    // Culture-dish feel: bursts, memory, modulatory bath (works best on medium/high density graphs)
    steps: 22,
    globalGain: 1.20,
    g_dt: 0.008,
    g_noise: 0.014,
    g_K1: 2.6,
    g_a1: 0.40,
    g_K2: 0.65,
    g_a2: 0.10,

    hebb_on: true,
    hebb_lr: 0.080,
    hebb_decay: 0.0009,
    hebb_wmax: 2.2,

    stp_on: true,
    stp_U: 0.24,
    stp_tauD: 0.90,
    stp_tauF: 0.70,
    stp_actGain: 1.35,
    stp_max: 2.8,

    nm_on: true,
    nm_base: 0.26,
    nm_tau: 5.8,
    nm_D: 0.70,
    nm_drive: 0.85,
    nm_gainK: 0.60,
    nm_gainLR: 0.90,

    gf_on: true,  Kgf: 3.0,  agf: 0.52,
    fg_on: true,  Kfg: 2.5,  afg: 0.30,

    f_dt: 0.95,
    phiDiff: 0.55,
    phiRelax: 0.16
  },

  waves: {
    // Traveling waves: stronger graph↔field feedback + smoother field transport
    steps: 20,
    globalGain: 1.05,
    g_dt: 0.008,
    g_noise: 0.010,
    g_K1: 1.8,
    g_a1: 0.70,
    g_K2: 0.35,
    g_a2: 0.16,

    hebb_on: true,
    hebb_lr: 0.045,
    hebb_decay: 0.0013,
    hebb_wmax: 1.7,

    stp_on: true,
    stp_U: 0.20,
    stp_tauD: 0.75,
    stp_tauF: 0.55,
    stp_actGain: 1.00,
    stp_max: 2.0,

    gf_on: true,  Kgf: 4.5,  agf: 0.32,
    fg_on: true,  Kfg: 4.0,  afg: 0.16,

    f_dt: 1.05,
    phiDiff: 0.85,
    phiRelax: 0.12,

    nm_on: true,
    nm_base: 0.20,
    nm_tau: 6.5,
    nm_D: 0.85,
    nm_drive: 0.45,
    nm_gainK: 0.30,
    nm_gainLR: 0.45
  },

  neuromod: {
    // Bath-driven regime: neuromod field strongly gates coupling + learning (slow-ish but expressive)
    steps: 24,
    globalGain: 1.15,
    g_dt: 0.007,
    g_noise: 0.012,
    g_K1: 2.0,
    g_a1: 0.48,
    g_K2: 0.55,
    g_a2: 0.12,

    hebb_on: true,
    hebb_lr: 0.070,
    hebb_decay: 0.0010,
    hebb_wmax: 2.0,

    stp_on: true,
    stp_U: 0.20,
    stp_tauD: 1.10,
    stp_tauF: 0.90,
    stp_actGain: 1.25,
    stp_max: 2.6,

    nm_on: true,
    nm_base: 0.12,
    nm_tau: 10.0,
    nm_D: 1.10,
    nm_drive: 1.05,
    nm_gainK: 1.05,
    nm_gainLR: 1.15,

    gf_on: true,  Kgf: 2.2,  agf: 0.42,
    fg_on: true,  Kfg: 1.8,  afg: 0.22,

    f_dt: 0.90,
    phiDiff: 0.70,
    phiRelax: 0.14
  },

  sync: {
    // Coherent locking: strong coupling, low noise, weaker field feedback
    steps: 18,
    globalGain: 1.10,
    g_dt: 0.007,
    g_noise: 0.003,
    g_K1: 3.4,
    g_a1: 0.10,
    g_K2: 1.10,
    g_a2: 0.04,

    hebb_on: true,
    hebb_lr: 0.045,
    hebb_decay: 0.0020,
    hebb_wmax: 1.6,

    stp_on: false,
    nm_on: false,

    gf_on: true,  Kgf: 1.0,  agf: 0.10,
    fg_on: true,  Kfg: 0.7,  afg: 0.05,

    f_dt: 0.55,
    phiDiff: 0.28,
    phiRelax: 0.32
  },

  seizure: {
    // Overdrive synchrony: pushes into very strong lock / large coherent swings (use Kick to break symmetry)
    steps: 26,
    globalGain: 1.35,
    g_dt: 0.009,
    g_noise: 0.006,
    g_K1: 4.6,
    g_a1: 0.05,
    g_K2: 1.80,
    g_a2: 0.02,

    hebb_on: true,
    hebb_lr: 0.030,
    hebb_decay: 0.0032,
    hebb_wmax: 1.4,

    stp_on: false,
    nm_on: false,

    gf_on: true,  Kgf: 0.5,  agf: 0.06,
    fg_on: true,  Kfg: 0.4,  afg: 0.04,

    f_dt: 0.45,
    phiDiff: 0.18,
    phiRelax: 0.42
  },

  chaos: {
    // STP stress test: strong facilitation/depression -> rich, unstable edge dynamics
    steps: 28,
    globalGain: 1.25,
    g_dt: 0.009,
    g_noise: 0.028,
    g_K1: 2.4,
    g_a1: 0.80,
    g_K2: 0.80,
    g_a2: 0.22,

    hebb_on: true,
    hebb_lr: 0.095,
    hebb_decay: 0.0008,
    hebb_wmax: 2.6,

    stp_on: true,
    stp_U: 0.10,
    stp_tauD: 1.35,
    stp_tauF: 1.05,
    stp_actGain: 1.65,
    stp_max: 3.2,

    nm_on: true,
    nm_base: 0.16,
    nm_tau: 8.5,
    nm_D: 0.55,
    nm_drive: 1.05,
    nm_gainK: 0.75,
    nm_gainLR: 1.05,

    gf_on: true,  Kgf: 3.5,  agf: 0.55,
    fg_on: true,  Kfg: 2.8,  afg: 0.34,

    f_dt: 0.95,
    phiDiff: 0.62,
    phiRelax: 0.16
  }
};


  function setCtrl(id, v){
    const el = document.getElementById(id);
    if(!el) return;
    if(el.type === 'checkbox'){
      el.checked = !!v;
    }else{
      el.value = v;
    }
    el.dispatchEvent(new Event('input', { bubbles:true }));
    el.dispatchEvent(new Event('change', { bubbles:true }));
  }

  function applyPreset(key){
    const P = PRESETS[key];
    if(!P) return;

    // Always keep delays off unless user explicitly enables them later
    if(document.getElementById('g_delayOn')) setCtrl('g_delayOn', false);
    if(document.getElementById('f_delayOn')) setCtrl('f_delayOn', false);

    // Presets intentionally do NOT change integration step time (dt) or any substep/iteration counts.
    const _presetSkip = new Set(['g_dt','f_dt','dt','stepTime','steps','substeps','stepsPerFrame','itersPerFrame']);

    // Apply values
    for(const [k,v] of Object.entries(P)) {
      if(_presetSkip.has(k) || /(?:^|_)dt$/.test(k)) continue;
      setCtrl(k, v);
    }

  }

  presetApply?.addEventListener('click', ()=>{
    const key = presetSel?.value || 'custom';
    if(key && key !== 'custom') applyPreset(key);
  });
  presetSel?.addEventListener('change', ()=>{
    // If user picks a preset, enable quick apply via Enter
    // (no auto-apply because it can be heavy)
  });

  shapeEl.addEventListener('change', updateShapeUI);
  updateShapeUI();

  // Resize
  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = Math.floor(canvas.clientWidth * dpr);
    const h = Math.floor(canvas.clientHeight * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w; canvas.height = h;
      gl.viewport(0,0,w,h);
    }
  }
  window.addEventListener('resize', resize, { passive:true });
  resize();

  // Pan/zoom view
  let centerX=0, centerY=0, scale=1, fitScale=1;
  function resetView(){ centerX=0; centerY=0; scale=fitScale; }
  resetBtn.addEventListener('click', resetView);

  const pointers=new Map();
  let lastPan=null, pinchStart=null;
  let clickX=0, clickY=0, clickTime=0;
  canvas.addEventListener('pointerdown',(e)=>{
    canvas.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
    if(pointers.size===1){
      lastPan={x:e.clientX,y:e.clientY,cx:centerX,cy:centerY};
      clickX=e.clientX; clickY=e.clientY; clickTime=performance.now();
    } else if(pointers.size===2){
      lastPan=null;
      const pts=[...pointers.values()];
      const dx=pts[0].x-pts[1].x, dy=pts[0].y-pts[1].y;
      pinchStart={ d:Math.hypot(dx,dy), scale, centerX, centerY, midX:(pts[0].x+pts[1].x)/2, midY:(pts[0].y+pts[1].y)/2 };
    }
  });
  canvas.addEventListener('pointermove',(e)=>{
    if(!pointers.has(e.pointerId)) return;
    pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
    if(pointers.size===1 && lastPan){
      const w=canvas.width,h=canvas.height,aspect=w/h;
      const dxN=2*(e.clientX-lastPan.x)/w;
      const dyN=2*(e.clientY-lastPan.y)/h;
      centerX = lastPan.cx - (dxN*aspect)/scale;
      centerY = lastPan.cy + (dyN)/scale;
    } else if(pointers.size===2 && pinchStart){
      const pts=[...pointers.values()];
      const dx=pts[0].x-pts[1].x, dy=pts[0].y-pts[1].y;
      const d=Math.hypot(dx,dy);
      if(d>0){
        const factor=d/pinchStart.d;
        const rect=canvas.getBoundingClientRect();
        const mx=(pinchStart.midX-rect.left)*(canvas.width/rect.width);
        const my=(pinchStart.midY-rect.top)*(canvas.height/rect.height);
        const w=canvas.width,h=canvas.height,aspect=w/h;
        const ndcX=(2*mx/w-1), ndcY=(1-2*my/h);
        const wx=pinchStart.centerX + (ndcX*aspect)/pinchStart.scale;
        const wy=pinchStart.centerY + ndcY/pinchStart.scale;
        scale=pinchStart.scale*factor;
        centerX=wx - (ndcX*aspect)/scale;
        centerY=wy - ndcY/scale;
      }
    }
  });
  function endPtr(e){ 
    if(pointers.size===1 && lastPan){
      const dx = e.clientX - clickX;
      const dy = e.clientY - clickY;
      // If the pointer barely moved and was quick, treat it as a tap/click
      if(Math.hypot(dx,dy) < 6 && (performance.now() - clickTime) < 400){
         const rect=canvas.getBoundingClientRect();
         const px=(e.clientX-rect.left)*(canvas.width/rect.width);
         const py=(e.clientY-rect.top)*(canvas.height/rect.height);
         const w=canvas.width, h=canvas.height, aspect=w/h;
         const ndcX=(2*px/w-1), ndcY=(1-2*py/h);
         const wx=centerX + (ndcX*aspect)/scale;
         const wy=centerY + ndcY/scale;

         const uvX = wx * uvScaleGlobal + 0.5;
         const uvY = wy * uvScaleGlobal + 0.5;

         // Only place inspector if they clicked inside the active coordinate space
         if(uvX>=0 && uvX<=1 && uvY>=0 && uvY<=1){
           window.inspectorActive = true;
           window.inspectorUV = {x:uvX, y:uvY};
           document.getElementById('inspector').classList.remove('hidden');
           if(typeof updateInspectorImmediate === 'function') updateInspectorImmediate();
         } else {
           window.inspectorActive = false;
           document.getElementById('inspector').classList.add('hidden');
         }
      }
    }
    pointers.delete(e.pointerId); lastPan=null; pinchStart=null; 
  }
  canvas.addEventListener('pointerup', endPtr);
  canvas.addEventListener('pointercancel', endPtr);
  canvas.addEventListener('wheel',(e)=>{
    e.preventDefault();
    const rect=canvas.getBoundingClientRect();
    const px=(e.clientX-rect.left)*(canvas.width/rect.width);
    const py=(e.clientY-rect.top)*(canvas.height/rect.height);
    const factor=Math.exp(-e.deltaY*0.0015);
    const w=canvas.width,h=canvas.height,aspect=w/h;
    const ndcX=(2*px/w-1), ndcY=(1-2*py/h);
    const wx=centerX + (ndcX*aspect)/scale;
    const wy=centerY + ndcY/scale;
    const newScale=scale*factor;
    centerX=wx - (ndcX*aspect)/newScale;
    centerY=wy - ndcY/newScale;
    scale=newScale;
  },{passive:false});

  // GL helpers
  function compile(type,src){
    const sh=gl.createShader(type);
    gl.shaderSource(sh,src);
    gl.compileShader(sh);
    if(!gl.getShaderParameter(sh,gl.COMPILE_STATUS)){
      throw new Error((gl.getShaderInfoLog(sh)||"").trim()||"compile failed");
    }
    return sh;
  }
  function link(vs,fs){
    const p=gl.createProgram();
    gl.attachShader(p,vs); gl.attachShader(p,fs);
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p,gl.LINK_STATUS)){
      throw new Error((gl.getProgramInfoLog(p)||"").trim()||"link failed");
    }
    return p;
  }

  function makeTexRGBA8(w,h,data=null){
    const t=gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D,t);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT,1);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,w,h,0,gl.RGBA,gl.UNSIGNED_BYTE,data);
    gl.bindTexture(gl.TEXTURE_2D,null);
    return t;
  }
  function makeTexRGBA8UI(w,h,data=null){
    const t=gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D,t);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT,1);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA8UI,w,h,0,gl.RGBA_INTEGER,gl.UNSIGNED_BYTE,data);
    gl.bindTexture(gl.TEXTURE_2D,null);
    return t;
  }
  function makeTexRGBA16F(w,h){
    const t=gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D,t);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA16F,w,h,0,gl.RGBA,gl.HALF_FLOAT,null);
    gl.bindTexture(gl.TEXTURE_2D,null);
    return t;
  }

  function makeTexR16F(w,h){
    const t=gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D,t);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.R16F,w,h,0,gl.RED,gl.HALF_FLOAT,null);
    gl.bindTexture(gl.TEXTURE_2D,null);
    return t;
  }

  const TAU = Math.PI*2;
  const DELAY_MAX = 24;
  const THETA_RING = DELAY_MAX + 1;
  const fbo = gl.createFramebuffer();
  gl.disable(gl.DEPTH_TEST);

  function packTheta01ToRGBA(theta01, out, o, vel01=0.5){
    // Pack theta (0..1) into RG (u16), and velocity (mapped 0..1) into BA (u16).
    let v = Math.max(0, Math.min(1, theta01));
    let vv = Math.max(0, Math.min(1, vel01));
    const u16 = (v * 65535 + 0.5) | 0;
    const v16 = (vv * 65535 + 0.5) | 0;
    out[o+0] = u16 & 255;
    out[o+1] = (u16 >>> 8) & 255;
    out[o+2] = v16 & 255;
    out[o+3] = (v16 >>> 8) & 255;
  }
  function packUV16(u,v,out,o){
    u=Math.max(0,Math.min(1,u)); v=Math.max(0,Math.min(1,v));
    const uu=(u*65535+0.5)|0, vv=(v*65535+0.5)|0;
    out[o+0]=uu&255; out[o+1]=(uu>>>8)&255;
    out[o+2]=vv&255; out[o+3]=(vv>>>8)&255;
  }

  function initThetaRing(w,h, seed=12345){
    const ring=[];
    for(let i=0;i<THETA_RING;i++) ring.push(makeTexRGBA8(w,h,null));
    let s=seed>>>0;
    const rnd=()=>{ s^=(s<<13)>>>0; s^=(s>>>17)>>>0; s^=(s<<5)>>>0; return (s>>>0)/4294967295; };
    const bytes=new Uint8Array(w*h*4);
    for(let i=0;i<w*h;i++) packTheta01ToRGBA(rnd(), bytes, i*4, 0.5);
    for(let i=0;i<THETA_RING;i++){
      gl.bindTexture(gl.TEXTURE_2D, ring[i]);
      gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,w,h,gl.RGBA,gl.UNSIGNED_BYTE,bytes);
    }
    gl.bindTexture(gl.TEXTURE_2D,null);
    return ring;
  }
  function initOmegaTex(w,h, seed=777){
    let s=seed>>>0;
    const rnd=()=>{ s^=(s<<13)>>>0; s^=(s>>>17)>>>0; s^=(s<<5)>>>0; return (s>>>0)/4294967295; };
    const bytes=new Uint8Array(w*h*4);
    const inhibEl = document.getElementById('g_inhib');
    const inhibFrac = inhibEl ? parseFloat(inhibEl.value) : 0.20;
    for(let i=0;i<w*h;i++){
      const b = (rnd()*255+0.5)|0;
      // G channel stores Node Type: 255 = Excitatory, 0 = Inhibitory
      const typeG = rnd() < inhibFrac ? 0 : 255;
      bytes[i*4+0]=b; bytes[i*4+1]=typeG; bytes[i*4+2]=0; bytes[i*4+3]=255;
    }
    return makeTexRGBA8(w,h,bytes);
  }

  let g_texW=0, g_texH=0, nodeCount=0, degK=16;
  let g_weightTexA=null, g_weightTexB=null, g_weightFlip=0;
  let g_nodeWeightTex=null;

  let g_homeoTexA=null, g_homeoTexB=null, g_homeoFlip=0;
  function currentHomeoTex(){ return g_homeoFlip===0 ? g_homeoTexA : g_homeoTexB; }
  function otherHomeoTex(){ return g_homeoFlip===0 ? g_homeoTexB : g_homeoTexA; }
  // ===== Short-term plasticity (STP) per-edge state =====
  let g_stpTexA=null, g_stpTexB=null, g_stpFlip=0;
  let g_axonDistTex=null;

  let storedNeiW=0, storedNeiH=0;
  let g_thetaRing=[], g_thetaIdx=0, g_omegaTex=null;
  let g_uvTexA=null, g_uvTexB=null, g_uvFlip=0;
  function currentUvTex(){ return g_uvFlip===0 ? g_uvTexA : g_uvTexB; }
  function otherUvTex(){ return g_uvFlip===0 ? g_uvTexB : g_uvTexA; }
  let g_neiTexA=null, g_neiTexB=null, g_neiFlip=0;
  function currentNeiTex(){ return g_neiFlip===0 ? g_neiTexA : g_neiTexB; }
  function otherNeiTex(){ return g_neiFlip===0 ? g_neiTexB : g_neiTexA; }
  let f_N=256, f_thetaRing=[], f_thetaIdx=0, f_omegaTex=null;
  let defTex=null;
  let meanTex=null;
  let inflA=null, inflB=null, inflFlip=0, inflUseFloat=false;
  let phiA=null, phiB=null, phiFlip=0;
  let nmA=null, nmB=null, nmFlip=0;
  // Metabolic field: R=ATP (0..1), G=Glial buffer (0..1)
  let metaA=null, metaB=null, metaFlip=0;
  function currentMetaTex(){ return metaFlip===0 ? metaA : metaB; }
  function otherMetaTex(){ return metaFlip===0 ? metaB : metaA; }

  let uvScaleGlobal=0.5;
  let maxR=1.0;

  let nodeVBO = gl.createBuffer();
  let edgeIBO = gl.createBuffer();
  let edgeIndexCount = 0;

  let splatVAO = gl.createVertexArray();
  let splatVBO = gl.createBuffer();

  let gGlobR=0.0, gGlobPsi=0.0;
  let simTick=0.0;

  function currTheta(ring, idx){ return ring[idx]; }
  function nextTheta(ring, idx){ return ring[(idx+1)%THETA_RING]; }
  function delayedTheta(ring, idx, delaySteps){
    const d = Math.max(0, Math.min(DELAY_MAX, delaySteps|0));
    const j = (idx - d + THETA_RING) % THETA_RING;
    return ring[j];
  }

  function initGraphTextures(N){
    g_texW = 1;
    while(g_texW*g_texW < N) g_texW <<= 1;
    g_texH = Math.ceil(N / g_texW);
    if(g_texH > g_texW){ g_texW <<= 1; g_texH = Math.ceil(N / g_texW); }
    g_thetaRing = initThetaRing(g_texW, g_texH, 123456);
    g_thetaIdx = 0;
    g_omegaTex = initOmegaTex(g_texW, g_texH, 4242);
    if(g_uvTexA) gl.deleteTexture(g_uvTexA);
    if(g_uvTexB) gl.deleteTexture(g_uvTexB);
    g_uvTexA = makeTexRGBA8(g_texW, g_texH, null);
    g_uvTexB = makeTexRGBA8(g_texW, g_texH, null);
    g_uvFlip = 0;

    if(g_homeoTexA) gl.deleteTexture(g_homeoTexA);
    if(g_homeoTexB) gl.deleteTexture(g_homeoTexB);
    const homeoBytes = new Uint8Array(g_texW * g_texH * 4);
    for(let i=0; i<g_texW * g_texH; i++) {
        homeoBytes[i*4+0] = 16383 & 255;       // H = 1.0 (excitability mapped to 0..4)
        homeoBytes[i*4+1] = (16383 >>> 8) & 255;
        homeoBytes[i*4+2] = 0;                 // A = 0.0 (recent activity)
        homeoBytes[i*4+3] = 0;
    }
    g_homeoTexA = makeTexRGBA8(g_texW, g_texH, homeoBytes);
    g_homeoTexB = makeTexRGBA8(g_texW, g_texH, homeoBytes);
    g_homeoFlip = 0;
  }

  function initFieldTextures(){
    f_N = parseInt(f_NEl.value,10) || 256;
    f_thetaRing = initThetaRing(f_N, f_N, 8888);
    f_thetaIdx = 0;
    f_omegaTex = initOmegaTex(f_N, f_N, 999);
    phiMeanLod = Math.log2(f_N);

    if(defTex) gl.deleteTexture(defTex);
    defTex = makeTexRGBA8(f_N, f_N, null);

    // Conformal metric proxy (curvature) field phi: stored in R channel, phiSigned = r*2-1.
    if(phiA) gl.deleteTexture(phiA);
    if(phiB) gl.deleteTexture(phiB);
    phiA = makeTexRGBA8(f_N, f_N, null);
    phiB = makeTexRGBA8(f_N, f_N, null);
    phiFlip = 0;

    // Neuromodulator bath field (separate)
    if(nmA) gl.deleteTexture(nmA);
    if(nmB) gl.deleteTexture(nmB);
    nmA = makeTexRGBA8(f_N, f_N, null);
    nmB = makeTexRGBA8(f_N, f_N, null);
    nmFlip = 0;

    // Metabolic field (ATP + Glia buffer)
    if(metaA) gl.deleteTexture(metaA);
    if(metaB) gl.deleteTexture(metaB);
    metaA = makeTexRGBA8(f_N, f_N, null);
    metaB = makeTexRGBA8(f_N, f_N, null);
    metaFlip = 0;

    if(meanTex) gl.deleteTexture(meanTex);
    meanTex = makeTexRGBA8(1, 1, null);

    const wantFloat = true;
    const hasFloat = !!gl.getExtension('EXT_color_buffer_float');
    const hasFloatBlend = !!gl.getExtension('EXT_float_blend');
    inflUseFloat = wantFloat && hasFloat && hasFloatBlend;

    const makeInfl = inflUseFloat ? makeTexRGBA16F : makeTexRGBA8;
    if(inflA) gl.deleteTexture(inflA);
    if(inflB) gl.deleteTexture(inflB);
    inflA = makeInfl(f_N, f_N);
    inflB = makeInfl(f_N, f_N);
    inflFlip = 0;
    clearInfluence();
    clearDefects();
    clearPhi();
    clearNeuromod();
    clearMeta();
  }

  function currentInflTex(){ return inflFlip===0 ? inflA : inflB; }
  function otherInflTex(){ return inflFlip===0 ? inflB : inflA; }
  function currentNeuromodTex(){ return nmFlip===0 ? nmA : nmB; }
  function otherNeuromodTex(){ return nmFlip===0 ? nmB : nmA; }
  function currentPhiTex(){ return phiFlip===0 ? phiA : phiB; }
  function otherPhiTex(){ return phiFlip===0 ? phiB : phiA; }

  function clearInfluence(){
    const clearOne = (tex)=>{
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
      gl.viewport(0,0,f_N,f_N);
      gl.disable(gl.BLEND);
      gl.clearColor(0,0,0,0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.viewport(0,0,canvas.width,canvas.height);
    };
    if(inflA) clearOne(inflA);
    if(inflB) clearOne(inflB);
  }

  function clearDefects(){
    if(!defTex) return;
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, defTex, 0);
    gl.viewport(0,0,f_N,f_N);
    gl.disable(gl.BLEND);
    // 0.5 => q=0 (no defect)
    gl.clearColor(0.5,0.0,0.0,1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0,0,canvas.width,canvas.height);
  }

  function clearPhi(){
    const clearOne = (tex)=>{
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
      gl.viewport(0,0,f_N,f_N);
      gl.disable(gl.BLEND);
      // 0.5, 0.5 => phi=0, vel=0
      gl.clearColor(0.5,0.5,0.0,1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.viewport(0,0,canvas.width,canvas.height);
    };
    if(phiA) clearOne(phiA);
    if(phiB) clearOne(phiB);
  }

  function clearNeuromod(){
    const base = nm_baseEl ? parseFloat(nm_baseEl.value) : 0.18;
    const daBase = Math.round(base * 0.4 * 255) / 255;
    const gluBase = Math.round(base * 255) / 255;
    const gabaBase = Math.round(base * 0.6 * 255) / 255;
    const actSlowInit = 0.15; // resting activity trace so DA doesn't false-trigger on init
    const clearOne = (tex)=>{
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
      gl.viewport(0,0,f_N,f_N);
      gl.disable(gl.BLEND);
      gl.clearColor(daBase, gluBase, gabaBase, actSlowInit);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.viewport(0,0,canvas.width,canvas.height);
    };
    if(nmA) clearOne(nmA);
    if(nmB) clearOne(nmB);
  }

function clearMeta(){
    const clearOne = (tex)=>{
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
      gl.viewport(0,0,f_N,f_N);
      gl.disable(gl.BLEND);
      // ATP=1, Glia=0
      gl.clearColor(1.0,0.0,0.0,1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.viewport(0,0,canvas.width,canvas.height);
    };
    if(metaA) clearOne(metaA);
    if(metaB) clearOne(metaB);
  }

    // ===== Hebbian Weight Textures =====
  function initWeightTextures(neiW, neiH){
    storedNeiW = neiW;
    storedNeiH = neiH;
    if(g_weightTexA) gl.deleteTexture(g_weightTexA);
    if(g_weightTexB) gl.deleteTexture(g_weightTexB);
    if(g_nodeWeightTex) gl.deleteTexture(g_nodeWeightTex);

    // Initialize all weights to rest weight (default 1.0 → encoded as 0.5 in 0-2 range)
    const w0 = parseFloat(hebb_w0El.value) || 1.0;
    const enc = Math.max(0, Math.min(1, w0 / 2.0));
    const u16 = (enc * 65535 + 0.5) | 0;
    const lo = u16 & 255, hi = (u16 >>> 8) & 255;
    const bytes = new Uint8Array(neiW * neiH * 4);
    for(let i = 0; i < neiW * neiH; i++){
      bytes[i*4+0] = lo;
      bytes[i*4+1] = hi;
      bytes[i*4+2] = 0;
      bytes[i*4+3] = 255;
    }
    g_weightTexA = makeTexRGBA8(neiW, neiH, bytes);
    g_weightTexB = makeTexRGBA8(neiW, neiH, bytes);
    g_weightFlip = 0;

    // Per-node average weight texture (small, g_texW x g_texH)
    const nodeBytes = new Uint8Array(g_texW * g_texH * 4);
    for(let i = 0; i < g_texW * g_texH; i++){
      nodeBytes[i*4+0] = lo;
      nodeBytes[i*4+1] = hi;
      nodeBytes[i*4+2] = 0;
      nodeBytes[i*4+3] = 255;
    }
    g_nodeWeightTex = makeTexRGBA8(g_texW, g_texH, nodeBytes);
    // Initialize STP state textures (u,x)
    initSTPTextures(neiW, neiH);
  }

  function resetWeights(){
    if(storedNeiW > 0 && storedNeiH > 0){
      initWeightTextures(storedNeiW, storedNeiH);
    }
  }

  function currentWeightTex(){ return g_weightFlip === 0 ? g_weightTexA : g_weightTexB; }
  function otherWeightTex(){ return g_weightFlip === 0 ? g_weightTexB : g_weightTexA; }


  function initSTPTextures(neiW, neiH){
    if(g_stpTexA) gl.deleteTexture(g_stpTexA);
    if(g_stpTexB) gl.deleteTexture(g_stpTexB);

    const U = Math.max(0.0001, Math.min(0.999, parseFloat(stp_UEl.value) || 0.25));
    const uEnc = Math.max(0, Math.min(1, U));        // store u in [0,1]
    const xEnc = 1.0;                               // resources start full

    const u16u = (uEnc * 65535 + 0.5) | 0;
    const uLo = u16u & 255, uHi = (u16u >>> 8) & 255;
    const u16x = (xEnc * 65535 + 0.5) | 0;
    const xLo = u16x & 255, xHi = (u16x >>> 8) & 255;

    const bytes = new Uint8Array(neiW * neiH * 4);
    for(let i=0;i<neiW*neiH;i++){
      bytes[i*4+0]=uLo; bytes[i*4+1]=uHi;
      bytes[i*4+2]=xLo; bytes[i*4+3]=xHi;
    }
    g_stpTexA = makeTexRGBA8(neiW, neiH, bytes);
    g_stpTexB = makeTexRGBA8(neiW, neiH, bytes);
    g_stpFlip = 0;
  }

  function resetSTP(){
    if(storedNeiW>0 && storedNeiH>0){
      initSTPTextures(storedNeiW, storedNeiH);
    }
  }

  function currentSTPTex(){ return g_stpFlip===0 ? g_stpTexA : g_stpTexB; }
  function otherSTPTex(){ return g_stpFlip===0 ? g_stpTexB : g_stpTexA; }

  // Approximate global mean of phi using mipmaps (sample highest LOD). Runs infrequently to avoid stalling.
  let phiMeanEst = 0.0;
  let phiMeanLod = 0.0;
  let phiMeanCounter = 0;

  function updatePhiMeanEstimate(){
    if(!meanTex || !phiA || !phiB) return;
    // Ensure mipmaps exist for current phi texture (requires power-of-two f_N).
    gl.bindTexture(gl.TEXTURE_2D, currentPhiTex());
    gl.generateMipmap(gl.TEXTURE_2D);

    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, meanTex, 0);
    gl.viewport(0,0,1,1);
    gl.disable(gl.BLEND);

    gl.useProgram(meanProg);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, currentPhiTex());
    gl.uniform1i(MPU.tex, 0);
    gl.uniform1f(MPU.lod, phiMeanLod);
    gl.drawArrays(gl.TRIANGLES, 0, 3);

    const px = new Uint8Array(4);
    gl.readPixels(0,0,1,1, gl.RGBA, gl.UNSIGNED_BYTE, px);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0,0,canvas.width,canvas.height);

    const r = px[0] / 255.0; // mean stored in R
    const phiMean = r*2.0 - 1.0;
    // Smooth to avoid jitter
    phiMeanEst = phiMeanEst*0.9 + phiMean*0.1;
  }

  function updateATPMetaEstimate(){
    if(!meanTex || !metaA || !metaB) return;

    gl.bindTexture(gl.TEXTURE_2D, currentMetaTex());
    gl.generateMipmap(gl.TEXTURE_2D);

    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, meanTex, 0);
    gl.viewport(0,0,1,1);
    gl.disable(gl.BLEND);

    gl.useProgram(meanProg);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, currentMetaTex());
    gl.uniform1i(MPU.tex, 0);
    gl.uniform1f(MPU.lod, phiMeanLod);
    gl.drawArrays(gl.TRIANGLES, 0, 3);

    const px = new Uint8Array(4);
    gl.readPixels(0,0,1,1, gl.RGBA, gl.UNSIGNED_BYTE, px);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0,0,canvas.width,canvas.height);

    const r = px[0] / 255.0; // mean ATP stored in R
    atpMeanEst = atpMeanEst*0.92 + r*0.08;
  }


  // ===== Shaders =====
  FULL_VS = `#version 300 es
  precision highp float;
  const vec2 V[3] = vec2[3](vec2(-1.0,-1.0), vec2(3.0,-1.0), vec2(-1.0,3.0));
  out vec2 v_uv;
  void main(){ vec2 p=V[gl_VertexID]; v_uv=0.5*(p+1.0); gl_Position=vec4(p,0.0,1.0); }`;

  const GRAPH_FS = `#version 300 es
  precision highp float; precision highp usampler2D;
  in vec2 v_uv; 
  layout(location = 0) out vec4 outColor;
  layout(location = 1) out uvec4 outNei;

  uniform sampler2D u_thetaCurr, u_thetaDelay, u_omega, u_uvTex, u_fieldTheta, u_infl, u_def, u_meta;
  uniform sampler2D u_neuromod;
  uniform float u_nmOn, u_nmGainK;
  uniform usampler2D u_nei;
  uniform sampler2D u_weights;
  uniform sampler2D u_stp;
  uniform int u_nodeCount, u_texW, u_degK;
  uniform float u_dt, u_K1, u_a1, u_K2, u_a2, u_omegaSpread;
  uniform float u_delayMix, u_Kg, u_ag, u_Rg, u_psig, u_noiseAmp, u_tick;
  uniform float u_Kfg, u_afg, u_fgOn;
  uniform float u_gateOn, u_gateLo, u_gateHi, u_gateBoost;
  uniform float u_gaugeGamma;
  uniform float u_wind;
  uniform float u_inertialOn, u_eta, u_vmax;
  uniform vec2 u_inflTexel;
  uniform float u_topoOn, u_fluxBoost;
  uniform float u_defOn, u_defBoost;
  uniform float u_stpOn, u_stpU, u_stpMax;
  uniform sampler2D u_homeo;
  uniform float u_homeoOn;
  uniform sampler2D u_phiTex;
  uniform float u_cemiCoupling;
  uniform sampler2D u_axonDist;
  uniform float u_axonOn, u_axonSpeed;
  uniform sampler2D u_thetaMid;

  // NEW: Retina and Lobe Uniforms
  uniform int u_lobes;
  uniform sampler2D u_retina;
  uniform float u_retinaOn;
  uniform float u_retinaGain;
  uniform vec4 u_retinaBounds;

  const float TAU=6.28318530718;
  const uint SENT=4294967295u;

  float theta01_from_rg(vec4 px){ float r=px.r*255.0; float g=px.g*255.0; return (r+256.0*g)/65535.0; }
  float vel_from_ba(vec4 px){ float b=px.b*255.0; float a=px.a*255.0; return (b+256.0*a)/65535.0; }

  vec4 packThetaVel01(float th01, float vel01){
    th01=clamp(th01,0.0,1.0);
    vel01=clamp(vel01,0.0,1.0);
    float u=th01*65535.0; float ulo=floor(mod(u,256.0)); float uhi=floor(u/256.0);
    float v=vel01*65535.0; float vlo=floor(mod(v,256.0)); float vhi=floor(v/256.0);
    return vec4(ulo/255.0, uhi/255.0, vlo/255.0, vhi/255.0);
  }
  float readWeight(ivec2 p){ vec4 px=texelFetch(u_weights,p,0); float r=px.r*255.0; float g=px.g*255.0; return (r+256.0*g)/65535.0*2.0; }
  float readAxonDist(ivec2 p){ return texelFetch(u_axonDist,p,0).r; }
  vec2 readSTP(ivec2 p){ vec4 px=texelFetch(u_stp,p,0); float r=px.r*255.0; float g=px.g*255.0; float b=px.b*255.0; float a=px.a*255.0; float u=(r+256.0*g)/65535.0; float x=(b+256.0*a)/65535.0; return vec2(u,x); }
  float stpMul(ivec2 p){ vec2 ux=readSTP(p); float mul = (ux.x * ux.y) / max(u_stpU, 0.0001); return clamp(mul, 0.0, u_stpMax); }
  ivec2 idxToCoord(int idx){ int x=idx-(idx/u_texW)*u_texW; int y=idx/u_texW; return ivec2(x,y); }
  uint getNeighbor(int i,int j){
    int baseX=i-(i/u_texW)*u_texW; int baseY=i/u_texW;
    int x=baseX + j*u_texW; int y=baseY;
    uvec4 v=texelFetch(u_nei, ivec2(x,y), 0);
    return v.r + (v.g<<8) + (v.b<<16) + (v.a<<24);
  }
  vec2 decodeUV(vec4 p){
    float r=p.r*255.0,g=p.g*255.0,b=p.b*255.0,a=p.a*255.0;
    float u=(r+256.0*g)/65535.0; float v=(b+256.0*a)/65535.0; return vec2(u,v);
  }
  vec2 inflVec(vec4 p){ float c=(p.r-p.g); float s=(p.b-p.a); return vec2(c,s); }
float curlA(vec2 uv){
  vec2 t = u_inflTexel;
  vec2 AL = inflVec(texture(u_infl, uv + vec2(-t.x,0.0)));
  vec2 AR = inflVec(texture(u_infl, uv + vec2( t.x,0.0)));
  vec2 AD = inflVec(texture(u_infl, uv + vec2(0.0,-t.y)));
  vec2 AU = inflVec(texture(u_infl, uv + vec2(0.0, t.y)));
  float dAy_dx = (AR.y - AL.y) * 0.5;
  float dAx_dy = (AU.x - AD.x) * 0.5;
  return dAy_dx - dAx_dy;
}
  float hashNoise(float x,float y){ float n=sin(x*12.9898+y*78.233)*43758.5453; return (fract(n)-0.5)*2.0; }

  void main(){
    ivec2 p=ivec2(gl_FragCoord.xy);
    int i=p.x + p.y*u_texW;
    if(i>=u_nodeCount){ outColor=texelFetch(u_thetaCurr,p,0); return; }

    vec4 px_i = texelFetch(u_thetaCurr,p,0);
    float th_i=theta01_from_rg(px_i)*TAU;
    float vel01_i = vel_from_ba(px_i);
    float vel_i = (vel01_i*2.0 - 1.0) * u_vmax;

    vec2 uv_i = decodeUV(texelFetch(u_uvTex,p,0));

    // Local metabolism: sample ATP at the node's position and gate excitability/oscillation.
    float atpLocal = texture(u_meta, uv_i).r;
    float energyGate = smoothstep(0.06, 0.25, atpLocal);
    float energyScale = mix(0.10, 1.0, atpLocal);

    float B_i = 0.0;
    float kMul = 1.0;
    if(u_topoOn>0.5 && u_fluxBoost!=0.0){
      B_i = curlA(uv_i);
      kMul = 1.0 + u_fluxBoost * abs(B_i);
    }

    if(u_defOn>0.5 && u_defBoost!=0.0){
      float qDef = texture(u_def, uv_i).r * 2.0 - 1.0;
      kMul *= (1.0 + u_defBoost * abs(qDef));
    }

    float omU=texelFetch(u_omega,p,0).r;
    float omega=(omU-0.5)*(2.0*u_omegaSpread);
    omega *= smoothstep(0.12, 0.45, atpLocal);

    float nodesPerLobe = float(u_nodeCount) / max(1.0, float(u_lobes));
    float myLobe = floor(float(i) / nodesPerLobe);

    float retinaForce = 0.0;
    if(u_retinaOn > 0.5 && myLobe < 0.5) {
        // Map image EXACTLY onto Lobe 0's physical boundaries
        vec2 span = max(u_retinaBounds.zw, vec2(1e-6));
        vec2 retUV = (uv_i - u_retinaBounds.xy) / span;
        retUV.y = 1.0 - retUV.y; // Standard flip
        retUV.x = 1.0 - retUV.x; // Mirror for webcam

        if(retUV.x >= 0.0 && retUV.x <= 1.0 && retUV.y >= 0.0 && retUV.y <= 1.0) {
            vec3 rgb = texture(u_retina, retUV).rgb;
            float brightness = dot(rgb, vec3(0.299, 0.587, 0.114)); 
            // Massive direct current injection (overrides natural omega)
            retinaForce = (brightness - 0.3) * u_retinaGain * 6.0; 
        }
    }

    float sum1=0.0,sum2=0.0,cnt=0.0;
    for(int j=0;j<32;j++){
      if(j>=u_degK) break;
      uint nbU=getNeighbor(i,j);
      if(nbU==SENT) continue;
      int nb=int(nbU);
      ivec2 q=idxToCoord(nb);
      float th_j0=theta01_from_rg(texelFetch(u_thetaCurr,q,0))*TAU;
      float th_jd=theta01_from_rg(texelFetch(u_thetaDelay,q,0))*TAU;
      float th_jm=0.5*(th_j0+th_jd); // approx mid-delay (saves one texture)
      // Per-edge delay: nearby nodes couple instantly, distant nodes are delayed
      float edgeMix;
      if(u_axonOn > 0.5){
        int dX = (i - (i/u_texW)*u_texW) + j*u_texW;
        int dY = i / u_texW;
        float dist = readAxonDist(ivec2(dX, dY));
        edgeMix = clamp(dist / max(u_axonSpeed, 0.001), 0.0, 1.0);
      } else {
        edgeMix = clamp(u_delayMix, 0.0, 1.0);
      }
      // Piecewise-linear 3-point interpolation: 0→current, 0.5→mid, 1.0→delayed
      float th_j;
      if(edgeMix < 0.5){
        float t2 = edgeMix * 2.0;
        th_j = th_j0 + t2 * (th_jm - th_j0);
      } else {
        float t2 = (edgeMix - 0.5) * 2.0;
        th_j = th_jm + t2 * (th_jd - th_jm);
      }
      float d=th_j-th_i;
      // Gauge / holonomy edge phase from influence field (vector potential)
      vec2 uv_j = decodeUV(texelFetch(u_uvTex,q,0));
      vec2 dUV = uv_j - uv_i;
      // shortest wrap on torus
      dUV -= floor(dUV + 0.5);
      vec2 midUV = fract(uv_i + 0.5*dUV);
      vec2 A = inflVec(texture(u_infl, midUV));
      float phi = u_gaugeGamma * TAU * dot(A, dUV);

      // Directed Wind: Boost coupling if fluid flows from j to i
      // A points along flow. dUV points i->j. 
      // If dot(A, dUV) is negative, flow is j->i, so we boost the weight.
      float flowProj = dot(A, dUV);
      float windMultiplier = clamp(exp(-u_wind * flowProj * 15.0), 0.1, 10.0);

      // Read per-edge Hebbian weight
      int wX = (i - (i/u_texW)*u_texW) + j*u_texW;
      int wY = i / u_texW;
      float ew = readWeight(ivec2(wX, wY)) * ((u_stpOn>0.5) ? stpMul(ivec2(wX, wY)) : 1.0);

      ew *= windMultiplier; // Apply directed asymmetry

      // --- DALE'S LAW (80/20 Rule) ---
      // Read type of neighbor j from its omega texture (G channel: 1.0=E, 0.0=I)
      float type_j = texelFetch(u_omega, q, 0).g;

      // Inhibitory nodes push anti-phase and are slightly stronger per connection 
      // to balance the fact that they are outnumbered 4-to-1 by E-nodes.
      float sign_j = type_j > 0.5 ? 1.0 : -2.5; 
      ew *= sign_j;

      sum1 += ew * sin(d - u_a1 - phi);
      sum2 += ew * sin(2.0*d - u_a2 - 2.0*phi);
      cnt += 1.0;
    }
    float inv=(cnt>0.0)?(1.0/cnt):0.0;
    float coup1=sum1*inv;
    float coup2=sum2*inv;

    float gateMul=1.0;
    float nmMul = 1.0;
    if(u_nmOn>0.5){
      vec3 nm = texture(u_neuromod, uv_i).rgb;
      // Glutamate (G) intensely boosts coupling, GABA (B) actively suppresses it
      nmMul = clamp(1.0 + u_nmGainK * (nm.g * 2.0 - nm.b * 1.5), 0.1, 5.0);
    }

    if(u_gateOn>0.5){
      float amp=length(inflVec(texture(u_infl,uv_i)));
      float g=smoothstep(u_gateLo,u_gateHi,amp);
      gateMul=1.0 + u_gateBoost*g;
    }

    float fterm=0.0;
    if(u_fgOn>0.5){
      float th_f=theta01_from_rg(texture(u_fieldTheta,uv_i))*TAU;
      fterm = u_Kfg * gateMul * sin(th_f - th_i - u_afg);
    }

    float gterm=0.0;
    if(u_Kg>0.0 && u_Rg>0.0){
      gterm = u_Kg * u_Rg * sin(u_psig - th_i - u_ag);
    }

    float nterm=0.0;
    if(u_noiseAmp>0.0){
      float nn=hashNoise(float(i)+1.0,u_tick);
      nterm=u_noiseAmp*nn;
    }

    float H_i = 1.0;
    if(u_homeoOn > 0.5){
      vec4 hpx = texelFetch(u_homeo, p, 0);
      float r=hpx.r*255.0; float g=hpx.g*255.0;
      H_i = ((r+256.0*g)/65535.0) * 4.0;
    }

    // Apply local energy envelope (approx SNIC-like excitability gating)
    H_i *= energyScale * energyGate;

    // --- NON-LINEAR EPHAPTIC COUPLING (PRC) ---
    // Scale the raw amplitude down slightly so it doesn't instantly blow past vmax
    float localWave = (texture(u_phiTex, uv_i).r * 16.0 - 8.0) * 0.06;
    // PRC logic: Node is most sensitive to the field when theta is near 2*PI (firing)
    float phaseSensitivity = (1.0 - cos(th_i)); 
    float cemiForce = u_cemiCoupling * localWave * phaseSensitivity;

    float inputs = gateMul*nmMul*(kMul*(u_K1*coup1 + u_K2*coup2)) + (nmMul*fterm) + gterm + nterm;

    // BUG FIX: CEMI is now inside the Homeostatic envelope (H_i). 
    // If a node is exhausted by ATP or local seizures, it will naturally ignore the CEMI wave!
    // Inject Retina directly into the physical current computation
    float force = omega + H_i * (inputs + cemiForce + retinaForce);

    float th2;
    float vel2;
    if(u_inertialOn>0.5){
      // Inertial Kuramoto: dtheta = v, dv = force - eta*v
      vel2 = vel_i + u_dt * (force - u_eta * vel_i);
      vel2 = clamp(vel2, -u_vmax, u_vmax);
      th2 = th_i + u_dt * vel2;
    } else {
      // Classic first-order Kuramoto
      vel2 = force;
      th2 = th_i + u_dt * force;
    }
    th2 = mod(th2, TAU); if(th2<0.0) th2 += TAU;
    float vel01 = clamp(vel2 / u_vmax * 0.5 + 0.5, 0.0, 1.0);
        outColor = packThetaVel01(th2/TAU, vel01);
  }`;

  const UV_FS = `#version 300 es
  precision highp float;
  in vec2 v_uv; out vec4 outColor;

  uniform sampler2D u_uvCurr;
  uniform sampler2D u_infl;
  uniform int u_nodeCount;
  uniform int u_texW;
  uniform float u_dt;
  uniform float u_motility;
  uniform float u_tick; 
  uniform vec2 u_inflTexel; 

  float hashNoise(float x,float y){ float n=sin(x*12.9898+y*78.233)*43758.5453; return fract(n); }

  vec2 decodeUV(vec4 p){
    float r=p.r*255.0, g=p.g*255.0, b=p.b*255.0, a=p.a*255.0;
    return vec2((r+256.0*g)/65535.0, (b+256.0*a)/65535.0);
  }
  vec4 encodeUV(vec2 uv){
    uv = fract(uv); // Torus wrap
    float uu = uv.x * 65535.0; float loU = floor(mod(uu, 256.0)); float hiU = floor(uu / 256.0);
    float vv = uv.y * 65535.0; float loV = floor(mod(vv, 256.0)); float hiV = floor(vv / 256.0);
    return vec4(loU/255.0, hiU/255.0, loV/255.0, hiV/255.0);
  }
  vec2 inflVec(vec4 p){ return vec2(p.r-p.g, p.b-p.a); }

  // Manual bilinear filter for NEAREST textures to prevent grid-alignment artifacts
  vec2 smoothInfl(vec2 uv) {
      vec2 sz = 1.0 / u_inflTexel;
      vec2 p = uv * sz - 0.5;
      vec2 i = floor(p);
      vec2 f = fract(p);

      vec2 v00 = inflVec(texture(u_infl, (i + vec2(0.5, 0.5)) * u_inflTexel));
      vec2 v10 = inflVec(texture(u_infl, (i + vec2(1.5, 0.5)) * u_inflTexel));
      vec2 v01 = inflVec(texture(u_infl, (i + vec2(0.5, 1.5)) * u_inflTexel));
      vec2 v11 = inflVec(texture(u_infl, (i + vec2(1.5, 1.5)) * u_inflTexel));

      return mix(mix(v00, v10, f.x), mix(v01, v11, f.x), f.y);
  }

  void main(){
    ivec2 p = ivec2(gl_FragCoord.xy);
    int i = p.x + p.y * u_texW;
    vec4 curr = texelFetch(u_uvCurr, p, 0);
    if(i >= u_nodeCount){ outColor = curr; return; }

    vec2 uv = decodeUV(curr);

    // Use smooth bilinear sampling to find the gradient
    vec2 t = u_inflTexel;
    float aL = length(smoothInfl(uv + vec2(-t.x, 0.0)));
    float aR = length(smoothInfl(uv + vec2( t.x, 0.0)));
    float aD = length(smoothInfl(uv + vec2(0.0, -t.y)));
    float aU = length(smoothInfl(uv + vec2(0.0,  t.y)));

    vec2 gradA = vec2(aR - aL, aU - aD);

    // Incompressible flow: rotate gradient 90 degrees. 
    // This perfectly matches the fluid's own advection velocity!
    vec2 flow = vec2(gradA.y, -gradA.x);

    float speed = length(flow);
    vec2 dir = speed > 0.00001 ? flow / speed : vec2(0.0);

    // Speed multiplier (gradient diffs are small)
    float cappedSpeed = min(speed * 15.0, 1.5);

    // Very slight noise to keep things organic and prevent stacking
    float n1 = hashNoise(uv.x * 13.0 + float(i), u_tick) - 0.5;
    float n2 = hashNoise(uv.y * 19.0 - float(i), u_tick + 1.0) - 0.5;
    vec2 jitter = vec2(n1, n2) * 0.002;

    vec2 nextUV = uv + dir * cappedSpeed * u_motility * u_dt * 0.02 + jitter * u_motility;

    outColor = encodeUV(nextUV);
  }`;

  const FIELD_FS = `#version 300 es
  precision highp float;
  in vec2 v_uv; 
  layout(location = 0) out vec4 outColor;
  layout(location = 1) out uvec4 outNei;
  uniform sampler2D u_thetaCurr,u_thetaDelay,u_omega,u_infl,u_def,u_phi,u_meta;
  uniform vec2 u_inflTexel;
  uniform float u_topoOn, u_Kflux;
  uniform float u_defOn, u_Kdef;
  uniform float u_phiWarp;
  uniform float u_dt,u_Ke,u_Ki,u_a1,u_K2,u_a2,u_omegaSpread;
  uniform float u_gfOn,u_Kgf,u_agf;
  uniform vec2 u_texel;
  const float TAU=6.28318530718;
  float theta01_from_rg(vec4 px){ float r=px.r*255.0; float g=px.g*255.0; return (r+256.0*g)/65535.0; }
  vec4 packTheta01(float th01){
    th01=clamp(th01,0.0,1.0);
    float u=th01*65535.0; float lo=floor(mod(u,256.0)); float hi=floor(u/256.0);
    return vec4(lo/255.0,hi/255.0,128.0/255.0,1.0);
  }
  vec2 inflVec(vec4 p){ float c=(p.r-p.g); float s=(p.b-p.a); return vec2(c,s); }
  float phiSigned(vec2 uv){ return texture(u_phi, uv).r*16.0-8.0; }
float curlA(vec2 uv){
  vec2 t=u_inflTexel;
  vec2 AL=inflVec(texture(u_infl, uv+vec2(-t.x,0.0)));
  vec2 AR=inflVec(texture(u_infl, uv+vec2( t.x,0.0)));
  vec2 AD=inflVec(texture(u_infl, uv+vec2(0.0,-t.y)));
  vec2 AU=inflVec(texture(u_infl, uv+vec2(0.0, t.y)));
  float dAy_dx=(AR.y-AL.y)*0.5;
  float dAx_dy=(AU.x-AD.x)*0.5;
  return dAy_dx - dAx_dy;
}
  void main(){
    // Geometry warp: treat phi as a conformal metric proxy and warp sampling along grad(phi).
    vec2 baseUV = v_uv;
    if(abs(u_phiWarp) > 1e-6){
      vec2 t = u_texel;
      float pL = phiSigned(baseUV + vec2(-t.x,0.0));
      float pR = phiSigned(baseUV + vec2( t.x,0.0));
      float pD = phiSigned(baseUV + vec2(0.0,-t.y));
      float pU = phiSigned(baseUV + vec2(0.0, t.y));
      vec2 g = vec2(pR - pL, pU - pD);
      baseUV = fract(baseUV + u_phiWarp * 0.35 * g);
    }

    float th=theta01_from_rg(texture(u_thetaCurr,baseUV))*TAU;
    float omU=texture(u_omega,baseUV).r;
    float omega=(omU-0.5)*(2.0*u_omegaSpread);
    float atp = texture(u_meta, baseUV).r;
    float energyGate = mix(0.15, 1.0, atp);
    omega *= energyGate;

    vec2 t=u_texel;
    float e1=0.0,e2=0.0;
    vec2 offs[8]=vec2[8](vec2(t.x,0.0),vec2(-t.x,0.0),vec2(0.0,t.y),vec2(0.0,-t.y),
                         vec2(t.x,t.y),vec2(-t.x,t.y),vec2(t.x,-t.y),vec2(-t.x,-t.y));
    for(int i=0;i<8;i++){
      float thj=theta01_from_rg(texture(u_thetaDelay,baseUV+offs[i]))*TAU;
      float d=thj-th; e1+=sin(d-u_a1); e2+=sin(2.0*d-u_a2);
    }
    e1*=1.0/8.0; e2*=1.0/8.0;

    float i1=0.0;
    vec2 t3=3.0*t;
    vec2 io[12]=vec2[12](vec2(t3.x,0.0),vec2(-t3.x,0.0),vec2(0.0,t3.y),vec2(0.0,-t3.y),
                         vec2(t3.x,t3.y),vec2(-t3.x,t3.y),vec2(t3.x,-t3.y),vec2(-t3.x,-t3.y),
                         vec2(2.0*t.x,3.0*t.y),vec2(-2.0*t.x,3.0*t.y),vec2(2.0*t.x,-3.0*t.y),vec2(-2.0*t.x,-3.0*t.y));
    for(int i=0;i<12;i++){
      float thj=theta01_from_rg(texture(u_thetaDelay,baseUV+io[i]))*TAU;
      float d=thj-th; i1+=sin(d-u_a1);
    }
    i1*=1.0/12.0;

    float localTerm=u_Ke*e1 - u_Ki*i1 + u_K2*e2;
    localTerm *= energyGate;

    float gTerm=0.0;
    if(u_gfOn>0.5){
      vec2 v=inflVec(texture(u_infl,baseUV));
      float amp=clamp(length(v),0.0,3.0);
      float phi=atan(v.y,v.x);
      gTerm=u_Kgf*amp*sin(phi-th-u_agf);
    }

    float topoTerm=0.0;
    if(u_topoOn>0.5 && u_Kflux!=0.0){ topoTerm = u_Kflux * curlA(baseUV); }
    if(u_defOn>0.5 && u_Kdef!=0.0){ float qDef=texture(u_def,baseUV).r*2.0-1.0; topoTerm += u_Kdef*qDef; }
    float th2=mod(th + u_dt*(omega+localTerm+gTerm+topoTerm), TAU); if(th2<0.0) th2+=TAU;
    outColor=packTheta01(th2/TAU);
  }`;


  // Neuromodulator bath field (separate from phase/curvature fields).
  // Stores neuromod value m in R channel (0..1). It diffuses, decays toward baseline,
  // and is driven by local activity estimated from |influence vector|.
  // Multi-Chemical Bath. RGB channels mapped to biological neurotransmitters.
  const NEUROMOD_FS = `#version 300 es
  precision highp float;
  in vec2 v_uv; 
  layout(location = 0) out vec4 outColor;

  uniform sampler2D u_prev;
  uniform sampler2D u_infl;
  uniform sampler2D u_meta;
  uniform vec2 u_texel;
  uniform float u_dt;
  uniform float u_tau;
  uniform float u_D;
  uniform float u_drive;
  uniform float u_base;

  uniform float u_gliaOn;
  uniform float u_gliaMop;

  vec2 inflVec(vec4 p){ return vec2(p.r-p.g, p.b-p.a); }

  void main(){
    vec2 uv = v_uv;
    vec4 prev = texture(u_prev, uv);
    vec3 mC = prev.rgb;         // R=Dopamine, G=Glutamate, B=GABA
    float actSlow = prev.a;     // Slow activity trace for DA phasic signaling

    // 5-point laplacian
    vec3 mL = texture(u_prev, uv + vec2(-u_texel.x, 0.0)).rgb;
    vec3 mR = texture(u_prev, uv + vec2( u_texel.x, 0.0)).rgb;
    vec3 mD = texture(u_prev, uv + vec2(0.0, -u_texel.y)).rgb;
    vec3 mU = texture(u_prev, uv + vec2(0.0,  u_texel.y)).rgb;
    vec3 lap = (mL + mR + mD + mU - 4.0 * mC);

    // Local metabolism
    vec4 meta = texture(u_meta, uv);
    float atp = meta.r;
    float glia = meta.g;

    // Activity from influence buffer (consistent scaling used by meta shader too)
    vec2 iv = inflVec(texture(u_infl, uv));
    float act = clamp(length(iv) * 1.2, 0.0, 1.0);

    // Update slow activity trace (EMA, ~2 second time constant)
    actSlow = mix(actSlow, act, u_dt * 0.5);

    // Per-chemical resting baselines
    vec3 base = vec3(u_base * 0.4, u_base, u_base * 0.6);

    // ---- DOPAMINE (R): PHASIC — responds to novelty/surprise, not absolute activity ----
    // Positive temporal difference = something new is happening
    float surprise = max(0.0, act - actSlow - 0.03);
    // Amplify the surprise signal but gate by energy
    float daDrive = surprise * 4.0 * smoothstep(0.10, 0.40, atp);

    // ---- GLUTAMATE (G): activity-dependent excitatory release ----
    float gluDrive = act * smoothstep(0.10, 0.35, atp);

    // ---- GABA (B): inhibitory — driven by high activity AND low energy ----
    float gabaFromExhaustion = (1.0 - smoothstep(0.15, 0.50, atp)) * 0.6;
    float gabaFromActivity = smoothstep(0.35, 0.70, act) * 0.5;
    float gabaDrive = gabaFromExhaustion + gabaFromActivity;

    float tau = max(u_tau, 0.1);

    // CRITICAL FIX: Self-limiting release — (1-m) prevents hard saturation.
    // As concentration rises, release efficiency drops (autoreceptor feedback).
    // Steady state becomes: m = (base + tau*drive*signal) / (1 + tau*drive*signal)
    // This keeps all channels in a useful dynamic range.
    vec3 rawDrive = vec3(daDrive, gluDrive, gabaDrive);
    vec3 release = rawDrive * u_drive * max(vec3(0.0), 1.0 - mC);

    // Decay toward resting baseline
    vec3 dm = u_D * lap - (mC - base) / tau + release;
    vec3 m2 = clamp(mC + u_dt * dm, 0.0, 1.0);

    // Glial buffering: mops excess glutamate, mildly raises GABA
    if(u_gliaOn > 0.5){
      float mopRate = u_gliaMop * glia;
      float excessGlu = max(0.0, m2.g - base.y);
      m2.g = max(base.y, m2.g - mopRate * excessGlu * u_dt);
      m2.b = clamp(m2.b + 0.20 * mopRate * excessGlu * u_dt, 0.0, 1.0);
    }

    outColor = vec4(m2, actSlow);
  }`;


  // Spatially distributed metabolism field (GPU):
  //   R = ATP (local energy availability 0..1)
  //   G = Glial buffer (slow metabolic/environmental cleanup 0..1)
  // This breaks the old "single global ATP variable" and creates local firebreaks/sleep pockets.
  const META_FS = `#version 300 es
  precision highp float;
  in vec2 v_uv;
  layout(location = 0) out vec4 outColor;

  uniform sampler2D u_prev;
  uniform sampler2D u_infl;
  uniform sampler2D u_neuromod;
  uniform vec2 u_texel;
  uniform float u_dt;

  uniform float u_regen;    // blood-flow replenishment
  uniform float u_cost;     // activity burn rate
  uniform float u_diff;     // ATP diffusion

  uniform float u_gliaOn;
  uniform float u_gliaTau;
  uniform float u_gliaYield;
  uniform float u_gliaDrive;
  uniform float u_gliaDiff;

  vec2 inflVec(vec4 p){ return vec2(p.r-p.g, p.b-p.a); }

  void main(){
    vec2 uv = v_uv;

    vec4 mC = texture(u_prev, uv);
    float atp = mC.r;
    float glia = mC.g;

    // 5-point Laplacian diffusion for ATP + glia
    float atpL = texture(u_prev, uv + vec2(-u_texel.x, 0.0)).r;
    float atpR = texture(u_prev, uv + vec2( u_texel.x, 0.0)).r;
    float atpD = texture(u_prev, uv + vec2(0.0, -u_texel.y)).r;
    float atpU = texture(u_prev, uv + vec2(0.0,  u_texel.y)).r;
    float lapA = (atpL + atpR + atpD + atpU - 4.0 * atp);

    float glL = texture(u_prev, uv + vec2(-u_texel.x, 0.0)).g;
    float glR = texture(u_prev, uv + vec2( u_texel.x, 0.0)).g;
    float glD = texture(u_prev, uv + vec2(0.0, -u_texel.y)).g;
    float glU = texture(u_prev, uv + vec2(0.0,  u_texel.y)).g;
    float lapG = (glL + glR + glD + glU - 4.0 * glia);

    // Activity from influence buffer (SAME scaling as neuromod shader)
    vec4 inflPx = texture(u_infl, uv);
    float act = clamp(length(inflVec(inflPx)) * 1.2, 0.0, 1.0);

    // ATP cost scales quadratically — idle neurons are cheap, bursting is expensive
    float consume = u_cost * act * act;

    // Blood flow: replenishment proportional to deficit
    float regen = u_regen * (1.0 - atp);

    // Read neurochemistry for glia coupling
    vec3 nm = texture(u_neuromod, uv).rgb;
    float glu = nm.g;
    float gaba = nm.b;

    // ---- GLIA DYNAMICS ----
    float gOn = step(0.5, u_gliaOn);
    float gTau = max(u_gliaTau, 0.1);

    // Glia is activated by glutamate (cleanup response to excitatory activity)
    // CRITICAL FIX: self-limiting growth (1-glia) prevents permanent saturation.
    // Glia responds to EXCESS glutamate above baseline, not raw concentration.
    float gluExcess = max(0.0, glu - 0.15);
    float gDrive = gOn * u_gliaDrive * gluExcess * (1.0 - glia);

    // Natural decay back toward low resting level
    float gDecay = gOn * glia / gTau;

    // Glia diffuses slowly (astrocyte networks are local)
    glia += u_dt * (u_gliaDiff * lapG + gDrive - gDecay);
    glia = clamp(glia, 0.0, 1.0);

    // Glia → ATP: proportional to glia activation AND ATP deficit
    // (glia metabolizes glycogen reserves to feed hungry neurons)
    float gliaATP = gOn * u_gliaYield * glia * (1.0 - atp);

    // Glia also mildly suppresses local consumption (protective)
    consume *= (1.0 - 0.3 * glia * gOn);

    // ATP update: diffuse + regen + glia rescue - activity cost
    atp += u_dt * (u_diff * lapA + regen + gliaATP - consume);
    atp = clamp(atp, 0.0, 1.0);

    outColor = vec4(atp, glia, 0.0, 1.0);
  }`;

    // CEMI Theory Wave Equation. Phase in R, Velocity in G. 
  // Decoded: phi = r*16-8, vel = g*30-15
  const PHI_FS = `#version 300 es
  precision highp float;
  in vec2 v_uv; out vec4 outColor;

  uniform sampler2D u_phi;
  uniform sampler2D u_def;
  uniform sampler2D u_infl;

  // NEW: anisotropic medium + metabolism coupling
  uniform sampler2D u_meta;      // R=ATP, G=Glia
  uniform sampler2D u_neuromod;  // B channel = GABA, G channel = Glu

  uniform vec2 u_texel;
  uniform float u_dt;
  uniform float u_waveSpeed;
  uniform float u_waveDamping;
  uniform float u_phiInject;
  uniform float u_cemiEmit;
  uniform float u_defOn;
  uniform float u_phiGlobalOn;
  uniform float u_phiTargetMean;
  uniform float u_phiMean;
  uniform float u_phiGlobalRate;

  void main(){
    ivec2 p = ivec2(gl_FragCoord.xy);
    vec4 curr = texelFetch(u_phi, p, 0);

    float phi = curr.r * 16.0 - 8.0; 
    float vel = curr.g * 30.0 - 15.0; 

    vec2 uv = v_uv; vec2 t = u_texel;

    float l = texture(u_phi, fract(uv + vec2(-t.x,0.0))).r * 16.0 - 8.0;
    float r = texture(u_phi, fract(uv + vec2( t.x,0.0))).r * 16.0 - 8.0;
    float d = texture(u_phi, fract(uv + vec2(0.0,-t.y))).r * 16.0 - 8.0;
    float u = texture(u_phi, fract(uv + vec2(0.0, t.y))).r * 16.0 - 8.0;

    float lap = (l + r + d + u - 4.0 * phi);

    float inj = 0.0;
    if(u_defOn > 0.5){
      float q = texture(u_def, v_uv).r*2.0-1.0;
      inj = u_phiInject * abs(q) * 15.0;
    }

    // --- SPIKING EMISSION (local) ---
    vec4 inflPx = texture(u_infl, uv);
    float rawFlux = length(vec2(inflPx.r - inflPx.g, inflPx.b - inflPx.a));
    float spikingEmitter = smoothstep(0.85, 1.0, rawFlux);

    // Local energy / chemistry changes the "thickness" of space (anisotropic permittivity)
    vec4 meta = texture(u_meta, uv);
    float atp = meta.r;
    float glia = meta.g;

    vec3 nm = texture(u_neuromod, uv).rgb;
    float glu = nm.g;
    float gaba = nm.b;

    // Exhausted regions become slow & absorptive (firebreaks)
    float thick = clamp(1.0 - atp, 0.0, 1.0);
    float cEff = u_waveSpeed * mix(0.35, 1.0, atp) * (1.0 + 0.15 * glu);
    float dampEff = u_waveDamping * (1.0 + 1.8 * thick + 1.2 * gaba + 0.6 * glia);

    // Only emit if energy exists (active inference + metabolism synergize)
    spikingEmitter *= smoothstep(0.08, 0.45, atp);

    float drive = 0.0;
    if(u_phiGlobalOn > 0.5){ 
      float globalMean = u_phiMean * 8.0; 
      drive = u_phiGlobalRate * (u_phiTargetMean - globalMean) * 10.0; 
    }

    // d'Alembert Wave Equation: Accel = c^2 * Laplacian - damping * velocity + Drivers
    float accel = cEff * lap * 400.0 - dampEff * vel + inj + drive + u_cemiEmit * spikingEmitter * 8.0;

    float nextV = vel + u_dt * accel;
    float nextPhi = phi + u_dt * nextV;

    outColor = vec4(clamp((nextPhi + 8.0)/16.0, 0.0, 1.0), clamp((nextV + 15.0)/30.0, 0.0, 1.0), 0.0, 1.0);
  }`;



  // Sample mean phi using mipmaps (approx). Render 1x1 and readPixels occasionally.
  const MEAN_FS = `#version 300 es
  precision highp float;
  in vec2 v_uv;
  out vec4 outColor;
  uniform sampler2D u_tex;
  uniform float u_lod;
  void main(){
    float r = textureLod(u_tex, vec2(0.5,0.5), u_lod).r;
    outColor = vec4(r,0.0,0.0,1.0);
  }`;

  const DEFECT_FS = `#version 300 es
  precision highp float;
  in vec2 v_uv;
  out vec4 outColor;

  uniform sampler2D u_theta;
  uniform vec2 u_texel;

  const float TAU=6.28318530718;
  const float PI=3.14159265359;

  float theta01_from_rg(vec4 px){ float r=px.r*255.0; float g=px.g*255.0; return (r+256.0*g)/65535.0; }

  float wrapPMPI(float a){
    // wrap to (-pi, pi]
    a = mod(a + PI, TAU);
    if(a < 0.0) a += TAU;
    return a - PI;
  }

  void main(){
    // cell corners: (0,0)=v_uv, (1,0)=+x, (0,1)=+y, (1,1)=+x+y
    vec2 t = u_texel;
    float th00 = theta01_from_rg(texture(u_theta, v_uv))*TAU;
    float th10 = theta01_from_rg(texture(u_theta, v_uv + vec2(t.x,0.0)))*TAU;
    float th01 = theta01_from_rg(texture(u_theta, v_uv + vec2(0.0,t.y)))*TAU;
    float th11 = theta01_from_rg(texture(u_theta, v_uv + t))*TAU;

    float d0 = wrapPMPI(th10 - th00);
    float d1 = wrapPMPI(th11 - th10);
    float d2 = wrapPMPI(th01 - th11);
    float d3 = wrapPMPI(th00 - th01);

    float q = (d0 + d1 + d2 + d3) / TAU; // ~ integer winding
    q = clamp(q, -1.5, 1.5);

    // encode q in red channel 0..1, keep alpha=1 for safety on some GPUs
    float r = q*0.5 + 0.5;
    outColor = vec4(r, 0.0, 0.0, 1.0);
  }`;

  const DECAY_FS = `#version 300 es
precision highp float;

in vec2 v_uv;
out vec4 outColor;

uniform sampler2D u_in;
uniform sampler2D u_def;

// existing
uniform float u_decay;

// new controls
uniform float u_dt;       // ~1.0
uniform float u_diff;     // 0..1-ish
uniform float u_advect;   // 0..3-ish
uniform float u_swirl;    // 0..6-ish
uniform float u_sharpen;  // 0..2-ish

uniform float u_topoOn;      // enable topological curl forcing
uniform float u_fluxSwirl;   // extra rotation from curl(A)

uniform float u_defOn;        // enable defect feedback
uniform float u_defSwirl;     // rotate influence around defects
uniform float u_defInject;    // inject tangential flow from defect gradients

vec2 inflVec(vec4 p){
  // pos/neg encoding already used elsewhere in this file
  return vec2(p.r - p.g, p.b - p.a);
}
vec4 enc(vec2 v){
  return vec4(max(v.x,0.0), max(-v.x,0.0), max(v.y,0.0), max(-v.y,0.0));
}
vec2 rot(vec2 v, float a){
  float c = cos(a), s = sin(a);
  return vec2(c*v.x - s*v.y, s*v.x + c*v.y);
}

void main(){
  ivec2 sz = textureSize(u_in, 0);
  vec2 texel = 1.0 / vec2(sz);

  vec2 v0 = inflVec(texture(u_in, v_uv));

  vec2 vL = inflVec(texture(u_in, v_uv + vec2(-texel.x, 0.0)));
  vec2 vR = inflVec(texture(u_in, v_uv + vec2( texel.x, 0.0)));
  vec2 vD = inflVec(texture(u_in, v_uv + vec2(0.0, -texel.y)));
  vec2 vU = inflVec(texture(u_in, v_uv + vec2(0.0,  texel.y)));

  // topological curl of A (here A is the influence vector itself)
  float B = ((vR.y - vL.y) - (vU.x - vD.x)) * 0.5;

  float qDef = 0.0;
  vec2 gradQ = vec2(0.0);
  if(u_defOn>0.5){
    float qC = texture(u_def, v_uv).r * 2.0 - 1.0;
    float qL = texture(u_def, v_uv + vec2(-texel.x, 0.0)).r * 2.0 - 1.0;
    float qR = texture(u_def, v_uv + vec2( texel.x, 0.0)).r * 2.0 - 1.0;
    float qD = texture(u_def, v_uv + vec2(0.0, -texel.y)).r * 2.0 - 1.0;
    float qU = texture(u_def, v_uv + vec2(0.0,  texel.y)).r * 2.0 - 1.0;
    qDef = qC;
    gradQ = vec2(qR - qL, qU - qD) * 0.5;
  }

  float a0 = length(v0);
  float aL = length(vL), aR = length(vR), aD = length(vD), aU = length(vU);
  vec2 gradA = vec2(aR - aL, aU - aD);

  // Laplacian diffusion of the signed vector
  vec2 lap = (vL + vR + vD + vU) - 4.0*v0;
  vec2 v = v0 + u_diff * lap;

  // self-advection: flow perpendicular to amplitude gradient (tends to form curls)
  vec2 vel = u_advect * vec2( gradA.y, -gradA.x ); // rot90(gradA)
  vec2 backUV = v_uv - vel * (u_dt * 0.35) * texel;
  vec2 vAdv = inflVec(texture(u_in, backUV));
  v = mix(v, vAdv, clamp(u_advect * 0.35, 0.0, 1.0));

  // swirl: rotate vector by a local “curl-like” term
  float sw = (gradA.x * v.y - gradA.y * v.x);   // 2D cross
  v = rot(v, u_swirl * sw * 0.35);

  // topology-driven swirl from curl(A)
  if(u_topoOn>0.5 && u_fluxSwirl!=0.0){ v = rot(v, u_fluxSwirl * B * 0.35); }

  // defect-driven swirl + tangential injection
  if(u_defOn>0.5){
    v = rot(v, u_defSwirl * qDef * 0.35);
    v += (u_defInject * 0.35) * vec2(gradQ.y, -gradQ.x);
  }

  // sharpen: encourages coherent structures (soft-normalize)
  float m = length(v) + 1e-6;
  float target = mix(m, 1.0, clamp(u_sharpen * 0.25, 0.0, 1.0));
  v *= target / m;

  // mild saturation + decay
  float sat = 1.0 / (1.0 + 0.8*length(v));
  v *= sat;
  v *= u_decay;

  outColor = enc(v);
}`;

  const DRAW_FS = `#version 300 es
  precision highp float;
  in vec2 v_uv; 
  layout(location = 0) out vec4 outColor;
  layout(location = 1) out uvec4 outNei;
  uniform sampler2D u_theta;
  uniform sampler2D u_phi;
  uniform sampler2D u_neuromod;
  uniform float u_alpha,u_time,u_palOn,u_palSpeed;
  uniform int u_colorMode;
  const float TAU=6.28318530718;
  float theta01_from_rg(vec4 px){ float r=px.r*255.0; float g=px.g*255.0; return (r+256.0*g)/65535.0; }
  vec3 hsv2rgb(vec3 c){
    vec4 K=vec4(1.0,2.0/3.0,1.0/3.0,3.0);
    vec3 p=abs(fract(c.xxx+K.xyz)*6.0-K.www);
    return c.z*mix(K.xxx,clamp(p-K.xxx,0.0,1.0),c.y);
  }
  vec3 diverging(float t){
    // blue(0) -> white(0.5) -> red(1)
    vec3 cool=vec3(0.15,0.3,0.9);
    vec3 warm=vec3(0.95,0.2,0.15);
    vec3 mid=vec3(1.0);
    return t<0.5 ? mix(cool,mid,t*2.0) : mix(mid,warm,(t-0.5)*2.0);
  }
  vec3 firePal(float t){
    vec3 c=vec3(0.0);
    c.r=clamp(t*3.0,0.0,1.0);
    c.g=clamp(t*3.0-1.0,0.0,1.0);
    c.b=clamp(t*3.0-2.0,0.0,1.0);
    return c;
  }
  vec3 oceanPal(float t){
    vec3 deep=vec3(0.02,0.05,0.18);
    vec3 mid=vec3(0.05,0.35,0.55);
    vec3 bright=vec3(0.2,0.85,0.75);
    return t<0.5 ? mix(deep,mid,t*2.0) : mix(mid,bright,(t-0.5)*2.0);
  }
  vec3 neonPal(float t){
    vec3 a=vec3(0.85,0.1,0.85);
    vec3 b=vec3(0.1,0.95,0.95);
    vec3 c=vec3(1.0,1.0,1.0);
    return t<0.5 ? mix(a,b,t*2.0) : mix(b,c,(t-0.5)*2.0);
  }
  void main(){
    float th01=theta01_from_rg(texture(u_theta,v_uv));
    float th=th01*TAU;
    float t=u_time*u_palSpeed*u_palOn;
    float hue=fract(th01+t);
    vec3 col;
    if(u_colorMode==0){
      col=hsv2rgb(vec3(hue,1.0,1.0));
    } else if(u_colorMode==1){
      col=diverging(hue);
    } else if(u_colorMode==2){
      col=firePal(hue);
    } else if(u_colorMode==3){
      float v=0.5+0.5*cos(th+t*TAU);
      col=vec3(v);
    } else if(u_colorMode==4){
      // E/I mode on field: just show warm/cool split
      col=diverging(hue);
    } else if(u_colorMode==5){
      // Weight mode on field: fire palette
      col=firePal(hue);
    } else if(u_colorMode==6){
      col=oceanPal(hue);
    } else if(u_colorMode==7){
      col=neonPal(hue);
    } else if(u_colorMode==8){
      // coherence: show as desaturated rainbow
      float sat=0.4+0.4*sin(th);
      col=hsv2rgb(vec3(hue,sat,1.0));
    } else if(u_colorMode==9){
      // frequency band: same as phase rainbow for field
      col=hsv2rgb(vec3(hue,0.85,1.0));
    } else if(u_colorMode==10){
      // CEMI EM Field: R = (phi+8)/16, G = (vel+15)/30
      vec4 phiPx = texture(u_phi, v_uv);
      float phi = phiPx.r * 16.0 - 8.0;
      float vel = phiPx.g * 30.0 - 15.0;
      float phiNorm = clamp(phi / 6.0 * 0.5 + 0.5, 0.0, 1.0);
      vec3 neg = vec3(0.1, 0.15, 0.95);
      vec3 zero = vec3(0.03, 0.03, 0.05);
      vec3 pos = vec3(0.95, 0.15, 0.1);
      col = phiNorm < 0.5 ? mix(neg, zero, phiNorm * 2.0) : mix(zero, pos, (phiNorm - 0.5) * 2.0);
      float velGlow = clamp(abs(vel) / 8.0, 0.0, 1.0);
      col += vec3(velGlow * 0.4);
    } else if(u_colorMode==11){
      // DA / GLU / GABA: direct RGB from neuromod texture
      vec3 nm = texture(u_neuromod, v_uv).rgb;
      float da   = clamp(nm.r * 2.5, 0.0, 1.0);
      float glu  = clamp(nm.g * 2.5, 0.0, 1.0);
      float gaba = clamp(nm.b * 2.5, 0.0, 1.0);
      col = vec3(da, glu, gaba) + 0.03;
    } else {
      col=hsv2rgb(vec3(hue,1.0,1.0));
    }
    outColor=vec4(col, u_alpha);
  }`;

    const EDGE_VS = `#version 300 es
  precision highp float;
  in vec2 a_pos; in float a_idx;
  uniform vec2 u_center; uniform float u_scale,u_aspect;
  uniform sampler2D u_theta,u_fieldTheta,u_nodeWeight,u_uvTex,u_omega; uniform int u_texW;
  uniform sampler2D u_phi, u_neuromod;
  uniform float u_uvScale,u_useField,u_hebbGlow;
  out float v_phase;
  out vec2 v_phasor;
  out float v_weight;
  out float v_type;
  out vec3 v_cemi;
  out vec3 v_nm;
  const float TAU=6.28318530718;
  float theta01_from_rg(vec4 px){ float r=px.r*255.0; float g=px.g*255.0; return (r+256.0*g)/65535.0; }
  float readWeight(vec4 px){ float r=px.r*255.0; float g=px.g*255.0; return (r+256.0*g)/65535.0*2.0; }
  ivec2 idxToCoord(int idx){ int x=idx-(idx/u_texW)*u_texW; int y=idx/u_texW; return ivec2(x,y); }
  void main(){
    int i=int(a_idx+0.5); ivec2 tc=idxToCoord(i);
    vec4 uvPx=texelFetch(u_uvTex,tc,0);
    float r=uvPx.r*255.0, g=uvPx.g*255.0, b=uvPx.b*255.0, a=uvPx.a*255.0;
    vec2 uv=vec2((r+256.0*g)/65535.0, (b+256.0*a)/65535.0);
    v_phase=theta01_from_rg(texelFetch(u_theta,tc,0))*TAU;
    v_phasor=vec2(cos(v_phase),sin(v_phase));
    v_weight = mix(1.0, readWeight(texelFetch(u_nodeWeight,tc,0)), u_hebbGlow);
    v_type = texelFetch(u_omega, tc, 0).g;
    // Sample field-space textures at node UV for CEMI + neuromod color modes
    vec4 phiPx = texture(u_phi, uv);
    v_cemi = vec3(phiPx.r * 16.0 - 8.0, phiPx.g * 30.0 - 15.0, 0.0);
    v_nm = texture(u_neuromod, uv).rgb;
    vec2 dynamicPos = (uv - vec2(0.5)) / u_uvScale;
    vec2 pp=(dynamicPos-u_center)*u_scale; pp.x/=u_aspect;
    gl_Position=vec4(pp,0.0,1.0);
  }`;

    const EDGE_FS = `#version 300 es
  precision mediump float;
  in float v_phase; in vec2 v_phasor; in float v_weight; in float v_type;
  in vec3 v_cemi; in vec3 v_nm;
  uniform float u_alpha,u_palSpeed,u_time,u_palOn;
  uniform int u_colorMode;
  out vec4 outColor;
  const float TAU=6.28318530718;
  vec3 hsv2rgb(vec3 c){
    vec4 K=vec4(1.0,2.0/3.0,1.0/3.0,3.0);
    vec3 p=abs(fract(c.xxx+K.xyz)*6.0-K.www);
    return c.z*mix(K.xxx,clamp(p-K.xxx,0.0,1.0),c.y);
  }
  vec3 diverging(float t){
    vec3 cool=vec3(0.15,0.3,0.9);
    vec3 warm=vec3(0.95,0.2,0.15);
    vec3 mid=vec3(1.0);
    return t<0.5 ? mix(cool,mid,t*2.0) : mix(mid,warm,(t-0.5)*2.0);
  }
  vec3 firePal(float t){
    vec3 c=vec3(0.0);
    c.r=clamp(t*3.0,0.0,1.0);
    c.g=clamp(t*3.0-1.0,0.0,1.0);
    c.b=clamp(t*3.0-2.0,0.0,1.0);
    return c;
  }
  vec3 oceanPal(float t){
    vec3 deep=vec3(0.02,0.05,0.18);
    vec3 mid2=vec3(0.05,0.35,0.55);
    vec3 bright=vec3(0.2,0.85,0.75);
    return t<0.5 ? mix(deep,mid2,t*2.0) : mix(mid2,bright,(t-0.5)*2.0);
  }
  vec3 neonPal(float t){
    vec3 a=vec3(0.85,0.1,0.85);
    vec3 b=vec3(0.1,0.95,0.95);
    vec3 c=vec3(1.0,1.0,1.0);
    return t<0.5 ? mix(a,b,t*2.0) : mix(b,c,(t-0.5)*2.0);
  }
  void main(){
    float t=u_time*u_palSpeed*u_palOn;
    float hue=fract(v_phase/TAU+t);
    float brightness = mix(1.0, length(v_phasor) * clamp(v_weight, 0.3, 2.0), 0.6);
    vec3 col; float a = u_alpha * brightness;

    if(u_colorMode==0){
      // Phase Rainbow (original)
      if(v_type < 0.5){ hue=0.55; brightness*=1.2; }
      col=hsv2rgb(vec3(hue, 1.0, clamp(brightness, 0.15, 1.0)));
      a=u_alpha*brightness;
    } else if(u_colorMode==1){
      // Diverging cool/warm
      col=diverging(hue)*clamp(brightness,0.15,1.0);
    } else if(u_colorMode==2){
      // Fire
      col=firePal(hue)*clamp(brightness,0.2,1.0);
    } else if(u_colorMode==3){
      // Monochrome
      float v=0.5+0.5*cos(v_phase+t*TAU);
      col=vec3(v*clamp(brightness,0.15,1.0));
    } else if(u_colorMode==4){
      // E/I Cell Type: excitatory=cyan, inhibitory=magenta
      vec3 excColor=vec3(0.15,0.85,0.95);
      vec3 inhColor=vec3(0.95,0.2,0.75);
      vec3 base=v_type<0.5 ? inhColor : excColor;
      float pulse=0.6+0.4*cos(v_phase);
      col=base*pulse*clamp(brightness,0.3,1.0);
    } else if(u_colorMode==5){
      // Synaptic Weight heat map
      float w=clamp(v_weight*0.5,0.0,1.0);
      vec3 lo=vec3(0.05,0.0,0.2);
      vec3 mid2=vec3(0.1,0.8,0.3);
      vec3 hi=vec3(1.0,1.0,0.2);
      col=w<0.5 ? mix(lo,mid2,w*2.0) : mix(mid2,hi,(w-0.5)*2.0);
      col*=clamp(brightness,0.3,1.0);
    } else if(u_colorMode==6){
      // Ocean
      col=oceanPal(hue)*clamp(brightness,0.15,1.0);
    } else if(u_colorMode==7){
      // Neon Plasma
      col=neonPal(hue)*clamp(brightness,0.15,1.0);
    } else if(u_colorMode==8){
      // Phase Coherence: bright = in sync, dim = desync
      float coherence=length(v_phasor);
      float val=coherence*clamp(v_weight,0.3,1.5);
      vec3 sync=vec3(0.3,1.0,0.5);
      vec3 desync=vec3(0.6,0.1,0.15);
      col=mix(desync,sync,clamp(val,0.0,1.0));
      a=u_alpha*clamp(val*1.5,0.15,1.0);
    } else if(u_colorMode==9){
      // Frequency Band
      float freqHue=fract(v_weight*0.75+0.1);
      float sat=v_type<0.5 ? 0.7 : 1.0;
      col=hsv2rgb(vec3(freqHue, sat, clamp(brightness,0.2,1.0)));
    } else if(u_colorMode==10){
      // CEMI EM Field on edges: phi from vertex shader
      float phi = v_cemi.x;
      float vel = v_cemi.y;
      float phiNorm = clamp(phi / 6.0 * 0.5 + 0.5, 0.0, 1.0);
      vec3 neg = vec3(0.1, 0.2, 0.95);
      vec3 zero = vec3(0.05, 0.05, 0.08);
      vec3 pos = vec3(0.95, 0.2, 0.1);
      col = phiNorm < 0.5 ? mix(neg, zero, phiNorm * 2.0) : mix(zero, pos, (phiNorm - 0.5) * 2.0);
      float velGlow = clamp(abs(vel) / 8.0, 0.0, 1.0);
      col += vec3(velGlow * 0.35);
      a = u_alpha * (0.4 + velGlow * 0.6 + abs(phi) * 0.05);
    } else if(u_colorMode==11){
      // DA / GLU / GABA on edges
      float da   = clamp(v_nm.r * 2.5, 0.0, 1.0);
      float glu  = clamp(v_nm.g * 2.5, 0.0, 1.0);
      float gaba = clamp(v_nm.b * 2.5, 0.0, 1.0);
      col = vec3(da, glu, gaba) + 0.04;
      float nmStrength = max(da, max(glu, gaba));
      a = u_alpha * (0.3 + nmStrength * 0.7);
    } else {
      col=hsv2rgb(vec3(hue, 1.0, clamp(brightness, 0.15, 1.0)));
    }
    outColor = vec4(col, a);
  }`;

  const SPLAT_VS = `#version 300 es
  precision highp float;
  in vec2 a_uv; in float a_idx;
  uniform sampler2D u_theta, u_uvTex; uniform int u_gTexW;
  uniform float u_pointSize;
  out float v_phase;
  const float TAU=6.28318530718;
  float theta01_from_rg(vec4 px){ float r=px.r*255.0; float g=px.g*255.0; return (r+256.0*g)/65535.0; }
  ivec2 idxToCoord(int idx){ int x=idx-(idx/u_gTexW)*u_gTexW; int y=idx/u_gTexW; return ivec2(x,y); }
  void main(){
    int i=int(a_idx+0.5); ivec2 tc=idxToCoord(i);
    v_phase=theta01_from_rg(texelFetch(u_theta,tc,0))*TAU;

    vec4 uvPx=texelFetch(u_uvTex,tc,0);
    float r=uvPx.r*255.0, g=uvPx.g*255.0, b=uvPx.b*255.0, a=uvPx.a*255.0;
    vec2 uv=vec2((r+256.0*g)/65535.0, (b+256.0*a)/65535.0);

    gl_Position=vec4(uv*2.0-1.0,0.0,1.0);
    gl_PointSize=u_pointSize;
  }`;

  const SPLAT_FS = `#version 300 es
  precision highp float;
  in float v_phase; 
  out vec4 outColor;

  uniform float u_gain;
  uniform sampler2D u_fieldTheta;
  uniform sampler2D u_meta;
  uniform float u_aiOn;
  uniform float u_aiThresh;
  uniform float u_pacOn;
  uniform float u_pacThresh;

  const float TAU=6.28318530718;
  const float PI=3.14159265359;

  float theta01_from_rg(vec4 px){
    float r=px.r*255.0; float g=px.g*255.0;
    return (r+256.0*g)/65535.0;
  }
  float wrapPMPI(float a){
    a = mod(a + PI, TAU);
    if(a < 0.0) a += TAU;
    return a - PI;
  }

  void main(){
    vec2 d = gl_PointCoord - vec2(0.5);
    float w = exp(-dot(d,d)*18.0);

    // Map this fragment to the field grid (splat FBO is f_N x f_N)
    ivec2 sz = textureSize(u_meta, 0);
    vec2 uv = (gl_FragCoord.xy - vec2(0.5)) / vec2(sz);

    // Local metabolism: splat strength depends on local ATP
    float atp = texture(u_meta, uv).r;
    float gain = u_gain * mix(0.10, 1.0, atp);

    float fieldTh = theta01_from_rg(texture(u_fieldTheta, uv)) * TAU;

    // Cross-frequency multiplexing (Phase-Amplitude Coupling):
    // allow "gamma payload" only near peaks of the slow carrier wave (field theta)
    if(u_pacOn > 0.5){
      float carrier = 0.5 + 0.5*cos(fieldTh);
      float pg = smoothstep(u_pacThresh, min(1.0, u_pacThresh + 0.25), carrier);
      gain *= pg;
    }

    // Active inference: only emit if "surprise" (phase mismatch vs local field) is high
    if(u_aiOn > 0.5){
      float diff = abs(wrapPMPI(fieldTh - v_phase));
      float surprise = 0.5 * (1.0 - cos(diff)); // 0..1
      float gate = smoothstep(u_aiThresh, min(1.0, u_aiThresh + 0.25), surprise);
      gain *= gate;
    }

    float c = cos(v_phase), s = sin(v_phase);
    outColor = vec4(max(c,0.0),max(-c,0.0),max(s,0.0),max(-s,0.0))*(gain*w);
  }`;

  // ===== Hebbian weight update shader =====
  const WEIGHT_FS = `#version 300 es
  precision highp float; precision highp usampler2D;
  in vec2 v_uv; 
  layout(location = 0) out vec4 outColor;
  layout(location = 1) out uvec4 outNei;

  uniform sampler2D u_thetaCurr;
  uniform sampler2D u_uvTex;
  uniform sampler2D u_neuromod;
  uniform sampler2D u_weights;
  uniform sampler2D u_nodeWeights;
  uniform usampler2D u_nei;

  // NEW: node type + metabolism for inhibitory plasticity and local learning gates
  uniform sampler2D u_omega;
  uniform sampler2D u_meta;

  uniform int u_nodeCount, u_texW, u_degK;
  uniform float u_decay, u_lr, u_wMin, u_wMax, u_wRest;
  uniform float u_stdpMix, u_tick;
  uniform float u_nmOn, u_nmGainLR;
  uniform float u_normRate;
  uniform float u_rewireOn;
  uniform float u_vmax;

  // Inhibitory Plasticity: repel perfect synchrony to create chimera boundaries
  uniform float u_inhibAntiSync;

  const float TAU=6.28318530718;
  const uint SENT=4294967295u;

  float theta01_from_rg(vec4 px){ float r=px.r*255.0; float g=px.g*255.0; return (r+256.0*g)/65535.0; }
  float vel_from_ba(vec4 px){ float b=px.b*255.0; float a=px.a*255.0; return (b+256.0*a)/65535.0; }
  float readWeight(vec4 px){ float r=px.r*255.0; float g=px.g*255.0; return (r+256.0*g)/65535.0*2.0; }
  vec4 packWeight(float w){
    w=clamp(w/2.0,0.0,1.0);
    float u=w*65535.0; float lo=floor(mod(u,256.0)); float hi=floor(u/256.0);
    return vec4(lo/255.0,hi/255.0,0.0,1.0);
  }

  float hashNoise(float x, float y){
    return fract(sin(dot(vec2(x,y), vec2(127.1,311.7))) * 43758.5453123);
  }

  vec2 decodeUV(vec4 p){
    float r=p.r*255.0, g=p.g*255.0, b=p.b*255.0, a=p.a*255.0;
    return vec2((r+256.0*g)/65535.0, (b+256.0*a)/65535.0);
  }

  void main(){
    ivec2 p = ivec2(gl_FragCoord.xy);
    int pixelX = p.x;
    int pixelY = p.y;
    int j = pixelX / u_texW;
    int baseX = pixelX - j * u_texW;
    int i = baseX + pixelY * u_texW;

    if(i >= u_nodeCount || j >= u_degK){
      outColor = texelFetch(u_weights, p, 0);
      outNei = texelFetch(u_nei, p, 0);
      return;
    }

    uvec4 nv = texelFetch(u_nei, p, 0);
    uint nbU = nv.r + (nv.g << 8u) + (nv.b << 16u) + (nv.a << 24u);
    if(nbU == SENT){
      outColor = texelFetch(u_weights, p, 0);
      outNei = nv;
      return;
    }

    ivec2 ci = ivec2(baseX, pixelY);
    vec4 px_i = texelFetch(u_thetaCurr, ci, 0);
    float th_i = theta01_from_rg(px_i) * TAU;
    float vel_i = (vel_from_ba(px_i) * 2.0 - 1.0) * u_vmax;

    int nb = int(nbU);
    ivec2 cj = ivec2(nb - (nb / u_texW) * u_texW, nb / u_texW);
    vec4 px_j = texelFetch(u_thetaCurr, cj, 0);
    float th_j = theta01_from_rg(px_j) * TAU;
    float vel_j = (vel_from_ba(px_j) * 2.0 - 1.0) * u_vmax;

    float w = readWeight(texelFetch(u_weights, p, 0));

    float hebb = cos(th_j - th_i);

    float phaseDiff = sin(th_j - th_i);
    float velMean = 0.5 * (vel_i + vel_j);
    float stdpTerm = phaseDiff * sign(velMean) * 0.5;

    float signal = mix(hebb, hebb + stdpTerm, u_stdpMix);

    // --- Inhibitory anti-sync: if presynaptic node is inhibitory, strengthen when "too synchronous"
    float type_j = texelFetch(u_omega, cj, 0).g;
    if(type_j < 0.5){
      float sync01 = 0.5 + 0.5 * hebb;      // 0..1
      float anti = (sync01 - 0.55) * 2.0;   // <0 below ~0.55, >0 above
      signal = mix(signal, anti, clamp(u_inhibAntiSync, 0.0, 2.0) / 2.0);
    }

    vec2 uv_i = decodeUV(texelFetch(u_uvTex, ci, 0));
    vec2 uv_j = decodeUV(texelFetch(u_uvTex, cj, 0));

    // Metabolic cost based on physical distance between nodes
    vec2 dUV = abs(uv_i - uv_j);
    dUV = min(dUV, 1.0 - dUV);
    float spatialDist = length(dUV);
    float metabolicCost = u_decay * (1.0 + spatialDist * 6.0);

    float lrEff = u_lr;
    if(u_nmOn > 0.5){
      vec3 nm = texture(u_neuromod, uv_i).rgb;
      lrEff = u_lr * (1.0 + u_nmGainLR * nm.r * 6.0);
    }

    // Local ATP slows plasticity (structural learning is expensive)
    float atp = texture(u_meta, uv_i).r;
    lrEff *= mix(0.15, 1.0, atp);

    float nodeAvgW = readWeight(texelFetch(u_nodeWeights, ci, 0));
    float normPenalty = u_normRate * (u_wRest - nodeAvgW);

    float dw = lrEff * signal - metabolicCost * (w - u_wRest) + normPenalty;
    w += dw;
    w = clamp(w, u_wMin, u_wMax);

    uint finalNb = nbU;

    // --- NEUROTROPHIC SPROUTING (BDNF proxy via dopamine) ---
    if(u_rewireOn > 0.5 && w <= u_wMin + 0.005){
      float rnd = hashNoise(float(i)*1.3 + float(j)*7.1, u_tick);

      if(rnd > 0.995){
        float rndNode = hashNoise(float(i)*3.1, u_tick + rnd);
        uint testNb = uint(rndNode * float(u_nodeCount));

        ivec2 testCoord = ivec2(int(testNb) - (int(testNb) / u_texW) * u_texW, int(testNb) / u_texW);
        vec2 testUV = decodeUV(texelFetch(u_uvTex, testCoord, 0));

        float growthFactor = texture(u_neuromod, testUV).r;

        if(growthFactor > 0.15 || u_nmOn < 0.5) {
            finalNb = testNb;
            w = u_wMin + 0.25;
        }
      }
    }

    outColor = packWeight(w);
    outNei = uvec4(finalNb & 255u, (finalNb >> 8u) & 255u, (finalNb >> 16u) & 255u, (finalNb >> 24u) & 255u);
  }`;


  // ===== Short-term plasticity (STP) update shader (Tsodyks‑Markram style) =====
  const STP_FS = `#version 300 es
  precision highp float; precision highp usampler2D;
  in vec2 v_uv; 
  layout(location = 0) out vec4 outColor;
  layout(location = 1) out uvec4 outNei;

  uniform sampler2D u_thetaCurr;
  uniform sampler2D u_stp;
  uniform usampler2D u_nei;
  uniform int u_nodeCount, u_texW, u_degK;
  uniform float u_dt, u_U, u_tauD, u_tauF, u_actGain;
  uniform float u_vmax;

  const float TAU = 6.28318530718;
  const uint SENT = 4294967295u;

  float theta01_from_rg(vec4 px){ float r=px.r*255.0; float g=px.g*255.0; return (r+256.0*g)/65535.0; }
  float vel_from_ba(vec4 px){ float b=px.b*255.0; float a=px.a*255.0; return (b+256.0*a)/65535.0; }

  vec2 readUX(vec4 px){
    float r=px.r*255.0; float g=px.g*255.0; float b=px.b*255.0; float a=px.a*255.0;
    float u=(r+256.0*g)/65535.0;
    float x=(b+256.0*a)/65535.0;
    return vec2(u,x);
  }
  vec4 packUX(vec2 ux){
    float u = clamp(ux.x, 0.0, 1.0);
    float x = clamp(ux.y, 0.0, 1.0);
    float uu = u * 65535.0;
    float xu = x * 65535.0;
    float ulo=floor(mod(uu,256.0)); float uhi=floor(uu/256.0);
    float xlo=floor(mod(xu,256.0)); float xhi=floor(xu/256.0);
    return vec4(ulo/255.0, uhi/255.0, xlo/255.0, xhi/255.0);
  }

  void main(){
    ivec2 p = ivec2(gl_FragCoord.xy);
    int pixelX = p.x;
    int pixelY = p.y;
    int j = pixelX / u_texW;
    int baseX = pixelX - j * u_texW;
    int i = baseX + pixelY * u_texW;

    if(i >= u_nodeCount || j >= u_degK){
      outColor = texelFetch(u_stp, p, 0);
      return;
    }

    // neighbor index
    uvec4 nv = texelFetch(u_nei, p, 0);
    uint nbU = nv.r + (nv.g<<8u) + (nv.b<<16u) + (nv.a<<24u);
    if(nbU == SENT){
      outColor = texelFetch(u_stp, p, 0);
      return;
    }

    // phases (activity proxy from phase locking)
    ivec2 ci = ivec2(baseX, pixelY);
    float th_i = theta01_from_rg(texelFetch(u_thetaCurr, ci, 0)) * TAU;

    int nb = int(nbU);
    ivec2 cj = ivec2(nb - (nb / u_texW) * u_texW, nb / u_texW);
    float th_j = theta01_from_rg(texelFetch(u_thetaCurr, cj, 0)) * TAU;

    float lock = 0.5 + 0.5 * cos(th_j - th_i);   // 0..1
    float a = clamp(lock * u_actGain, 0.0, 6.0); // "spike rate" proxy

    vec2 ux = readUX(texelFetch(u_stp, p, 0));
    float u = ux.x;
    float x = ux.y;

    float U = clamp(u_U, 0.0001, 0.999);

    // Continuous-time TM dynamics driven by activity proxy a
    float du = (U - u) / max(u_tauF, 0.0001) + a * (1.0 - u);
    float dx = (1.0 - x) / max(u_tauD, 0.0001) - (u * x) * a;

    u += u_dt * du;
    x += u_dt * dx;

    outColor = packUX(vec2(u, x));
  }`;
  const HOMEO_FS = `#version 300 es
  precision highp float;
  in vec2 v_uv; out vec4 outColor;
  uniform sampler2D u_thetaCurr;
  uniform sampler2D u_homeo;
  uniform sampler2D u_uvTex;
  uniform sampler2D u_neuromod;
  uniform int u_nodeCount, u_texW;
  uniform float u_dt, u_target, u_rate, u_vmax, u_on, u_metaOn, u_nmOn;

  vec2 read16(vec4 px){
    float r=px.r*255.0; float g=px.g*255.0; float b=px.b*255.0; float a=px.a*255.0;
    return vec2((r+256.0*g)/65535.0, (b+256.0*a)/65535.0);
  }
  vec4 write16(vec2 v){
    v = clamp(v, 0.0, 1.0);
    float x = v.x * 65535.0; float xlo = floor(mod(x, 256.0)); float xhi = floor(x / 256.0);
    float y = v.y * 65535.0; float ylo = floor(mod(y, 256.0)); float yhi = floor(y / 256.0);
    return vec4(xlo/255.0, xhi/255.0, ylo/255.0, yhi/255.0);
  }
  float vel_from_ba(vec4 px){ float b=px.b*255.0; float a=px.a*255.0; return (b+256.0*a)/65535.0; }
  vec2 decodeUV(vec4 p){
    float r=p.r*255.0, g=p.g*255.0, b=p.b*255.0, a=p.a*255.0;
    return vec2((r+256.0*g)/65535.0, (b+256.0*a)/65535.0);
  }

  void main(){
    ivec2 p = ivec2(gl_FragCoord.xy);
    int i = p.x + p.y * u_texW;
    if(i >= u_nodeCount){ outColor = texelFetch(u_homeo, p, 0); return; }

    vec2 HA = read16(texelFetch(u_homeo, p, 0));
    float H = max(0.01, HA.x * 4.0); // excitability in [0,4]
    float A = HA.y;                  // slow activity trace in [0,1]

    if(u_on < 0.5){
      outColor = write16(vec2(1.0/4.0, A)); // Reset H to 1.0 but preserve A
      return;
    }

    vec4 px = texelFetch(u_thetaCurr, p, 0);
    float vel01 = vel_from_ba(px);
    float act = abs(vel01 * 2.0 - 1.0); // instantaneous activity proxy 0..1

    // BCM-like sliding threshold: when metaOn is enabled, make A a *slower* moving average
    float aRate = (u_metaOn > 0.5) ? 0.35 : 1.5;
    A = mix(A, act, u_dt * aRate);

    // Genetic heterogeneity: slightly different baseline targets per node
    float personalityOffset = (fract(sin(float(i) * 12.9898) * 43758.5453) - 0.5) * 0.20;
    float currentTarget = u_target + personalityOffset;

    // BCM rule: slide the target toward the node's own long-term average (A)
    if(u_metaOn > 0.5){
      currentTarget = mix(currentTarget, A, 0.75);
    }

    // Chemical bath shifts the target as well (glutamate tolerates wake; GABA forces sleep)
    if (u_metaOn > 0.5 && u_nmOn > 0.5) {
      vec2 nodeUV = decodeUV(texelFetch(u_uvTex, p, 0));
      vec3 nm = texture(u_neuromod, nodeUV).rgb;
      currentTarget += (nm.g * 0.4) - (nm.b * 0.6);
    }

    currentTarget = clamp(currentTarget, 0.05, 0.95);

    // Homeostatic excitability update uses instantaneous activity vs sliding target
    float dH = u_rate * (currentTarget - act) * H;
    H = clamp(H + u_dt * dH, 0.05, 4.0);

    outColor = write16(vec2(H / 4.0, A));
  }`;

  // ===== Per-node average weight reduction shader =====
  const NODE_WEIGHT_FS = `#version 300 es
  precision highp float;
  in vec2 v_uv; 
  layout(location = 0) out vec4 outColor;
  layout(location = 1) out uvec4 outNei;

  uniform sampler2D u_weights;
  uniform int u_nodeCount, u_texW, u_degK;

  float readWeight(ivec2 p){ vec4 px=texelFetch(u_weights,p,0); float r=px.r*255.0; float g=px.g*255.0; return (r+256.0*g)/65535.0*2.0; }
  vec4 packWeight(float w){
    w=clamp(w/2.0,0.0,1.0);
    float u=w*65535.0; float lo=floor(mod(u,256.0)); float hi=floor(u/256.0);
    return vec4(lo/255.0,hi/255.0,0.0,1.0);
  }

  void main(){
    ivec2 p = ivec2(gl_FragCoord.xy);
    int i = p.x + p.y * u_texW;
    if(i >= u_nodeCount){ outColor = packWeight(1.0); return; }

    float sum = 0.0, cnt = 0.0;
    for(int j = 0; j < 64; j++){
      if(j >= u_degK) break;
      int wx = p.x + j * u_texW;
      float w = readWeight(ivec2(wx, p.y));
      if(w > 0.001){ sum += w; cnt += 1.0; }
    }
    float avg = (cnt > 0.0) ? sum / cnt : 1.0;
    outColor = packWeight(avg);
  }`;

  let graphProg, fieldProg, defectProg, phiProg, neuromodProg, metaProg, meanProg, decayProg, drawProg, edgeProg, splatProg, uvProg;
  let weightProg, stpProg, nodeWeightProg, homeoProg;
  try {
    homeoProg = link(compile(gl.VERTEX_SHADER, FULL_VS), compile(gl.FRAGMENT_SHADER, HOMEO_FS));
    graphProg = link(compile(gl.VERTEX_SHADER, FULL_VS), compile(gl.FRAGMENT_SHADER, GRAPH_FS));
    fieldProg = link(compile(gl.VERTEX_SHADER, FULL_VS), compile(gl.FRAGMENT_SHADER, FIELD_FS));
    defectProg = link(compile(gl.VERTEX_SHADER, FULL_VS), compile(gl.FRAGMENT_SHADER, DEFECT_FS));
    phiProg = link(compile(gl.VERTEX_SHADER, FULL_VS), compile(gl.FRAGMENT_SHADER, PHI_FS));
    neuromodProg = link(compile(gl.VERTEX_SHADER, FULL_VS), compile(gl.FRAGMENT_SHADER, NEUROMOD_FS));
    metaProg = link(compile(gl.VERTEX_SHADER, FULL_VS), compile(gl.FRAGMENT_SHADER, META_FS));
    meanProg = link(compile(gl.VERTEX_SHADER, FULL_VS), compile(gl.FRAGMENT_SHADER, MEAN_FS));
    uvProg = link(compile(gl.VERTEX_SHADER, FULL_VS), compile(gl.FRAGMENT_SHADER, UV_FS));
    decayProg = link(compile(gl.VERTEX_SHADER, FULL_VS), compile(gl.FRAGMENT_SHADER, DECAY_FS));
    drawProg  = link(compile(gl.VERTEX_SHADER, FULL_VS), compile(gl.FRAGMENT_SHADER, DRAW_FS));
    edgeProg  = link(compile(gl.VERTEX_SHADER, EDGE_VS),  compile(gl.FRAGMENT_SHADER, EDGE_FS));
    splatProg = link(compile(gl.VERTEX_SHADER, SPLAT_VS), compile(gl.FRAGMENT_SHADER, SPLAT_FS));
    weightProg = link(compile(gl.VERTEX_SHADER, FULL_VS), compile(gl.FRAGMENT_SHADER, WEIGHT_FS));
    stpProg = link(compile(gl.VERTEX_SHADER, FULL_VS), compile(gl.FRAGMENT_SHADER, STP_FS));
    nodeWeightProg = link(compile(gl.VERTEX_SHADER, FULL_VS), compile(gl.FRAGMENT_SHADER, NODE_WEIGHT_FS));
  } catch(e) { setStatus("Shader compile/link failed:\n" + (e.message||e)); return; }

  // Uniforms
  const GU = {
    thetaCurr: gl.getUniformLocation(graphProg,"u_thetaCurr"),
    thetaDelay: gl.getUniformLocation(graphProg,"u_thetaDelay"),
    omega: gl.getUniformLocation(graphProg,"u_omega"),
    nei: gl.getUniformLocation(graphProg,"u_nei"),
    nodeCount: gl.getUniformLocation(graphProg,"u_nodeCount"),
    texW: gl.getUniformLocation(graphProg,"u_texW"),
    degK: gl.getUniformLocation(graphProg,"u_degK"),
    dt: gl.getUniformLocation(graphProg,"u_dt"),
    K1: gl.getUniformLocation(graphProg,"u_K1"),
    a1: gl.getUniformLocation(graphProg,"u_a1"),
    K2: gl.getUniformLocation(graphProg,"u_K2"),
    a2: gl.getUniformLocation(graphProg,"u_a2"),
    omegaSpread: gl.getUniformLocation(graphProg,"u_omegaSpread"),
    delayMix: gl.getUniformLocation(graphProg,"u_delayMix"),
    Kg: gl.getUniformLocation(graphProg,"u_Kg"),
    ag: gl.getUniformLocation(graphProg,"u_ag"),
    Rg: gl.getUniformLocation(graphProg,"u_Rg"),
    psig: gl.getUniformLocation(graphProg,"u_psig"),
    noiseAmp: gl.getUniformLocation(graphProg,"u_noiseAmp"),
    tick: gl.getUniformLocation(graphProg,"u_tick"),
    uvTex: gl.getUniformLocation(graphProg,"u_uvTex"),
    fieldTheta: gl.getUniformLocation(graphProg,"u_fieldTheta"),
    neuromod: gl.getUniformLocation(graphProg,"u_neuromod"),
    meta: gl.getUniformLocation(graphProg,"u_meta"),
    nmOn: gl.getUniformLocation(graphProg,"u_nmOn"),
    nmGainK: gl.getUniformLocation(graphProg,"u_nmGainK"),
    Kfg: gl.getUniformLocation(graphProg,"u_Kfg"),
    afg: gl.getUniformLocation(graphProg,"u_afg"),
    fgOn: gl.getUniformLocation(graphProg,"u_fgOn"),
    infl: gl.getUniformLocation(graphProg,"u_infl"),
    defTex: gl.getUniformLocation(graphProg,"u_def"),
    gateOn: gl.getUniformLocation(graphProg,"u_gateOn"),
    gateLo: gl.getUniformLocation(graphProg,"u_gateLo"),
    gateHi: gl.getUniformLocation(graphProg,"u_gateHi"),
    gateBoost: gl.getUniformLocation(graphProg,"u_gateBoost"),
    gaugeGamma: gl.getUniformLocation(graphProg,"u_gaugeGamma"),
    wind: gl.getUniformLocation(graphProg,"u_wind"),
    inertialOn: gl.getUniformLocation(graphProg,"u_inertialOn"),
    eta: gl.getUniformLocation(graphProg,"u_eta"),
    vmax: gl.getUniformLocation(graphProg,"u_vmax"),
    inflTexel: gl.getUniformLocation(graphProg,"u_inflTexel"),
    topoOn: gl.getUniformLocation(graphProg,"u_topoOn"),
    fluxBoost: gl.getUniformLocation(graphProg,"u_fluxBoost"),
    defOn: gl.getUniformLocation(graphProg,"u_defOn"),
    defBoost: gl.getUniformLocation(graphProg,"u_defBoost"),
    weights: gl.getUniformLocation(graphProg,"u_weights"),
    stp: gl.getUniformLocation(graphProg,"u_stp"),
    stpOn: gl.getUniformLocation(graphProg,"u_stpOn"),
    stpU: gl.getUniformLocation(graphProg,"u_stpU"),
    stpMax: gl.getUniformLocation(graphProg,"u_stpMax"),
    homeo: gl.getUniformLocation(graphProg,"u_homeo"),
    homeoOn: gl.getUniformLocation(graphProg,"u_homeoOn"),
    phiTex: gl.getUniformLocation(graphProg,"u_phiTex"),
    cemiCoupling: gl.getUniformLocation(graphProg,"u_cemiCoupling"),
    axonDist: gl.getUniformLocation(graphProg,"u_axonDist"),
    axonOn: gl.getUniformLocation(graphProg,"u_axonOn"),
    axonSpeed: gl.getUniformLocation(graphProg,"u_axonSpeed"),
    thetaMid: gl.getUniformLocation(graphProg,"u_thetaMid"),
    lobes: gl.getUniformLocation(graphProg,"u_lobes"),
    retina: gl.getUniformLocation(graphProg,"u_retina"),
    retinaOn: gl.getUniformLocation(graphProg,"u_retinaOn"),
    retinaGain: gl.getUniformLocation(graphProg,"u_retinaGain"),
    retinaBounds: gl.getUniformLocation(graphProg,"u_retinaBounds"),
  };
  const HPU = {
    thetaCurr: gl.getUniformLocation(homeoProg, "u_thetaCurr"),
    homeo: gl.getUniformLocation(homeoProg, "u_homeo"),
    uvTex: gl.getUniformLocation(homeoProg, "u_uvTex"),
    neuromod: gl.getUniformLocation(homeoProg, "u_neuromod"),
    nodeCount: gl.getUniformLocation(homeoProg, "u_nodeCount"),
    texW: gl.getUniformLocation(homeoProg, "u_texW"),
    dt: gl.getUniformLocation(homeoProg, "u_dt"),
    target: gl.getUniformLocation(homeoProg, "u_target"),
    rate: gl.getUniformLocation(homeoProg, "u_rate"),
    vmax: gl.getUniformLocation(homeoProg, "u_vmax"),
    on: gl.getUniformLocation(homeoProg, "u_on"),
    metaOn: gl.getUniformLocation(homeoProg, "u_metaOn"),
    nmOn: gl.getUniformLocation(homeoProg, "u_nmOn")
  };
  const FU = {
    thetaCurr: gl.getUniformLocation(fieldProg,"u_thetaCurr"),
    thetaDelay: gl.getUniformLocation(fieldProg,"u_thetaDelay"),
    omega: gl.getUniformLocation(fieldProg,"u_omega"),
    infl: gl.getUniformLocation(fieldProg,"u_infl"),
    defTex: gl.getUniformLocation(fieldProg,"u_def"),
    phiTex: gl.getUniformLocation(fieldProg,"u_phi"),
    meta: gl.getUniformLocation(fieldProg,"u_meta"),
    phiWarp: gl.getUniformLocation(fieldProg,"u_phiWarp"),
    dt: gl.getUniformLocation(fieldProg,"u_dt"),
    Ke: gl.getUniformLocation(fieldProg,"u_Ke"),
    Ki: gl.getUniformLocation(fieldProg,"u_Ki"),
    a1: gl.getUniformLocation(fieldProg,"u_a1"),
    K2: gl.getUniformLocation(fieldProg,"u_K2"),
    a2: gl.getUniformLocation(fieldProg,"u_a2"),
    omegaSpread: gl.getUniformLocation(fieldProg,"u_omegaSpread"),
    gfOn: gl.getUniformLocation(fieldProg,"u_gfOn"),
    Kgf: gl.getUniformLocation(fieldProg,"u_Kgf"),
    agf: gl.getUniformLocation(fieldProg,"u_agf"),
    texel: gl.getUniformLocation(fieldProg,"u_texel"),
    inflTexel: gl.getUniformLocation(fieldProg,"u_inflTexel"),
    topoOn: gl.getUniformLocation(fieldProg,"u_topoOn"),
    Kflux: gl.getUniformLocation(fieldProg,"u_Kflux"),
    defOn: gl.getUniformLocation(fieldProg,"u_defOn"),
    Kdef: gl.getUniformLocation(fieldProg,"u_Kdef"),
  };

  const PPU = {
    phi: gl.getUniformLocation(phiProg, "u_phi"),
    defTex: gl.getUniformLocation(phiProg, "u_def"),
    infl: gl.getUniformLocation(phiProg, "u_infl"),
    meta: gl.getUniformLocation(phiProg, "u_meta"),
    neuromod: gl.getUniformLocation(phiProg, "u_neuromod"),
    texel: gl.getUniformLocation(phiProg, "u_texel"),
    dt: gl.getUniformLocation(phiProg, "u_dt"),
    waveSpeed: gl.getUniformLocation(phiProg, "u_waveSpeed"),
    waveDamping: gl.getUniformLocation(phiProg, "u_waveDamping"),
    cemiEmit: gl.getUniformLocation(phiProg, "u_cemiEmit"),
    phiInject: gl.getUniformLocation(phiProg, "u_phiInject"),
    phiGlobalOn: gl.getUniformLocation(phiProg, "u_phiGlobalOn"),
    phiTargetMean: gl.getUniformLocation(phiProg, "u_phiTargetMean"),
    phiMean: gl.getUniformLocation(phiProg, "u_phiMean"),
    phiGlobalRate: gl.getUniformLocation(phiProg, "u_phiGlobalRate"),
    defOn: gl.getUniformLocation(phiProg, "u_defOn"),
  };

  const QPU = {
    theta: gl.getUniformLocation(defectProg,"u_theta"),
    texel: gl.getUniformLocation(defectProg,"u_texel"),
  };
  const MPU = {
    tex: gl.getUniformLocation(meanProg, "u_tex"),
    lod: gl.getUniformLocation(meanProg, "u_lod"),
  };

  const DPU = {
    inTex:   gl.getUniformLocation(decayProg,"u_in"),
    defTex:  gl.getUniformLocation(decayProg,"u_def"),
    decay:   gl.getUniformLocation(decayProg,"u_decay"),
    dt:      gl.getUniformLocation(decayProg,"u_dt"),
    diff:    gl.getUniformLocation(decayProg,"u_diff"),
    advect:  gl.getUniformLocation(decayProg,"u_advect"),
    swirl:   gl.getUniformLocation(decayProg,"u_swirl"),
    sharpen: gl.getUniformLocation(decayProg,"u_sharpen"),
    topoOn: gl.getUniformLocation(decayProg,"u_topoOn"),
    fluxSwirl: gl.getUniformLocation(decayProg,"u_fluxSwirl"),
    defOn:     gl.getUniformLocation(decayProg,"u_defOn"),
    defSwirl:  gl.getUniformLocation(decayProg,"u_defSwirl"),
    defInject: gl.getUniformLocation(decayProg,"u_defInject"),
  };

  const NMU = {
    prev: gl.getUniformLocation(neuromodProg,"u_prev"),
    infl: gl.getUniformLocation(neuromodProg,"u_infl"),
    texel: gl.getUniformLocation(neuromodProg,"u_texel"),
    dt: gl.getUniformLocation(neuromodProg,"u_dt"),
    tau: gl.getUniformLocation(neuromodProg,"u_tau"),
    D: gl.getUniformLocation(neuromodProg,"u_D"),
    drive: gl.getUniformLocation(neuromodProg,"u_drive"),
    base: gl.getUniformLocation(neuromodProg,"u_base"),
    meta: gl.getUniformLocation(neuromodProg,"u_meta"),
    gliaOn: gl.getUniformLocation(neuromodProg,"u_gliaOn"),
    gliaMop: gl.getUniformLocation(neuromodProg,"u_gliaMop"),
  };

  const MTU = {
    prev: gl.getUniformLocation(metaProg,"u_prev"),
    infl: gl.getUniformLocation(metaProg,"u_infl"),
    neuromod: gl.getUniformLocation(metaProg,"u_neuromod"),
    texel: gl.getUniformLocation(metaProg,"u_texel"),
    dt: gl.getUniformLocation(metaProg,"u_dt"),
    regen: gl.getUniformLocation(metaProg,"u_regen"),
    cost: gl.getUniformLocation(metaProg,"u_cost"),
    diff: gl.getUniformLocation(metaProg,"u_diff"),
    gliaOn: gl.getUniformLocation(metaProg,"u_gliaOn"),
    gliaTau: gl.getUniformLocation(metaProg,"u_gliaTau"),
    gliaYield: gl.getUniformLocation(metaProg,"u_gliaYield"),
    gliaDrive: gl.getUniformLocation(metaProg,"u_gliaDrive"),
    gliaDiff: gl.getUniformLocation(metaProg,"u_gliaDiff"),
  };

  const DU = {
    theta: gl.getUniformLocation(drawProg,"u_theta"),
    alpha: gl.getUniformLocation(drawProg,"u_alpha"),
    time: gl.getUniformLocation(drawProg,"u_time"),
    palOn: gl.getUniformLocation(drawProg,"u_palOn"),
    palSpeed: gl.getUniformLocation(drawProg,"u_palSpeed"),
    colorMode: gl.getUniformLocation(drawProg,"u_colorMode"),
    phi: gl.getUniformLocation(drawProg,"u_phi"),
    neuromod: gl.getUniformLocation(drawProg,"u_neuromod"),
  };
  const UVU = {
    uvCurr: gl.getUniformLocation(uvProg,"u_uvCurr"),
    infl: gl.getUniformLocation(uvProg,"u_infl"),
    nodeCount: gl.getUniformLocation(uvProg,"u_nodeCount"),
    texW: gl.getUniformLocation(uvProg,"u_texW"),
    dt: gl.getUniformLocation(uvProg,"u_dt"),
    motility: gl.getUniformLocation(uvProg,"u_motility"),
    tick: gl.getUniformLocation(uvProg,"u_tick"),
    inflTexel: gl.getUniformLocation(uvProg,"u_inflTexel")
  };

  const EU = {
    center: gl.getUniformLocation(edgeProg,"u_center"),
    scale:  gl.getUniformLocation(edgeProg,"u_scale"),
    aspect: gl.getUniformLocation(edgeProg,"u_aspect"),
    theta: gl.getUniformLocation(edgeProg,"u_theta"),
    texW: gl.getUniformLocation(edgeProg,"u_texW"),
    alpha: gl.getUniformLocation(edgeProg,"u_alpha"),
    palSpd: gl.getUniformLocation(edgeProg,"u_palSpeed"),
    time: gl.getUniformLocation(edgeProg,"u_time"),
    palOn: gl.getUniformLocation(edgeProg,"u_palOn"),
    fieldTheta: gl.getUniformLocation(edgeProg,"u_fieldTheta"),
    uvScale: gl.getUniformLocation(edgeProg,"u_uvScale"),
    useField: gl.getUniformLocation(edgeProg,"u_useField"),
    nodeWeight: gl.getUniformLocation(edgeProg,"u_nodeWeight"),
    hebbGlow: gl.getUniformLocation(edgeProg,"u_hebbGlow"),
    uvTex: gl.getUniformLocation(edgeProg,"u_uvTex"),
    omega: gl.getUniformLocation(edgeProg,"u_omega"),
    colorMode: gl.getUniformLocation(edgeProg,"u_colorMode"),
    phi: gl.getUniformLocation(edgeProg,"u_phi"),
    neuromod: gl.getUniformLocation(edgeProg,"u_neuromod"),
  };
  const SU = {
    theta: gl.getUniformLocation(splatProg,"u_theta"),
    gTexW: gl.getUniformLocation(splatProg,"u_gTexW"),
    uvTex: gl.getUniformLocation(splatProg,"u_uvTex"),
    pointSize: gl.getUniformLocation(splatProg,"u_pointSize"),
    gain: gl.getUniformLocation(splatProg,"u_gain"),
    fieldTheta: gl.getUniformLocation(splatProg,"u_fieldTheta"),
    meta: gl.getUniformLocation(splatProg,"u_meta"),
    aiOn: gl.getUniformLocation(splatProg,"u_aiOn"),
    aiThresh: gl.getUniformLocation(splatProg,"u_aiThresh"),
    pacOn: gl.getUniformLocation(splatProg,"u_pacOn"),
    pacThresh: gl.getUniformLocation(splatProg,"u_pacThresh"),
  };

  const WPU = {
    thetaCurr: gl.getUniformLocation(weightProg,"u_thetaCurr"),
    uvTex: gl.getUniformLocation(weightProg,"u_uvTex"),
    neuromod: gl.getUniformLocation(weightProg,"u_neuromod"),
    omega: gl.getUniformLocation(weightProg,"u_omega"),
    meta: gl.getUniformLocation(weightProg,"u_meta"),
    inhibAntiSync: gl.getUniformLocation(weightProg,"u_inhibAntiSync"),
    nmOn: gl.getUniformLocation(weightProg,"u_nmOn"),
    nmGainLR: gl.getUniformLocation(weightProg,"u_nmGainLR"),
    weights: gl.getUniformLocation(weightProg,"u_weights"),
    nodeWeights: gl.getUniformLocation(weightProg,"u_nodeWeights"),
    nei: gl.getUniformLocation(weightProg,"u_nei"),
    nodeCount: gl.getUniformLocation(weightProg,"u_nodeCount"),
    texW: gl.getUniformLocation(weightProg,"u_texW"),
    degK: gl.getUniformLocation(weightProg,"u_degK"),
    lr: gl.getUniformLocation(weightProg,"u_lr"),
    decay: gl.getUniformLocation(weightProg,"u_decay"),
    wRest: gl.getUniformLocation(weightProg,"u_wRest"),
    wMin: gl.getUniformLocation(weightProg,"u_wMin"),
    wMax: gl.getUniformLocation(weightProg,"u_wMax"),
    normRate: gl.getUniformLocation(weightProg,"u_normRate"),
    stdpMix: gl.getUniformLocation(weightProg,"u_stdpMix"),
    vmax: gl.getUniformLocation(weightProg,"u_vmax"),
    rewireOn: gl.getUniformLocation(weightProg,"u_rewireOn"),
    tick: gl.getUniformLocation(weightProg,"u_tick"),
  };

  const STPU = {
    thetaCurr: gl.getUniformLocation(stpProg,"u_thetaCurr"),
    stp: gl.getUniformLocation(stpProg,"u_stp"),
    nei: gl.getUniformLocation(stpProg,"u_nei"),
    nodeCount: gl.getUniformLocation(stpProg,"u_nodeCount"),
    texW: gl.getUniformLocation(stpProg,"u_texW"),
    degK: gl.getUniformLocation(stpProg,"u_degK"),
    dt: gl.getUniformLocation(stpProg,"u_dt"),
    U: gl.getUniformLocation(stpProg,"u_U"),
    tauD: gl.getUniformLocation(stpProg,"u_tauD"),
    tauF: gl.getUniformLocation(stpProg,"u_tauF"),
    actGain: gl.getUniformLocation(stpProg,"u_actGain"),
    vmax: gl.getUniformLocation(stpProg,"u_vmax"),
  };



  const NWU = {
    weights: gl.getUniformLocation(nodeWeightProg,"u_weights"),
    nodeCount: gl.getUniformLocation(nodeWeightProg,"u_nodeCount"),
    texW: gl.getUniformLocation(nodeWeightProg,"u_texW"),
    degK: gl.getUniformLocation(nodeWeightProg,"u_degK"),
  };

  // VAO for indexed edges (pos.xy + idx float)
  const edgeVAO = gl.createVertexArray();
  gl.bindVertexArray(edgeVAO);
  gl.bindBuffer(gl.ARRAY_BUFFER, nodeVBO);
  const locPos = gl.getAttribLocation(edgeProg,"a_pos");
  const locIdx = gl.getAttribLocation(edgeProg,"a_idx");
  gl.enableVertexAttribArray(locPos);
  gl.vertexAttribPointer(locPos, 2, gl.FLOAT, false, 12, 0);
  gl.enableVertexAttribArray(locIdx);
  gl.vertexAttribPointer(locIdx, 1, gl.FLOAT, false, 12, 8);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, edgeIBO);
  gl.bindVertexArray(null);

  gl.bindVertexArray(splatVAO);
  gl.bindBuffer(gl.ARRAY_BUFFER, splatVBO);
  const sLocUV = gl.getAttribLocation(splatProg,"a_uv");
  const sLocIdx = gl.getAttribLocation(splatProg,"a_idx");
  gl.enableVertexAttribArray(sLocUV);
  gl.vertexAttribPointer(sLocUV, 2, gl.FLOAT, false, 12, 0);
  gl.enableVertexAttribArray(sLocIdx);
  gl.vertexAttribPointer(sLocIdx, 1, gl.FLOAT, false, 12, 8);
  gl.bindVertexArray(null);

  function decayInfluence(){
    if(!inflA || !inflB) return;
    const decay = parseFloat(inflDecayEl.value);
    const src = currentInflTex();
    const dst = otherInflTex();

    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, dst, 0);
    gl.viewport(0,0,f_N,f_N);
    gl.disable(gl.BLEND);

    gl.useProgram(decayProg);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, src);
    gl.uniform1i(DPU.inTex, 0);
    gl.uniform1f(DPU.decay, decay);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, defTex);
    gl.uniform1i(DPU.defTex, 1);

    // Influence dynamics (complex splat memory/flow). Defaults chosen to be stable & lively.
    gl.uniform1f(DPU.dt, 1.0);
    gl.uniform1f(DPU.diff, 0.22);
    gl.uniform1f(DPU.advect, 1.15);
    gl.uniform1f(DPU.swirl, 2.10);
    gl.uniform1f(DPU.sharpen, 0.65);
    gl.uniform1f(DPU.topoOn, topoOnEl.checked ? 1.0 : 0.0);
    gl.uniform1f(DPU.fluxSwirl, parseFloat(fluxSwirlEl.value));
    gl.uniform1f(DPU.defOn, defectOnEl.checked ? 1.0 : 0.0);
    gl.uniform1f(DPU.defSwirl, parseFloat(defSwirlEl.value));
    gl.uniform1f(DPU.defInject, parseFloat(defInjectEl.value));

    gl.drawArrays(gl.TRIANGLES, 0, 3);

    if(gf_onEl.checked && nodeCount>0){
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE);

      gl.useProgram(splatProg);
      gl.bindVertexArray(splatVAO);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, currTheta(g_thetaRing, g_thetaIdx));
      gl.uniform1i(SU.theta, 0);
      
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, currentUvTex());
      gl.uniform1i(SU.uvTex, 1);
      
      gl.uniform1i(SU.gTexW, g_texW);
      gl.uniform1f(SU.pointSize, parseFloat(splatREl.value));
      gl.activeTexture(gl.TEXTURE2);
      gl.bindTexture(gl.TEXTURE_2D, currTheta(f_thetaRing, f_thetaIdx));
      gl.uniform1i(SU.fieldTheta, 2);

      gl.activeTexture(gl.TEXTURE3);
      gl.bindTexture(gl.TEXTURE_2D, currentMetaTex());
      gl.uniform1i(SU.meta, 3);

      gl.uniform1f(SU.aiOn, ai_onEl.checked ? 1.0 : 0.0);
      gl.uniform1f(SU.aiThresh, parseFloat(ai_threshEl.value));
      gl.uniform1f(SU.pacOn, pac_onEl.checked ? 1.0 : 0.0);
      gl.uniform1f(SU.pacThresh, parseFloat(pac_threshEl.value));

      gl.uniform1f(SU.gain, (parseFloat(splatGainEl.value) / 6.0) * parseFloat(globalGainEl.value));

      gl.drawArrays(gl.POINTS, 0, nodeCount);

      gl.bindVertexArray(null);
      gl.disable(gl.BLEND);
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0,0,canvas.width,canvas.height);
    inflFlip ^= 1;
  }

  function graphStep(){
    const outTex = nextTheta(g_thetaRing, g_thetaIdx);
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outTex, 0);
    gl.viewport(0,0,g_texW,g_texH);

    gl.useProgram(graphProg);

    const axonActive = axon_onEl && axon_onEl.checked;
    const delaySteps = (g_delayOnEl.checked || axonActive) ? Math.max(1, (parseInt(g_delayStepsEl.value,10)|0)) : 0;
    const fDelay = (f_delayOnEl.checked ? (parseInt(f_delayStepsEl.value,10)|0) : 0);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, currTheta(g_thetaRing, g_thetaIdx));
    gl.uniform1i(GU.thetaCurr, 0);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, delayedTheta(g_thetaRing, g_thetaIdx, delaySteps));
    gl.uniform1i(GU.thetaDelay, 1);

    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, g_omegaTex);
    gl.uniform1i(GU.omega, 2);

    gl.activeTexture(gl.TEXTURE3);
    gl.bindTexture(gl.TEXTURE_2D, currentNeiTex());
    gl.uniform1i(GU.nei, 3);

    gl.activeTexture(gl.TEXTURE4);
    gl.bindTexture(gl.TEXTURE_2D, delayedTheta(f_thetaRing, f_thetaIdx, fDelay));
    gl.uniform1i(GU.fieldTheta, 4);

    gl.activeTexture(gl.TEXTURE5);
    gl.bindTexture(gl.TEXTURE_2D, currentUvTex());
    gl.uniform1i(GU.uvTex, 5);

    gl.activeTexture(gl.TEXTURE6);
    gl.bindTexture(gl.TEXTURE_2D, currentInflTex());
    gl.uniform1i(GU.infl, 6);

    gl.activeTexture(gl.TEXTURE7);
    gl.bindTexture(gl.TEXTURE_2D, defTex);
    gl.uniform1i(GU.defTex, 7);

    gl.activeTexture(gl.TEXTURE0 + 10);
    gl.bindTexture(gl.TEXTURE_2D, currentNeuromodTex());
    gl.uniform1i(GU.neuromod, 10);

    gl.activeTexture(gl.TEXTURE0 + 15);
    gl.bindTexture(gl.TEXTURE_2D, currentMetaTex());
    gl.uniform1i(GU.meta, 15);

    gl.activeTexture(gl.TEXTURE0 + 8);
    gl.bindTexture(gl.TEXTURE_2D, currentWeightTex());
    gl.uniform1i(GU.weights, 8);

    gl.activeTexture(gl.TEXTURE0 + 9);
    gl.bindTexture(gl.TEXTURE_2D, currentSTPTex());
    gl.uniform1i(GU.stp, 9);

    gl.activeTexture(gl.TEXTURE0 + 11);
    gl.bindTexture(gl.TEXTURE_2D, currentHomeoTex());
    gl.uniform1i(GU.homeo, 11);

    gl.activeTexture(gl.TEXTURE0 + 12);
    gl.bindTexture(gl.TEXTURE_2D, currentPhiTex());
    gl.uniform1i(GU.phiTex, 12);

    // Mid-delay theta removed to free a texture unit for the Retina on mobile GPUs.
    // The shader now approximates mid-delay by blending current/delayed phases.

    // Per-edge axonal distance texture (keep within MAX_TEX_UNITS)
    const AXON_UNIT = 14;
    if(AXON_UNIT < MAX_TEX_UNITS){
      gl.activeTexture(gl.TEXTURE0 + AXON_UNIT);
      gl.bindTexture(gl.TEXTURE_2D, g_axonDistTex);
      gl.uniform1i(GU.axonDist, AXON_UNIT);
    }

    // Retina visual cortex injection buffer (keep within MAX_TEX_UNITS)
    const RETINA_UNIT = 13;
    if(RETINA_UNIT < MAX_TEX_UNITS){
      gl.activeTexture(gl.TEXTURE0 + RETINA_UNIT);
      gl.bindTexture(gl.TEXTURE_2D, window.retinaTex || null);
      if(GU.retina) gl.uniform1i(GU.retina, RETINA_UNIT);
    }

    gl.uniform1i(GU.nodeCount, nodeCount);
    gl.uniform1i(GU.texW, g_texW);
    gl.uniform1i(GU.degK, degK);

    const G = parseFloat(globalGainEl.value);
    gl.uniform1f(GU.nmOn, nm_onEl && nm_onEl.checked ? 1.0 : 0.0);
    gl.uniform1f(GU.nmGainK, parseFloat(nm_gainKEl.value));
    gl.uniform1f(GU.dt, parseFloat(g_dtEl.value));
    gl.uniform1f(GU.K1, parseFloat(g_K1El.value) * G);
    gl.uniform1f(GU.a1, parseFloat(g_a1El.value));
    gl.uniform1f(GU.K2, parseFloat(g_K2El.value) * G);
    gl.uniform1f(GU.a2, parseFloat(g_a2El.value));
    gl.uniform1f(GU.gaugeGamma, parseFloat(g_gaugeEl.value));
    gl.uniform1f(GU.wind, parseFloat(g_windEl.value));
    gl.uniform1f(GU.inertialOn, g_inertialOnEl && g_inertialOnEl.checked ? 1.0 : 0.0);
    gl.uniform1f(GU.eta, parseFloat(g_etaEl.value));
    gl.uniform1f(GU.vmax, parseFloat(g_vmaxEl.value));
    gl.uniform2f(GU.inflTexel, 1.0/f_N, 1.0/f_N);
    gl.uniform1f(GU.topoOn, topoOnEl.checked ? 1.0 : 0.0);
    gl.uniform1f(GU.fluxBoost, parseFloat(fluxBoostEl.value));
    gl.uniform1f(GU.defOn, defectOnEl.checked ? 1.0 : 0.0);
    gl.uniform1f(GU.defBoost, parseFloat(defBoostEl.value));
    gl.uniform1f(GU.stpOn, stp_onEl.checked ? 1.0 : 0.0);
    gl.uniform1f(GU.stpU, parseFloat(stp_UEl.value));
    gl.uniform1f(GU.stpMax, parseFloat(stp_maxEl.value));
    gl.uniform1f(GU.omegaSpread, parseFloat(g_omegaEl.value));
    const homeo_onEl = document.getElementById('homeo_on');
    gl.uniform1f(GU.homeoOn, (homeo_onEl && homeo_onEl.checked) ? 1.0 : 0.0);

    gl.uniform1f(GU.delayMix, parseFloat(g_delayMixEl.value));
    gl.uniform1f(GU.Kg, parseFloat(g_KgEl.value) * G);
    gl.uniform1f(GU.ag, parseFloat(g_agEl.value));
    gl.uniform1f(GU.Rg, gGlobR);
    gl.uniform1f(GU.psig, gGlobPsi);
    gl.uniform1f(GU.noiseAmp, parseFloat(g_noiseEl.value));
    gl.uniform1f(GU.tick, simTick);

    gl.uniform1f(GU.Kfg, parseFloat(KfgEl.value) * G);
    gl.uniform1f(GU.afg, parseFloat(afgEl.value));
    gl.uniform1f(GU.fgOn, fg_onEl.checked ? 1.0 : 0.0);

    gl.uniform1f(GU.gateOn, gate_onEl.checked ? 1.0 : 0.0);
    gl.uniform1f(GU.gateLo, parseFloat(gate_loEl.value));
    gl.uniform1f(GU.gateHi, parseFloat(gate_hiEl.value));
    gl.uniform1f(GU.gateBoost, parseFloat(gate_boostEl.value));

    const cemi_coupleEl = document.getElementById('cemi_couple');
    gl.uniform1f(GU.cemiCoupling, cemi_coupleEl ? parseFloat(cemi_coupleEl.value) : 1.2);

    gl.uniform1f(GU.axonOn, (axon_onEl && axon_onEl.checked) ? 1.0 : 0.0);
    gl.uniform1f(GU.axonSpeed, parseFloat(axon_speedEl.value));

    if(GU.lobes) gl.uniform1i(GU.lobes, parseInt(document.getElementById('lobes')?.value || 1, 10));
    
    // Retina is active only if explicitly checked
    const isRetinaActive = (retina_camEl && retina_camEl.checked) || (retina_imgEl && retina_imgEl.checked && window.staticRetinaImg);
    if(GU.retinaOn) gl.uniform1f(GU.retinaOn, isRetinaActive ? 1.0 : 0.0);
    if(GU.retinaGain) gl.uniform1f(GU.retinaGain, retina_gainEl ? parseFloat(retina_gainEl.value) : 15.0);
    const rb = window.lobe0UV || {x:0, y:0, w:1, h:1};
    if(GU.retinaBounds) gl.uniform4f(GU.retinaBounds, rb.x, rb.y, rb.w, rb.h);
gl.drawArrays(gl.TRIANGLES, 0, 3);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0,0,canvas.width,canvas.height);
    g_thetaIdx = (g_thetaIdx + 1) % THETA_RING;
  }

  function weightStep(){
    if(!hebb_onEl.checked) return;
    if(!g_weightTexA || !g_weightTexB || !g_neiTexA) return;
    if(storedNeiW <= 0 || storedNeiH <= 0) return;

    const outTex = otherWeightTex();
    const outNeiTex = otherNeiTex();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outTex, 0);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT1, gl.TEXTURE_2D, outNeiTex, 0);
    gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);
    gl.viewport(0, 0, storedNeiW, storedNeiH);
    gl.disable(gl.BLEND);

    gl.useProgram(weightProg);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, currTheta(g_thetaRing, g_thetaIdx));
    gl.uniform1i(WPU.thetaCurr, 0);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, currentWeightTex());
    gl.uniform1i(WPU.weights, 1);

    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, currentNeiTex());
    gl.uniform1i(WPU.nei, 2);

    gl.activeTexture(gl.TEXTURE3);
    gl.bindTexture(gl.TEXTURE_2D, currentUvTex());
    gl.uniform1i(WPU.uvTex, 3);

    gl.activeTexture(gl.TEXTURE4);
    gl.bindTexture(gl.TEXTURE_2D, currentNeuromodTex());
    gl.uniform1i(WPU.neuromod, 4);

    gl.activeTexture(gl.TEXTURE5);
    gl.bindTexture(gl.TEXTURE_2D, g_nodeWeightTex);
    gl.uniform1i(WPU.nodeWeights, 5);

    gl.uniform1i(WPU.nodeCount, nodeCount);
    gl.uniform1i(WPU.texW, g_texW);
    gl.uniform1i(WPU.degK, degK);

    gl.activeTexture(gl.TEXTURE6);
    gl.bindTexture(gl.TEXTURE_2D, g_omegaTex);
    gl.uniform1i(WPU.omega, 6);

    gl.activeTexture(gl.TEXTURE7);
    gl.bindTexture(gl.TEXTURE_2D, currentMetaTex());
    gl.uniform1i(WPU.meta, 7);

    const G = parseFloat(globalGainEl.value);
    gl.uniform1f(WPU.nmOn, nm_onEl && nm_onEl.checked ? 1.0 : 0.0);
    gl.uniform1f(WPU.nmGainLR, parseFloat(nm_gainLREl.value));
    gl.uniform1f(WPU.lr, parseFloat(hebb_lrEl.value) * G);
    gl.uniform1f(WPU.decay, parseFloat(hebb_decayEl.value));
    gl.uniform1f(WPU.wRest, parseFloat(hebb_w0El.value));
    gl.uniform1f(WPU.wMin, parseFloat(hebb_wminEl.value));
    gl.uniform1f(WPU.wMax, parseFloat(hebb_wmaxEl.value));
    gl.uniform1f(WPU.normRate, parseFloat(hebb_normEl.value));
    gl.uniform1f(WPU.stdpMix, parseFloat(hebb_stdpEl.value));
    gl.uniform1f(WPU.inhibAntiSync, parseFloat(hebb_inhibEl.value));
    gl.uniform1f(WPU.vmax, parseFloat(g_vmaxEl.value));
    gl.uniform1f(WPU.rewireOn, hebb_rewireEl.checked ? 1.0 : 0.0);
    gl.uniform1f(WPU.tick, simTick);

    gl.drawArrays(gl.TRIANGLES, 0, 3);

    // Cleanup MRT state so other shader passes don't crash
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT1, gl.TEXTURE_2D, null, 0);
    gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    
    gl.viewport(0, 0, canvas.width, canvas.height);
    g_weightFlip ^= 1;
    g_neiFlip ^= 1;
  }


  function homeoStep(){
    if(!g_homeoTexA) return;
    const outTex = otherHomeoTex();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outTex, 0);
    gl.viewport(0, 0, g_texW, g_texH);
    gl.disable(gl.BLEND);

    gl.useProgram(homeoProg);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, currTheta(g_thetaRing, g_thetaIdx));
    gl.uniform1i(HPU.thetaCurr, 0);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, currentHomeoTex());
    gl.uniform1i(HPU.homeo, 1);

    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, currentUvTex());
    gl.uniform1i(HPU.uvTex, 2);

    gl.activeTexture(gl.TEXTURE3);
    gl.bindTexture(gl.TEXTURE_2D, currentNeuromodTex());
    gl.uniform1i(HPU.neuromod, 3);

    gl.uniform1i(HPU.nodeCount, nodeCount);
    gl.uniform1i(HPU.texW, g_texW);

    const homeo_onEl = document.getElementById('homeo_on');
    const homeo_targetEl = document.getElementById('homeo_target');
    const homeo_rateEl = document.getElementById('homeo_rate');
    const homeo_metaEl = document.getElementById('homeo_meta');
    const nm_onEl = document.getElementById('nm_on');

    gl.uniform1f(HPU.dt, parseFloat(g_dtEl.value));
    gl.uniform1f(HPU.target, homeo_targetEl ? parseFloat(homeo_targetEl.value) : 0.30);
    gl.uniform1f(HPU.rate, homeo_rateEl ? parseFloat(homeo_rateEl.value) : 0.08);
    gl.uniform1f(HPU.vmax, parseFloat(g_vmaxEl.value));
    gl.uniform1f(HPU.on, (homeo_onEl && homeo_onEl.checked) ? 1.0 : 0.0);
    gl.uniform1f(HPU.metaOn, (homeo_metaEl && homeo_metaEl.checked) ? 1.0 : 0.0);
    gl.uniform1f(HPU.nmOn, (nm_onEl && nm_onEl.checked) ? 1.0 : 0.0);

    gl.drawArrays(gl.TRIANGLES, 0, 3);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, canvas.width, canvas.height);
    g_homeoFlip ^= 1;
  }

  function stpStep(){
    if(!stp_onEl.checked) return;
    if(!g_stpTexA || !g_stpTexB || !g_neiTexA) return;
    if(storedNeiW <= 0 || storedNeiH <= 0) return;

    const outTex = otherSTPTex();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outTex, 0);
    gl.viewport(0, 0, storedNeiW, storedNeiH);
    gl.disable(gl.BLEND);

    gl.useProgram(stpProg);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, currTheta(g_thetaRing, g_thetaIdx));
    gl.uniform1i(STPU.thetaCurr, 0);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, currentSTPTex());
    gl.uniform1i(STPU.stp, 1);

    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, currentNeiTex());
    gl.uniform1i(STPU.nei, 2);

    gl.uniform1i(STPU.nodeCount, nodeCount);
    gl.uniform1i(STPU.texW, g_texW);
    gl.uniform1i(STPU.degK, degK);

    gl.uniform1f(STPU.dt, parseFloat(g_dtEl.value));
    gl.uniform1f(STPU.U, parseFloat(stp_UEl.value));
    gl.uniform1f(STPU.tauD, parseFloat(stp_tauDEl.value));
    gl.uniform1f(STPU.tauF, parseFloat(stp_tauFEl.value));
    gl.uniform1f(STPU.actGain, parseFloat(stp_actGainEl.value));
    gl.uniform1f(STPU.vmax, parseFloat(g_vmaxEl.value));

    gl.drawArrays(gl.TRIANGLES, 0, 3);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, canvas.width, canvas.height);
    g_stpFlip ^= 1;
  }

  function nodeWeightStep(){
    if(!g_nodeWeightTex || !g_weightTexA) return;

    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, g_nodeWeightTex, 0);
    gl.viewport(0, 0, g_texW, g_texH);
    gl.disable(gl.BLEND);

    gl.useProgram(nodeWeightProg);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, currentWeightTex());
    gl.uniform1i(NWU.weights, 0);

    gl.uniform1i(NWU.nodeCount, nodeCount);
    gl.uniform1i(NWU.texW, g_texW);
    gl.uniform1i(NWU.degK, degK);

    gl.drawArrays(gl.TRIANGLES, 0, 3);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, canvas.width, canvas.height);
  }

  function fieldStep(){
    const outTex = nextTheta(f_thetaRing, f_thetaIdx);
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outTex, 0);
    gl.viewport(0,0,f_N,f_N);

    gl.useProgram(fieldProg);
    const delaySteps = (f_delayOnEl.checked ? (parseInt(f_delayStepsEl.value,10)|0) : 0);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, currTheta(f_thetaRing, f_thetaIdx));
    gl.uniform1i(FU.thetaCurr, 0);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, delayedTheta(f_thetaRing, f_thetaIdx, delaySteps));
    gl.uniform1i(FU.thetaDelay, 1);

    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, f_omegaTex);
    gl.uniform1i(FU.omega, 2);

    gl.activeTexture(gl.TEXTURE3);
    gl.bindTexture(gl.TEXTURE_2D, currentInflTex());
    gl.uniform1i(FU.infl, 3);

    gl.activeTexture(gl.TEXTURE4);
    gl.bindTexture(gl.TEXTURE_2D, defTex);
    gl.uniform1i(FU.defTex, 4);

    gl.activeTexture(gl.TEXTURE5);
    gl.bindTexture(gl.TEXTURE_2D, currentPhiTex());
    gl.uniform1i(FU.phiTex, 5);

    gl.activeTexture(gl.TEXTURE6);
    gl.bindTexture(gl.TEXTURE_2D, currentMetaTex());
    gl.uniform1i(FU.meta, 6);

    const G = parseFloat(globalGainEl.value);
    gl.uniform1f(FU.dt, parseFloat(f_dtEl.value));
    gl.uniform1f(FU.Ke, parseFloat(f_KeEl.value) * G);
    gl.uniform1f(FU.Ki, parseFloat(f_KiEl.value) * G);
    gl.uniform1f(FU.a1, parseFloat(f_a1El.value));
    gl.uniform1f(FU.K2, parseFloat(f_K2El.value) * G);
    gl.uniform1f(FU.a2, parseFloat(f_a2El.value));
    gl.uniform1f(FU.omegaSpread, parseFloat(f_omegaEl.value));

    gl.uniform1f(FU.gfOn, gf_onEl.checked ? 1.0 : 0.0);
    gl.uniform1f(FU.Kgf, parseFloat(KgfEl.value) * G);
    gl.uniform1f(FU.agf, parseFloat(agfEl.value));

    gl.uniform2f(FU.texel, 1.0/f_N, 1.0/f_N);
    gl.uniform2f(FU.inflTexel, 1.0/f_N, 1.0/f_N);
    gl.uniform1f(FU.phiWarp, parseFloat(phiWarpEl.value));
    gl.uniform1f(FU.topoOn, topoOnEl.checked ? 1.0 : 0.0);
    gl.uniform1f(FU.Kflux, parseFloat(KfluxEl.value) * G);
    gl.uniform1f(FU.defOn, defectOnEl.checked ? 1.0 : 0.0);
    gl.uniform1f(FU.Kdef, parseFloat(KdefEl.value) * G);
    gl.drawArrays(gl.TRIANGLES, 0, 3);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0,0,canvas.width,canvas.height);
    f_thetaIdx = (f_thetaIdx + 1) % THETA_RING;
  }
  function neuromodStep(){
    if(!nmA || !nmB) return;
    if(!(nm_onEl && nm_onEl.checked)) return;

    const src = currentNeuromodTex();
    const dst = otherNeuromodTex();

    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, dst, 0);
    gl.viewport(0,0,f_N,f_N);
    gl.disable(gl.BLEND);

    gl.useProgram(neuromodProg);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, src);
    gl.uniform1i(NMU.prev, 0);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, currentInflTex());
    gl.uniform1i(NMU.infl, 1);

    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, currentMetaTex());
    gl.uniform1i(NMU.meta, 2);

    gl.uniform2f(NMU.texel, 1.0/f_N, 1.0/f_N);

    const dt = parseFloat(f_dtEl.value);
    gl.uniform1f(NMU.dt, dt);

    gl.uniform1f(NMU.tau, parseFloat(nm_tauEl.value));
    gl.uniform1f(NMU.D, parseFloat(nm_DEl.value));
    gl.uniform1f(NMU.drive, parseFloat(nm_driveEl.value));
    gl.uniform1f(NMU.base, parseFloat(nm_baseEl.value));

    gl.uniform1f(NMU.gliaOn, glia_onEl.checked ? 1.0 : 0.0);
    gl.uniform1f(NMU.gliaMop, parseFloat(glia_mopEl.value));

    gl.drawArrays(gl.TRIANGLES, 0, 3);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0,0,canvas.width,canvas.height);

    nmFlip ^= 1;
  }

    let lastATPOn = true;

  function metaStep(){
    if(!metaA || !metaB) return;

    const atpOn = atp_onEl.checked;
    if(!atpOn){
      if(lastATPOn) clearMeta();
      lastATPOn = false;
      return;
    }
    lastATPOn = true;

    const src = currentMetaTex();
    const dst = otherMetaTex();

    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, dst, 0);
    gl.viewport(0,0,f_N,f_N);
    gl.disable(gl.BLEND);

    gl.useProgram(metaProg);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, src);
    gl.uniform1i(MTU.prev, 0);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, currentInflTex());
    gl.uniform1i(MTU.infl, 1);

    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, currentNeuromodTex());
    gl.uniform1i(MTU.neuromod, 2);

    gl.uniform2f(MTU.texel, 1.0/f_N, 1.0/f_N);
    gl.uniform1f(MTU.dt, parseFloat(f_dtEl.value));

    gl.uniform1f(MTU.regen, parseFloat(atp_regenEl.value));
    gl.uniform1f(MTU.cost,  parseFloat(atp_costEl.value));
    gl.uniform1f(MTU.diff,  parseFloat(atp_diffEl.value));

    gl.uniform1f(MTU.gliaOn, glia_onEl.checked ? 1.0 : 0.0);
    gl.uniform1f(MTU.gliaTau, parseFloat(glia_tauEl.value));
    gl.uniform1f(MTU.gliaYield, parseFloat(glia_yieldEl.value));

    // These are intentionally gentle: glia should be slow compared to neurons
    gl.uniform1f(MTU.gliaDrive, parseFloat(glia_driveEl.value));
    gl.uniform1f(MTU.gliaDiff,  parseFloat(glia_diffEl.value));

    gl.drawArrays(gl.TRIANGLES, 0, 3);

    metaFlip = 1 - metaFlip;

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0,0,canvas.width,canvas.height);
  }

function uvStep(){
    const g_moveEl = document.getElementById('g_move');
    if(!g_moveEl || parseFloat(g_moveEl.value) <= 0.0) return;

    const outTex = otherUvTex();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outTex, 0);
    gl.viewport(0, 0, g_texW, g_texH);
    gl.disable(gl.BLEND);

    gl.useProgram(uvProg);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, currentUvTex());
    gl.uniform1i(UVU.uvCurr, 0);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, currentInflTex());
    gl.uniform1i(UVU.infl, 1);

    gl.uniform1i(UVU.nodeCount, nodeCount);
    gl.uniform1i(UVU.texW, g_texW);
    gl.uniform1f(UVU.dt, parseFloat(g_dtEl.value));
    gl.uniform1f(UVU.motility, parseFloat(g_moveEl.value));
    gl.uniform1f(UVU.tick, simTick);
    gl.uniform2f(UVU.inflTexel, 1.0/f_N, 1.0/f_N); // Passes the grid size

    gl.drawArrays(gl.TRIANGLES, 0, 3);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, canvas.width, canvas.height);
    g_uvFlip ^= 1;
  }



  function computeDefects(){
    if(!defTex) return;
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, defTex, 0);
    gl.viewport(0,0,f_N,f_N);

    gl.useProgram(defectProg);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, currTheta(f_thetaRing, f_thetaIdx));
    gl.uniform1i(QPU.theta, 0);
    gl.uniform2f(QPU.texel, 1.0/f_N, 1.0/f_N);
    gl.drawArrays(gl.TRIANGLES, 0, 3);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0,0,canvas.width,canvas.height);
  }

  function phiStep(){
    if(!phiA || !phiB) return;
    const outTex = otherPhiTex();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outTex, 0);
    gl.viewport(0,0,f_N,f_N);

    gl.useProgram(phiProg);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, currentPhiTex());
    gl.uniform1i(PPU.phi, 0);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, defTex);
    gl.uniform1i(PPU.defTex, 1);

    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, currentInflTex());
    gl.uniform1i(PPU.infl, 2);

    gl.activeTexture(gl.TEXTURE3);
    gl.bindTexture(gl.TEXTURE_2D, currentMetaTex());
    gl.uniform1i(PPU.meta, 3);

    gl.activeTexture(gl.TEXTURE4);
    gl.bindTexture(gl.TEXTURE_2D, currentNeuromodTex());
    gl.uniform1i(PPU.neuromod, 4);

    gl.uniform2f(PPU.texel, 1.0/f_N, 1.0/f_N);
    gl.uniform1f(PPU.dt, parseFloat(f_dtEl.value));

    const wave_speedEl = document.getElementById('wave_speed');
    const wave_dampEl = document.getElementById('wave_damp');
    const cemi_emitEl = document.getElementById('cemi_emit');

    gl.uniform1f(PPU.waveSpeed, wave_speedEl ? parseFloat(wave_speedEl.value) : 2.0);
    gl.uniform1f(PPU.waveDamping, wave_dampEl ? parseFloat(wave_dampEl.value) : 0.15);
    gl.uniform1f(PPU.cemiEmit, cemi_emitEl ? parseFloat(cemi_emitEl.value) : 0.8);
    gl.uniform1f(PPU.phiInject, parseFloat(phiInjectEl.value));
    gl.uniform1f(PPU.phiGlobalOn, phiGlobalOnEl.checked ? 1.0 : 0.0);
    gl.uniform1f(PPU.phiTargetMean, parseFloat(phiTargetEl.value));
    gl.uniform1f(PPU.phiMean, phiMeanEst);
    gl.uniform1f(PPU.phiGlobalRate, parseFloat(phiGlobalRateEl.value));
    gl.uniform1f(PPU.defOn, defectOnEl.checked ? 1.0 : 0.0);
    gl.drawArrays(gl.TRIANGLES, 0, 3);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0,0,canvas.width,canvas.height);
    phiFlip ^= 1;
  }

  function drawField(timeSec){
    if(!f_showEl.checked) return;
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    gl.useProgram(drawProg);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, currTheta(f_thetaRing, f_thetaIdx));
    gl.uniform1i(DU.theta, 0);
    gl.uniform1f(DU.alpha, parseFloat(f_alphaDrawEl.value));
    gl.uniform1f(DU.time, timeSec);

    const palEnabled = (!phaseOnlyEl.checked) && palOnEl.checked;
    gl.uniform1f(DU.palOn, palEnabled ? 1.0 : 0.0);
    gl.uniform1f(DU.palSpeed, parseFloat(palSpdEl.value));
    gl.uniform1i(DU.colorMode, parseInt(colorModeEl.value, 10) || 0);

    // Bind CEMI phi and neuromod textures for modes 10,11
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, currentPhiTex());
    gl.uniform1i(DU.phi, 1);

    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, currentNeuromodTex());
    gl.uniform1i(DU.neuromod, 2);

    gl.drawArrays(gl.TRIANGLES, 0, 3);
    gl.disable(gl.BLEND);
  }

  function drawEdges(timeSec){
    if(edgeIndexCount <= 0 || nodeCount<=0) return;
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    gl.useProgram(edgeProg);
    gl.bindVertexArray(edgeVAO);

    const aspect = canvas.width / Math.max(1, canvas.height);
    gl.uniform2f(EU.center, centerX, centerY);
    gl.uniform1f(EU.scale, scale);
    gl.uniform1f(EU.aspect, aspect);

    gl.uniform1i(EU.texW, g_texW);
    gl.uniform1f(EU.alpha, parseFloat(edgeAEl.value));
    gl.uniform1f(EU.time, timeSec);

    const palEnabled = (!phaseOnlyEl.checked) && palOnEl.checked;
    gl.uniform1f(EU.palOn, palEnabled ? 1.0 : 0.0);
    gl.uniform1f(EU.palSpd, parseFloat(palSpdEl.value));
    gl.uniform1i(EU.colorMode, parseInt(colorModeEl.value, 10) || 0);

    gl.uniform1f(EU.useField, edgeFromFieldEl.checked ? 1.0 : 0.0);
    gl.uniform1f(EU.uvScale, uvScaleGlobal);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, currTheta(g_thetaRing, g_thetaIdx));
    gl.uniform1i(EU.theta, 0);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, currTheta(f_thetaRing, f_thetaIdx));
    gl.uniform1i(EU.fieldTheta, 1);

    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, g_nodeWeightTex);
    gl.uniform1i(EU.nodeWeight, 2);

    gl.activeTexture(gl.TEXTURE3);
    gl.bindTexture(gl.TEXTURE_2D, currentUvTex());
    gl.uniform1i(EU.uvTex, 3);
    gl.uniform1f(EU.hebbGlow, parseFloat(hebb_glowEl.value));

    gl.activeTexture(gl.TEXTURE4);
    gl.bindTexture(gl.TEXTURE_2D, g_omegaTex);
    gl.uniform1i(EU.omega, 4);

    // Bind CEMI phi and neuromod textures for modes 10,11
    gl.activeTexture(gl.TEXTURE5);
    gl.bindTexture(gl.TEXTURE_2D, currentPhiTex());
    gl.uniform1i(EU.phi, 5);

    gl.activeTexture(gl.TEXTURE6);
    gl.bindTexture(gl.TEXTURE_2D, currentNeuromodTex());
    gl.uniform1i(EU.neuromod, 6);

    const frac = Math.max(0.05, Math.min(1, parseFloat(edgeFracEl.value)));
    const effFrac = Math.max(0.05, Math.min(1, frac * renderScale));
    const drawCount = (Math.floor((edgeIndexCount * effFrac) / 2) * 2) | 0;
    gl.drawElements(gl.LINES, drawCount, gl.UNSIGNED_INT, 0);

    gl.bindVertexArray(null);
    gl.disable(gl.BLEND);
  }

  let lastNodeXY = null;

  function seedGraphVortex(nodeXY){
    if(!nodeCount || !g_thetaRing.length) return;
    const bytes = new Uint8Array(g_texW * g_texH * 4);
    for(let i=0;i<g_texW*g_texH;i++) bytes[i*4+3]=255;
    for(let i=0;i<nodeCount;i++){
      const x = nodeXY[i*3+0], y = nodeXY[i*3+1];
      const ang = Math.atan2(y, x);
      const th01 = (ang + Math.PI) / TAU;
      packTheta01ToRGBA(th01, bytes, i*4, 0.5);
    }
    for(let r=0;r<g_thetaRing.length;r++){
      gl.bindTexture(gl.TEXTURE_2D, g_thetaRing[r]);
      gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,g_texW,g_texH,gl.RGBA,gl.UNSIGNED_BYTE,bytes);
    }
    gl.bindTexture(gl.TEXTURE_2D,null);
  }
  function seedFieldVortex(){
    if(!f_thetaRing.length) return;
    const bytes = new Uint8Array(f_N * f_N * 4);
    for(let y=0;y<f_N;y++){
      for(let x=0;x<f_N;x++){
        const u = (x + 0.5)/f_N - 0.5;
        const v = (y + 0.5)/f_N - 0.5;
        const ang = Math.atan2(v, u);
        const th01 = (ang + Math.PI) / TAU;
        packTheta01ToRGBA(th01, bytes, (y*f_N + x)*4, 0.5);
      }
    }
    for(let r=0;r<f_thetaRing.length;r++){
      gl.bindTexture(gl.TEXTURE_2D, f_thetaRing[r]);
      gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,f_N,f_N,gl.RGBA,gl.UNSIGNED_BYTE,bytes);
    }
    gl.bindTexture(gl.TEXTURE_2D,null);
  }

  seedAllBtn.addEventListener('click', ()=>{
    if(lastNodeXY) seedGraphVortex(lastNodeXY);
    seedFieldVortex();
    clearInfluence();
    resetWeights();
    simTick = 0;
  });

  hebbResetBtn.addEventListener('click', ()=>{
    resetWeights();
    setStatus("Hebbian weights reset to w₀=" + hebb_w0El.value);
  });

  stpResetBtn.addEventListener('click', ()=>{
    resetSTP();
    setStatus("STP state reset (u,x) to baseline U=" + stp_UEl.value);
  });

  nm_resetBtn.addEventListener('click', ()=>{
    const base = parseFloat(nm_baseEl.value) || 0.18;
    const daBase = Math.round(base * 0.4 * 255) / 255;
    const gluBase = Math.round(base * 255) / 255;
    const gabaBase = Math.round(base * 0.6 * 255) / 255;
    const actSlowInit = 0.15;
    const clearOne = (tex)=>{
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
      gl.viewport(0,0,f_N,f_N);
      gl.disable(gl.BLEND);
      gl.clearColor(daBase, gluBase, gabaBase, actSlowInit);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.viewport(0,0,canvas.width,canvas.height);
    };
    if(nmA) clearOne(nmA);
    if(nmB) clearOne(nmB);
    nmFlip = 0;
    setStatus("Chemical baths reset to baseline (DA=" + (base*0.4).toFixed(2) + " GLU=" + base.toFixed(2) + " GABA=" + (base*0.6).toFixed(2) + ").");
  });


  // ===== Worker builder (robust Coxeter-plane + simplex) =====
  const workerSrc = `
  let STOP=false;

  // ----- RNG -----
  let S=123456789>>>0;
  function urand(){ S^=(S<<13)>>>0; S^=(S>>>17)>>>0; S^=(S<<5)>>>0; return (S>>>0)/4294967295; }
  function randn(){
    let u=0,v=0;
    while(u===0) u=urand();
    while(v===0) v=urand();
    return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
  }

  function normalize(x){
    let s=0; for(let i=0;i<x.length;i++) s += x[i]*x[i];
    s = 1/Math.sqrt(Math.max(1e-30,s));
    for(let i=0;i<x.length;i++) x[i]*=s;
  }
  function dot(a,b){ let s=0; for(let i=0;i<a.length;i++) s+=a[i]*b[i]; return s; }
  function axpy(y, a, x){ for(let i=0;i<y.length;i++) y[i] += a*x[i]; }
  function copy(dst,src){ for(let i=0;i<dst.length;i++) dst[i]=src[i]; }

  // ----- D_n reflections / Coxeter element -----
  function buildDnReflections(n){
    const r=[];
    for(let k=0;k<n-1;k++) r.push([k,k+1,-1]); // e_k - e_{k+1}
    r.push([n-2,n-1,+1]); // e_{n-2} + e_{n-1}
    return r;
  }
  function applyRef(v,i,j,sgn){
    const dot = v[i] + sgn*v[j];
    v[i] -= dot;
    v[j] -= dot*sgn;
  }
  function applyCoxeter(v, refl){
    for(let t=0;t<refl.length;t++){
      const a=refl[t]; applyRef(v,a[0],a[1],a[2]);
    }
  }

  // ===== ROBUST Coxeter-plane (fixes collapse) =====
  function solveCoxeterPlaneDn(n){
    const h = 2*(n-1);
    const theta = 2*Math.PI/h;
    const refl = buildDnReflections(n);

    function oneTry(){
      const x = new Float64Array(n);
      for(let i=0;i<n;i++) x[i] = randn();
      normalize(x);

      const y = new Float64Array(n);
      copy(y, x);

      const re = new Float64Array(n);
      const im = new Float64Array(n);

      for(let k=0;k<h;k++){
        const ck = Math.cos(k*theta);
        const sk = Math.sin(k*theta);
        axpy(re,  ck, y);
        axpy(im, -sk, y);
        applyCoxeter(y, refl);
      }

      const nr = Math.sqrt(Math.max(1e-30, dot(re,re)));
      const ni = Math.sqrt(Math.max(1e-30, dot(im,im)));
      if(nr < 1e-8 || ni < 1e-8) return null;

      normalize(re);
      const d = dot(im, re);
      for(let i=0;i<n;i++) im[i] -= d*re[i];
      const nim = Math.sqrt(Math.max(1e-30, dot(im,im)));
      if(nim < 1e-8) return null;
      normalize(im);

      return {u: re, v: im};
    }

    for(let t=0;t<8;t++){
      const b = oneTry();
      if(b) return b;
    }

    const u = new Float64Array(n), v = new Float64Array(n);
    u[0]=1; v[1]=1;
    return {u,v};
  }

  // ----- pairs for demihypercube (as before) -----
  function makePairs(n, mode, paircap){
    const pairs=[];
    function pushAll(){
      for(let i=0;i<n;i++) for(let j=i+1;j<n;j++) pairs.push([i,j]);
    }
    if(mode==="chain"){
      for(let i=0;i<n-1;i++) pairs.push([i,i+1]);
      return pairs;
    }
    if(mode==="chain2"){
      for(let i=0;i<n-1;i++) pairs.push([i,i+1]);
      for(let i=0;i<n-2;i++) pairs.push([i,i+2]);
      return pairs;
    }
    const total = (n*(n-1))/2;
    if(mode==="allpairs" && n<=24){
      pushAll();
      return pairs;
    }
    let cap = paircap|0;
    if(cap<=0){
      cap = Math.min(2000, total);
    }
    if(mode==="allpairs"){
      const seen = new Set();
      for(let d=1; d<n && pairs.length<cap; d++){
        for(let i=0;i<n && pairs.length<cap;i++){
          let j=(i+d)%n;
          let a=i,b=j; if(a>b){ const t=a; a=b; b=t; }
          const key=a*n+b;
          if(seen.has(key)) continue;
          seen.add(key);
          pairs.push([a,b]);
        }
      }
      return pairs;
    }
    const seen = new Set();
    while(pairs.length < cap){
      let i = (urand()*n)|0;
      let j = (urand()*(n-1))|0;
      if(j>=i) j++;
      if(i>j){ const t=i; i=j; j=t; }
      const key = i*n + j;
      if(seen.has(key)) continue;
      seen.add(key);
      pairs.push([i,j]);
    }
    return pairs;
  }

  // ----- pairs for simplex edges (m vertices) -----
  function makePairsSimplex(m, mode, paircap){
    const edges=[];
    const total = (m*(m-1))/2;

    function addEdge(a,b){
      if(a===b) return;
      if(a>b){ const t=a; a=b; b=t; }
      edges.push([a,b]);
    }

    if(mode==="chain"){
      for(let i=0;i<m;i++) addEdge(i,(i+1)%m);
      return edges;
    }
    if(mode==="chain2"){
      for(let i=0;i<m;i++) addEdge(i,(i+1)%m);
      if(m>=4){
        for(let i=0;i<m;i++) addEdge(i,(i+2)%m);
      }
      return edges;
    }

    let cap = paircap|0;
    if(cap<=0){
      if(mode==="allpairs"){
        // auto cap to avoid instant browser death for huge m
        cap = (m<=200) ? total : Math.min(20000, total);
      } else {
        cap = Math.min(4000, total);
      }
    }
    cap = Math.max(1, Math.min(cap, total));

    if(mode==="allpairs"){
      // if small, do full K_m
      if(m<=200 && cap===total){
        for(let i=0;i<m;i++) for(let j=i+1;j<m;j++) addEdge(i,j);
        return edges;
      }
      // symmetric offset sweep until cap
      const seen=new Set();
      for(let d=1; d<m && edges.length<cap; d++){
        for(let i=0;i<m && edges.length<cap; i++){
          let j=(i+d)%m;
          let a=i,b=j; if(a>b){ const t=a; a=b; b=t; }
          const key=a*m+b;
          if(seen.has(key)) continue;
          seen.add(key);
          edges.push([a,b]);
        }
      }
      return edges;
    }

    // random
    const seen=new Set();
    while(edges.length<cap){
      let i=(urand()*m)|0;
      let j=(urand()*(m-1))|0;
      if(j>=i) j++;
      let a=i,b=j; if(a>b){ const t=a; a=b; b=t; }
      const key=a*m+b;
      if(seen.has(key)) continue;
      seen.add(key);
      edges.push([a,b]);
    }
    return edges;
  }

  function popcount16(x){
    x = x - ((x>>1)&0x5555);
    x = (x&0x3333)+((x>>2)&0x3333);
    return (((x + (x>>4))&0x0F0F)*0x0101)>>8;
  }

    function randomOrthoBasis(n){
    const u = new Float64Array(n);
    const v = new Float64Array(n);
    for(let i=0;i<n;i++){ u[i]=randn(); v[i]=randn(); }
    normalize(u);
    const proj = dot(u,v);
    for(let i=0;i<n;i++) v[i] -= proj*u[i];
    normalize(v);
    return {u,v};
  }

  function mergeQuant2D(rawX, rawY, targetMerge){
    const rawCount = rawX.length;
    let rawMaxR=1e-9;
    for(let i=0;i<rawCount;i++){
      const r=Math.hypot(rawX[i],rawY[i]);
      if(r>rawMaxR) rawMaxR=r;
    }
    let quant = Math.sqrt(targetMerge) / (2*rawMaxR);
    quant = Math.max(1e-6, quant);

    function clampI32(x){
      if(x>2147483647) return 2147483647;
      if(x<-2147483648) return -2147483648;
      return x|0;
    }
    function keyXY(bx,by){
      bx = clampI32(bx); by = clampI32(by);
      const bxU = (bx>>>0);
      const byU = (by>>>0);
      return (BigInt(bxU)<<32n) | BigInt(byU);
    }
    function bucketCountFor(q){
      const m=new Map();
      for(let i=0;i<rawCount;i++){
        const bx = Math.round(rawX[i]*q);
        const by = Math.round(rawY[i]*q);
        m.set(keyXY(bx,by),1);
      }
      return m.size;
    }
    for(let it=0; it<8; it++){
      const bc=bucketCountFor(quant);
      if(bc > targetMerge*1.10) quant *= 0.85;
      else if(bc < targetMerge*0.70) quant *= 1.15;
      else break;
    }

    const bucketMap=new Map();
    const sumX=[], sumY=[], sumC=[];
    for(let i=0;i<rawCount;i++){
      const bx = Math.round(rawX[i]*quant);
      const by = Math.round(rawY[i]*quant);
      const k = keyXY(bx,by);
      let id = bucketMap.get(k);
      if(id===undefined){
        id = sumX.length;
        bucketMap.set(k, id);
        sumX.push(0); sumY.push(0); sumC.push(0);
      }
      sumX[id]+=rawX[i];
      sumY[id]+=rawY[i];
      sumC[id]+=1;
    }

    const m2 = sumX.length;
    const nodeXY = new Float32Array(m2*3);
    let maxR=1e-9;
    for(let i=0;i<m2;i++){
      const x = sumX[i]/sumC[i];
      const y = sumY[i]/sumC[i];
      nodeXY[i*3+0]=x;
      nodeXY[i*3+1]=y;
      nodeXY[i*3+2]=i;
      const r=Math.hypot(x,y); if(r>maxR) maxR=r;
    }
    return {nodeXY, maxR};
  }

  function buildKNNEdges(nodeXY, degK){
    const N = (nodeXY.length/3)|0;
    const k = Math.max(1, degK|0);
    const candCap = (N<=2500) ? (N-1) : Math.min(N-1, 512);
    const neigh = Array.from({length:N}, ()=>[]);
    function addDir(a,b){ if(a!==b) neigh[a].push(b); }

    for(let i=0;i<N;i++){
      const xi=nodeXY[i*3], yi=nodeXY[i*3+1];
      let cands;
      if(candCap === N-1){
        cands = [];
        for(let j=0;j<N;j++) if(j!==i) cands.push(j);
      } else {
        cands = [];
        const seen = new Set();
        while(cands.length < candCap){
          const j = (urand()*N)|0;
          if(j===i) continue;
          if(seen.has(j)) continue;
          seen.add(j);
          cands.push(j);
        }
      }
      cands.sort((a,b)=>{
        const ax=nodeXY[a*3]-xi, ay=nodeXY[a*3+1]-yi;
        const bx=nodeXY[b*3]-xi, by=nodeXY[b*3+1]-yi;
        return (ax*ax+ay*ay)-(bx*bx+by*by);
      });
      const take = Math.min(k, cands.length);
      for(let t=0;t<take;t++) addDir(i, cands[t]);
    }

    const set = new Set();
    const edges=[];
    for(let a=0;a<N;a++){
      for(const b of neigh[a]){
        const i = a<b ? a : b;
        const j = a<b ? b : a;
        const key = i*4294967296 + j;
        if(set.has(key)) continue;
        set.add(key);
        edges.push(i,j);
      }
    }
    return new Uint32Array(edges);
  }

  // Compute per-edge distance bytes for axonal conduction delays
  function computeAxonDistBytes(nodeXY, neigh, degK, texW, neiW, neiH){
    // First pass: find max distance
    let maxDist = 1e-9;
    const N = neigh.length;
    for(let i=0;i<N;i++){
      const xi = nodeXY[i*3+0], yi = nodeXY[i*3+1];
      const arr = neigh[i];
      for(let j=0;j<arr.length && j<degK;j++){
        const nb = arr[j];
        const xj = nodeXY[nb*3+0], yj = nodeXY[nb*3+1];
        const d = Math.sqrt((xi-xj)*(xi-xj) + (yi-yj)*(yi-yj));
        if(d > maxDist) maxDist = d;
      }
    }
    // Second pass: encode normalized distance as u8 in R channel
    const distBytes = new Uint8Array(neiW * neiH * 4);
    for(let i=0;i<N;i++){
      const xi = nodeXY[i*3+0], yi = nodeXY[i*3+1];
      const baseX = i % texW;
      const baseY = (i / texW)|0;
      const arr = neigh[i];
      for(let j=0;j<degK;j++){
        const px = baseX + j * texW;
        const o = (baseY * neiW + px) * 4;
        if(j < arr.length){
          const nb = arr[j];
          const xj = nodeXY[nb*3+0], yj = nodeXY[nb*3+1];
          const d = Math.sqrt((xi-xj)*(xi-xj) + (yi-yj)*(yi-yj));
          const norm = Math.min(1.0, d / Math.max(1e-9, maxDist));
          distBytes[o+0] = Math.round(norm * 255);
        } else {
          distBytes[o+0] = 0;
        }
        distBytes[o+1] = 0;
        distBytes[o+2] = 0;
        distBytes[o+3] = 255;
      }
    }
    return distBytes;
  }

onmessage = async (e)=>{
    const msg = e.data;
    if(msg && msg.type==="stop"){ STOP=true; return; }
    if(!msg || msg.type!=="build") return;

    STOP=false;
    const {shape, n, shells, mode, paircap, maxCand, targetMerge, edgeStride, degK, exactFull, lobes, whiteMatter} = msg;
    const postP = (f,t)=>postMessage({type:"progress", frac:f, text:t});

    // Helper: Clones a base geometry into K lobes and wires long-range White Matter tracts between them
    function applyModularLobes(nodeXY, edgeIdx, count, lobes, whiteMatter, maxR){
      lobes = Math.max(1, lobes|0);
      if(lobes <= 1) return {nodeXY, edgeIdx, count, maxR};
      const totalNodes = count * lobes;
      const outXY = new Float32Array(totalNodes * 3);
      const outEdges = [];
      const orbitR = maxR * 1.8;
      let newMaxR = orbitR + maxR;

      for(let L=0; L<lobes; L++){
        const angle = (L / lobes) * Math.PI*2;
        const cx = orbitR * Math.cos(angle);
        const cy = orbitR * Math.sin(angle);
        const offset = L * count;

        // Topological heterogeneity: each lobe gets a slightly different micro-network.
        // 0 = dense/lattice-ish, 1 = small-world-ish, 2 = scale-free-ish (hub-biased)
        const mode = L % 3;

        // Pre-pick hubs for scale-free mode
        const hubCount = Math.max(3, Math.floor(Math.sqrt(count) / 2));
        const hubs = new Int32Array(hubCount);
        if(mode === 2){
          for(let h=0; h<hubCount; h++) hubs[h] = offset + ((urand()*count)|0);
        }

        // Geometry warp to break identical Laplacian spectra (different "pitch")
        const warp = (mode===0? 0.03 : mode===1? 0.06 : 0.045);
        const scale = (mode===0? 1.00 : mode===1? 1.05 : 0.97);

        // Copy nodes (with slight deterministic-ish jitter)
        for(let i=0;i<count;i++){
          const bx = nodeXY[i*3+0] * scale;
          const by = nodeXY[i*3+1] * scale;

          const jx = (urand()*2-1) * warp;
          const jy = (urand()*2-1) * warp;

          outXY[(offset+i)*3+0] = bx + cx + jx;
          outXY[(offset+i)*3+1] = by + cy + jy;
          outXY[(offset+i)*3+2] = offset + i;
        }

        // Copy edges + optional rewiring per mode
        const edgeOff = L * edgeIdx.length;
        for(let e=0;e<edgeIdx.length;e+=2){
          let a = edgeIdx[e] + offset;
          let b = edgeIdx[e+1] + offset;

          if(mode === 1){
            // Small-world: occasional long-range rewire
            if(urand() < 0.08){
              b = offset + ((urand()*count)|0);
              if(b === a) b = offset + ((b - offset + 1) % count);
            }
          } else if(mode === 2){
            // Scale-free: bias targets toward hubs
            if(urand() < 0.12){
              b = hubs[(urand()*hubCount)|0];
              if(b === a) b = hubs[(urand()*hubCount)|0];
            }
          } else {
            // Dense/lattice-ish: mostly local, tiny random drift
            if(urand() < 0.03){
              b = offset + ((urand()*count)|0);
              if(b === a) b = offset + ((b - offset + 1) % count);
            }
          }

          outEdges[edgeOff + e] = a;
          outEdges[edgeOff + e+1] = b;
        }
      }

      // Generate White Matter (Sparse Inter-lobe connections)
      const baseEdges = Math.max(1, edgeIdx.length/2);
      const numWM = Math.max(1, Math.floor(baseEdges * Math.max(0.0, whiteMatter||0.0)));
      for(let L=0; L<lobes; L++){
        for(let k=0; k<numWM; k++){
          const targetL = (L + 1 + ((urand()*(lobes-1))|0)) % lobes;
          const u = (urand() * count)|0;
          const v = (urand() * count)|0;
          outEdges.push(L * count + u, targetL * count + v);
        }
      }
      return { nodeXY: outXY, edgeIdx: new Uint32Array(outEdges), count: totalNodes, maxR: newMaxR };
    }

        // ==== CROSS-POLYTOPE / ORTHOPLEX ====
    if((shape||"demihypercube")==="crosspolytope"){
      const nn = Math.max(2, n|0);
      postP(0.05, "Cross-polytope: basis + projection ("+(2*nn)+" vertices)…");
      let basis;
      try{ basis = solveCoxeterPlaneDn(nn); }catch(_){ basis = randomOrthoBasis(nn); }
      const u=basis.u, v=basis.v;

      let m2 = 2*nn;
      let nodeXY = new Float32Array(m2*3);
      let maxR=1e-9;
      for(let i=0;i<nn;i++){
        const x=u[i], y=v[i];
        nodeXY[(2*i)*3+0]= x;
        nodeXY[(2*i)*3+1]= y;
        nodeXY[(2*i)*3+2]= 2*i;
        nodeXY[(2*i+1)*3+0]= -x;
        nodeXY[(2*i+1)*3+1]= -y;
        nodeXY[(2*i+1)*3+2]= 2*i+1;
        const r=Math.hypot(x,y); if(r>maxR) maxR=r;
      }

      postP(0.25, "Cross-polytope: wiring (kNN)…");
      let edgeIdx = buildKNNEdges(nodeXY, degK);

      const modL = applyModularLobes(nodeXY, edgeIdx, m2, lobes, whiteMatter, maxR);
      nodeXY = modL.nodeXY; edgeIdx = modL.edgeIdx; m2 = modL.count; maxR = modL.maxR;

      postP(0.55, "Cross-polytope: adjacency…");
      const neigh = Array.from({length:m2}, ()=>[]);
      for(let i=0;i<edgeIdx.length;i+=2){
        const a=edgeIdx[i], b=edgeIdx[i+1];
        neigh[a].push(b); neigh[b].push(a);
      }
      for(let i=0;i<m2;i++){
        if(neigh[i].length>degK) neigh[i].length=degK;
      }

      postP(0.75, "Cross-polytope: packing neighbors…");
      let texW=1;
      while(texW*texW < m2) texW<<=1;
      let texH=Math.ceil(m2/texW);
      if(texH>texW){ texW<<=1; texH=Math.ceil(m2/texW); }

      const neiW=texW*degK, neiH=texH;
      const neiBytes=new Uint8Array(neiW*neiH*4); neiBytes.fill(255);

      function writeNeighbor(i,j,nb){
        const baseX=(i%texW)+j*texW;
        const baseY=(i/texW)|0;
        const o=(baseY*neiW+baseX)*4;
        const u32=(nb>>>0);
        neiBytes[o+0]=u32&255; neiBytes[o+1]=(u32>>>8)&255; neiBytes[o+2]=(u32>>>16)&255; neiBytes[o+3]=(u32>>>24)&255;
      }
      for(let i=0;i<m2;i++){
        const arr=neigh[i];
        for(let j=0;j<degK;j++){
          const nb=(j<arr.length)?(arr[j]>>>0):0xFFFFFFFF;
          writeNeighbor(i,j,nb);
        }
      }

      postP(0.98, "Cross-polytope: done.");
      const distBytes = computeAxonDistBytes(nodeXY, neigh, degK, texW, neiW, neiH);
      postMessage({type:"done", payload:{
        shape:"crosspolytope",
        n:nn, shells:0, mode:"knn",
        paircap:0, maxCand:0, targetMerge:0,
        edgeStride:1, degK,
        rawCount:m2, rawEdgePairs:(edgeIdx.length/2)|0,
        nodeCount:m2, texW, texH, maxR,
        nodeXY, edgeIdx, neiW, neiH, neiBytes, distBytes
      }}, [nodeXY.buffer, edgeIdx.buffer, neiBytes.buffer, distBytes.buffer]);
      return;
    }

    // ==== HYPERCUBE (B_n / C_n) ====
    if((shape||"demihypercube")==="hypercube"){
      const nn = Math.max(2, n|0);
      let basis;
      try{ basis = solveCoxeterPlaneDn(nn); }catch(_){ basis = randomOrthoBasis(nn); }
      const u=basis.u, v=basis.v;

      const exactOk = exactFull && nn<=18;
      let rawCount = exactOk ? (1<<nn) : Math.max(64, Math.min((maxCand|0)||250000, Math.max(512, ((targetMerge|0)||2500)*4)));
      postP(0.05, "Hypercube: projecting "+(exactOk?rawCount:(rawCount+" sampled"))+" vertices…");

      const rawX = new Float32Array(rawCount);
      const rawY = new Float32Array(rawCount);

      function projMask(mask){
        let sx=0, sy=0;
        for(let k=0;k<nn;k++){
          const s = ((mask>>>k)&1) ? 1 : -1;
          sx += u[k]*s;
          sy += v[k]*s;
        }
        return [sx,sy];
      }

      if(exactOk){
        for(let mask=0; mask<rawCount; mask++){
          const p=projMask(mask);
          rawX[mask]=p[0]; rawY[mask]=p[1];
        }
      } else {
        for(let i=0;i<rawCount;i++){
          let sx=0, sy=0;
          for(let k=0;k<nn;k++){
            const s = (urand()<0.5)?-1:1;
            sx += u[k]*s;
            sy += v[k]*s;
          }
          rawX[i]=sx; rawY[i]=sy;
        }
      }

      let nodeXY, maxR, edgesFlat = [];
      const tgt = Math.max(64, (targetMerge|0)||2500);

      if(exactOk){
        const m2 = rawCount;
        nodeXY = new Float32Array(m2*3);
        maxR=1e-9;
        for(let i=0;i<m2;i++){
          const x=rawX[i], y=rawY[i];
          nodeXY[i*3+0]=x; nodeXY[i*3+1]=y; nodeXY[i*3+2]=i;
          const r=Math.hypot(x,y); if(r>maxR) maxR=r;
        }
        postP(0.55, "Hypercube: true isomorphic topological wiring…");
        for(let mask=0; mask<m2; mask++){
          for(let i=0; i<nn; i++){
            const nb = mask ^ (1<<i);
            if(mask < nb) edgesFlat.push(mask, nb);
          }
        }
      } else {
        if(rawCount > tgt*1.25){
          postP(0.30, "Hypercube: merging to ~"+tgt+" nodes…");
          const merged = mergeQuant2D(rawX, rawY, tgt);
          nodeXY = merged.nodeXY;
          maxR = merged.maxR;
        } else {
          const m2 = rawCount;
          nodeXY = new Float32Array(m2*3);
          maxR=1e-9;
          for(let i=0;i<m2;i++){
            const x=rawX[i], y=rawY[i];
            nodeXY[i*3+0]=x; nodeXY[i*3+1]=y; nodeXY[i*3+2]=i;
            const r=Math.hypot(x,y); if(r>maxR) maxR=r;
          }
        }
        postP(0.55, "Hypercube: wiring (kNN)…");
        const knn = buildKNNEdges(nodeXY, degK);
        for(let i=0; i<knn.length; i++) edgesFlat.push(knn[i]);
      }

      let m2 = (nodeXY.length/3)|0;
      const stride = Math.max(1, edgeStride|0);
      const rawEdgePairs = edgesFlat.length/2;
      const dsPairs = Math.max(1, Math.floor(rawEdgePairs/stride));
      let edgeIdx = new Uint32Array(dsPairs*2);
      for(let k=0,w=0; w<edgeIdx.length; k+=2*stride, w+=2){
        edgeIdx[w]=edgesFlat[k]; edgeIdx[w+1]=edgesFlat[k+1];
      }

      const modL = applyModularLobes(nodeXY, edgeIdx, m2, lobes, whiteMatter, maxR);
      nodeXY = modL.nodeXY; edgeIdx = modL.edgeIdx; m2 = modL.count; maxR = modL.maxR;

      postP(0.70, "Hypercube: adjacency…");
      const neigh = Array.from({length:m2}, ()=>[]);
      for(let i=0;i<edgeIdx.length;i+=2){
        const a=edgeIdx[i], b=edgeIdx[i+1];
        neigh[a].push(b); neigh[b].push(a);
      }
      for(let i=0;i<m2;i++){
        if(neigh[i].length>degK) neigh[i].length=degK;
      }

      postP(0.82, "Hypercube: packing neighbors…");
      let texW=1;
      while(texW*texW < m2) texW<<=1;
      let texH=Math.ceil(m2/texW);
      if(texH>texW){ texW<<=1; texH=Math.ceil(m2/texW); }

      const neiW=texW*degK, neiH=texH;
      const neiBytes=new Uint8Array(neiW*neiH*4); neiBytes.fill(255);

      function writeNeighbor(i,j,nb){
        const baseX=(i%texW)+j*texW;
        const baseY=(i/texW)|0;
        const o=(baseY*neiW+baseX)*4;
        const u32=(nb>>>0);
        neiBytes[o+0]=u32&255; neiBytes[o+1]=(u32>>>8)&255; neiBytes[o+2]=(u32>>>16)&255; neiBytes[o+3]=(u32>>>24)&255;
      }
      for(let i=0;i<m2;i++){
        const arr=neigh[i];
        for(let j=0;j<degK;j++){
          const nb=(j<arr.length)?(arr[j]>>>0):0xFFFFFFFF;
          writeNeighbor(i,j,nb);
        }
      }

      postP(0.98, "Hypercube: done.");
      const distBytes = computeAxonDistBytes(nodeXY, neigh, degK, texW, neiW, neiH);
      postMessage({type:"done", payload:{
        shape:"hypercube",
        n:nn, shells:0, mode:"knn",
        paircap:0, maxCand:rawCount, targetMerge:tgt,
        edgeStride:1, degK,
        rawCount:rawCount, rawEdgePairs:(edgeIdx.length/2)|0,
        nodeCount:m2, texW, texH, maxR,
        nodeXY, edgeIdx, neiW, neiH, neiBytes, distBytes
      }}, [nodeXY.buffer, edgeIdx.buffer, neiBytes.buffer, distBytes.buffer]);
      return;
    }

// ==== SIMPLEX (A_n): regular (n+1)-gon in Coxeter plane ====
    if((shape||"demihypercube")==="simplex"){
      let m = Math.max(3, (n|0) + 1); // vertices
      postP(0.10, "Simplex: projecting to regular polygon ("+m+" vertices)…");

      let nodeXY = new Float32Array(m*3);
      let mx=0,my=0;
      for(let i=0;i<m;i++){
        const a = 2*Math.PI*i/m;
        const x = Math.cos(a);
        const y = Math.sin(a);
        nodeXY[i*3+0]=x;
        nodeXY[i*3+1]=y;
        nodeXY[i*3+2]=i;
        mx += x; my += y;
      }
      mx/=m; my/=m;
      let maxR=1e-9;
      for(let i=0;i<m;i++){
        const x=nodeXY[i*3+0]-mx;
        const y=nodeXY[i*3+1]-my;
        nodeXY[i*3+0]=x; nodeXY[i*3+1]=y;
        const r=Math.hypot(x,y); if(r>maxR) maxR=r;
      }

      postP(0.25, "Simplex: edges ("+mode+") …");
      const pairs = makePairsSimplex(m, mode, paircap);
      const edgesFlat = new Uint32Array(pairs.length*2);
      for(let i=0;i<pairs.length;i++){
        edgesFlat[i*2+0]=pairs[i][0]>>>0;
        edgesFlat[i*2+1]=pairs[i][1]>>>0;
      }

      const stride = Math.max(1, edgeStride|0);
      const rawEdgePairs = edgesFlat.length/2;
      const dsPairs = Math.max(1, Math.floor(rawEdgePairs/stride));
      let edgeIdx = new Uint32Array(dsPairs*2);
      for(let k=0,w=0; w<edgeIdx.length; k+=2*stride, w+=2){
        edgeIdx[w]=edgesFlat[k];
        edgeIdx[w+1]=edgesFlat[k+1];
      }

      const modL = applyModularLobes(nodeXY, edgeIdx, m, lobes, whiteMatter, maxR);
      nodeXY = modL.nodeXY; edgeIdx = modL.edgeIdx; m = modL.count; maxR = modL.maxR;

      postP(0.55, "Simplex: adjacency…");
      const neigh = Array.from({length:m}, ()=>[]);
      for(let i=0;i<edgeIdx.length;i+=2){
        const a=edgeIdx[i], b=edgeIdx[i+1];
        neigh[a].push(b); neigh[b].push(a);
      }
      for(let i=0;i<m;i++){
        if(neigh[i].length>degK) neigh[i].length=degK;
      }

      postP(0.75, "Simplex: packing neighbors…");
      let texW=1;
      while(texW*texW < m) texW<<=1;
      let texH=Math.ceil(m/texW);
      if(texH>texW){ texW<<=1; texH=Math.ceil(m/texW); }

      const neiW=texW*degK, neiH=texH;
      const neiBytes=new Uint8Array(neiW*neiH*4); neiBytes.fill(255);

      function writeNeighbor(i,j,nb){
        const baseX=(i%texW)+j*texW;
        const baseY=(i/texW)|0;
        const o=(baseY*neiW+baseX)*4;
        const u=(nb>>>0);
        neiBytes[o+0]=u&255; neiBytes[o+1]=(u>>>8)&255; neiBytes[o+2]=(u>>>16)&255; neiBytes[o+3]=(u>>>24)&255;
      }
      for(let i=0;i<m;i++){
        const arr=neigh[i];
        for(let j=0;j<degK;j++){
          const nb=(j<arr.length)?(arr[j]>>>0):0xFFFFFFFF;
          writeNeighbor(i,j,nb);
        }
      }

      postP(0.98, "Simplex: done.");
      const distBytes = computeAxonDistBytes(nodeXY, neigh, degK, texW, neiW, neiH);
      postMessage({type:"done", payload:{
        shape:"simplex",
        n, shells:0, mode,
        paircap, maxCand:0, targetMerge:0,
        edgeStride:stride, degK,
        rawCount:m, rawEdgePairs,
        nodeCount:m, texW, texH, maxR,
        nodeXY, edgeIdx, neiW, neiH, neiBytes, distBytes
      }}, [nodeXY.buffer, edgeIdx.buffer, neiBytes.buffer, distBytes.buffer]);
      return;
    }

    // ==== DEMIHYPERCUBE (D_n) ====
    postP(0.01, "Coxeter plane (Dₙ) basis…");
    const basis = solveCoxeterPlaneDn(n);
    const u = basis.u, v = basis.v;

    // EXACT FULL: n<=18, all vertices, true isomorphic edges
    if(exactFull && n<=18){
      postP(0.08, "Exact Isomorphic: generating all even-parity vertices…");
      const Nmask = 1<<n;
      const masks = [];
      const maskToIdx = new Map();
      for(let m=0;m<Nmask;m++){
        if((popcount16(m) & 1)===0){
          const idx = masks.length;
          masks.push(m);
          maskToIdx.set(m, idx);
        }
        if((m & 4095)===0){ await new Promise(r=>setTimeout(r,0)); if(STOP) break; }
      }
      let V = masks.length;

      postP(0.20, "Exact Isomorphic: projecting…");
      let nodeXY = new Float32Array(V*3);
      let maxR=1e-9;
      let mx=0,my=0;
      for(let k=0;k<V;k++){
        const m=masks[k];
        let x=0,y=0;
        for(let i=0;i<n;i++){
          const bit = (m>>i)&1;
          const sgn = bit ? -1 : +1;
          x += sgn*u[i];
          y += sgn*v[i];
        }
        mx += x; my += y;
        nodeXY[k*3+0]=x;
        nodeXY[k*3+1]=y;
        nodeXY[k*3+2]=k;
      }
      mx/=V; my/=V;
      for(let k=0;k<V;k++){
        const x=nodeXY[k*3+0]-mx;
        const y=nodeXY[k*3+1]-my;
        nodeXY[k*3+0]=x; nodeXY[k*3+1]=y;
        const r=Math.hypot(x,y); if(r>maxR) maxR=r;
      }

      postP(0.35, "Exact Isomorphic: building true topological edges…");
      const edges = [];
      const edgePairs = makePairs(n, mode, paircap); // Allows sparse chain wiring on the exact manifold!
      for(let idx=0; idx<V; idx++){
        const m = masks[idx];
        for(let p=0; p<edgePairs.length; p++){
          const i = edgePairs[p][0];
          const j = edgePairs[p][1];
          const nb = m ^ (1<<i) ^ (1<<j);
          const jdx = maskToIdx.get(nb);
          if(jdx!==undefined && idx < jdx){
            edges.push(idx>>>0, jdx>>>0);
          }
        }
        if((idx & 2047)===0){ await new Promise(r=>setTimeout(r,0)); if(STOP) break; }
      }

      const stride = Math.max(1, edgeStride|0);
      const rawPairs = edges.length/2;
      const dsPairs = Math.max(1, Math.floor(rawPairs/stride));
      let edgeIdx = new Uint32Array(dsPairs*2);
      for(let k=0,w=0; w<edgeIdx.length; k+=2*stride, w+=2){
        edgeIdx[w]=edges[k]; edgeIdx[w+1]=edges[k+1];
      }

      const modL = applyModularLobes(nodeXY, edgeIdx, V, lobes, whiteMatter, maxR);
      nodeXY = modL.nodeXY; edgeIdx = modL.edgeIdx; V = modL.count; maxR = modL.maxR;

      postP(0.62, "Exact full: adjacency…");
      const neigh = Array.from({length:V}, ()=>[]);
      for(let i=0;i<edgeIdx.length;i+=2){
        const a=edgeIdx[i], b=edgeIdx[i+1];
        neigh[a].push(b); neigh[b].push(a);
      }
      for(let i=0;i<V;i++){ if(neigh[i].length>degK) neigh[i].length=degK; }

      let texW=1;
      while(texW*texW < V) texW<<=1;
      let texH=Math.ceil(V/texW);
      if(texH>texW){ texW<<=1; texH=Math.ceil(V/texW); }
      const neiW = texW*degK, neiH = texH;
      const neiBytes = new Uint8Array(neiW*neiH*4); neiBytes.fill(255);
      function writeNeighbor(i,j,nb){
        const baseX=(i%texW)+j*texW;
        const baseY=(i/texW)|0;
        const o=(baseY*neiW+baseX)*4;
        const u=(nb>>>0);
        neiBytes[o+0]=u&255; neiBytes[o+1]=(u>>>8)&255; neiBytes[o+2]=(u>>>16)&255; neiBytes[o+3]=(u>>>24)&255;
      }
      for(let i=0;i<V;i++){
        const arr=neigh[i];
        for(let j=0;j<degK;j++){
          const nb=(j<arr.length)?(arr[j]>>>0):0xFFFFFFFF;
          writeNeighbor(i,j,nb);
        }
      }

      postP(0.98, "Exact full: done.");
      const distBytes = computeAxonDistBytes(nodeXY, neigh, degK, texW, neiW, neiH);
      postMessage({type:"done", payload:{
        shape:"demihypercube",
        n, shells, mode:"allpairs (exact full)", paircap, maxCand, targetMerge,
        edgeStride:stride, degK,
        rawCount:V,
        rawEdgePairs:rawPairs,
        nodeCount:V,
        texW, texH, maxR,
        nodeXY, edgeIdx, neiW, neiH, neiBytes, distBytes
      }}, [nodeXY.buffer, edgeIdx.buffer, neiBytes.buffer, distBytes.buffer]);
      return;
    }

    // Non-exact: orbit sample
    postP(0.08, "Pairs…");
    const pairs = makePairs(n, mode, paircap);
    const flipMasks = pairs.map(([i,j]) => (1n<<BigInt(i)) | (1n<<BigInt(j)));

    postP(0.12, "Orbit…");
    const rawMaskToIndex = new Map(); // BigInt -> idx
    const rawMasks = [];
    const rawX = [];
    const rawY = [];

    // seed: balanced even
    let k = (n/2)|0; if(k%2===1) k--;
    let seedMask = 0n;
    for(let i=0;i<k;i++) seedMask |= (1n<<BigInt(i));

    let x0=0, y0=0;
    for(let i=0;i<n;i++){
      const bit = (seedMask >> BigInt(i)) & 1n;
      const sgn = (bit===1n) ? -1 : 1;
      x0 += sgn*u[i];
      y0 += sgn*v[i];
    }

    rawMaskToIndex.set(seedMask, 0);
    rawMasks.push(seedMask);
    rawX.push(x0);
    rawY.push(y0);

    let frontM=[seedMask], frontX=[x0], frontY=[y0];

    const YIELD=2500;
    let ops=0;

    for(let sh=1; sh<=shells; sh++){
      if(STOP) break;
      if(rawMasks.length >= maxCand) break;

      const nextM=[], nextX=[], nextY=[];
      for(let fi=0; fi<frontM.length; fi++){
        if(STOP) break;
        const cm=frontM[fi], cx=frontX[fi], cy=frontY[fi];

        for(let p=0;p<flipMasks.length;p++){
          const fm=flipMasks[p];
          const nm=cm ^ fm;
          if(rawMaskToIndex.has(nm)) continue;

          const [i,j]=pairs[p];
          const bi = ((cm >> BigInt(i)) & 1n) === 1n;
          const bj = ((cm >> BigInt(j)) & 1n) === 1n;
          const dx = (bi ? +2*u[i] : -2*u[i]) + (bj ? +2*u[j] : -2*u[j]);
          const dy = (bi ? +2*v[i] : -2*v[i]) + (bj ? +2*v[j] : -2*v[j]);
          const nx=cx+dx, ny=cy+dy;

          const idx=rawMasks.length;
          rawMaskToIndex.set(nm, idx);
          rawMasks.push(nm);
          rawX.push(nx);
          rawY.push(ny);
          nextM.push(nm);
          nextX.push(nx);
          nextY.push(ny);

          if(rawMasks.length >= maxCand) break;

          ops++;
          if((ops%YIELD)===0){
            postP(0.12 + 0.20*(rawMasks.length/maxCand), "Orbit: shell "+sh+"/"+shells+" ("+rawMasks.length+"/"+maxCand+")");
            await new Promise(r=>setTimeout(r,0));
          }
        }
        if(rawMasks.length >= maxCand) break;
      }
      frontM=nextM; frontX=nextX; frontY=nextY;
      await new Promise(r=>setTimeout(r,0));
      if(frontM.length===0) break;
    }

    const rawCount = rawMasks.length;
    if(rawCount < 8){
      postMessage({type:"error", text:"Too few points. Increase shells/candidates."});
      return;
    }

    let rawMaxR=1e-9;
    for(let i=0;i<rawCount;i++){
      const r=Math.hypot(rawX[i],rawY[i]);
      if(r>rawMaxR) rawMaxR=r;
    }

    // SYMMETRIC merge: ROUND + signed-safe key
    postP(0.35, "Merging (symmetric)…");
    let quant = Math.sqrt(targetMerge) / (2*rawMaxR);
    quant = Math.max(1e-6, quant);

    function clampI32(x){
      if(x>2147483647) return 2147483647;
      if(x<-2147483648) return -2147483648;
      return x|0;
    }
    function keyXY(bx,by){
      bx = clampI32(bx); by = clampI32(by);
      const bxU = (bx>>>0);
      const byU = (by>>>0);
      return (BigInt(bxU)<<32n) | BigInt(byU);
    }
    function bucketCountFor(q){
      const m=new Map();
      for(let i=0;i<rawCount;i++){
        const bx = Math.round(rawX[i]*q);
        const by = Math.round(rawY[i]*q);
        m.set(keyXY(bx,by),1);
      }
      return m.size;
    }
    for(let it=0; it<8; it++){
      const bc=bucketCountFor(quant);
      if(bc > targetMerge*1.10) quant *= 0.85;
      else if(bc < targetMerge*0.70) quant *= 1.15;
      else break;
      await new Promise(r=>setTimeout(r,0));
    }

    const bucketMap=new Map();
    const sumX=[], sumY=[], sumC=[];
    const rawToNode=new Int32Array(rawCount);

    for(let i=0;i<rawCount;i++){
      const bx=Math.round(rawX[i]*quant);
      const by=Math.round(rawY[i]*quant);
      const key=keyXY(bx,by);
      let ni=bucketMap.get(key);
      if(ni===undefined){
        ni=sumX.length;
        bucketMap.set(key,ni);
        sumX.push(0); sumY.push(0); sumC.push(0);
      }
      sumX[ni]+=rawX[i];
      sumY[ni]+=rawY[i];
      sumC[ni]+=1;
      rawToNode[i]=ni;
      if((i&4095)===0){ await new Promise(r=>setTimeout(r,0)); if(STOP) break; }
    }

    let nodeCount=sumX.length;
    let nodeXY=new Float32Array(nodeCount*3);

    let mx=0,my=0;
    for(let i=0;i<nodeCount;i++){
      mx += sumX[i]/sumC[i];
      my += sumY[i]/sumC[i];
    }
    mx/=nodeCount; my/=nodeCount;

    let maxR=1e-9;
    for(let i=0;i<nodeCount;i++){
      const x=(sumX[i]/sumC[i]) - mx;
      const y=(sumY[i]/sumC[i]) - my;
      nodeXY[i*3+0]=x;
      nodeXY[i*3+1]=y;
      nodeXY[i*3+2]=i;
      const r=Math.hypot(x,y); if(r>maxR) maxR=r;
    }

    postP(0.50, "Edges…");
    const edgeSet=new Set();
    const edges=[];

    for(let i=0;i<rawCount;i++){
      if(STOP) break;
      const a=rawToNode[i]>>>0;
      const m=rawMasks[i];
      for(let p=0;p<flipMasks.length;p++){
        const nm=m ^ flipMasks[p];
        const j=rawMaskToIndex.get(nm);
        if(j===undefined) continue;
        const b=rawToNode[j]>>>0;
        if(a===b) continue;
        const lo=a<b?a:b, hi=a<b?b:a;
        const key=(BigInt(lo)<<32n) | BigInt(hi);
        if(edgeSet.has(key)) continue;
        edgeSet.add(key);
        edges.push(lo,hi);
      }
      if((i&4095)===0){ await new Promise(r=>setTimeout(r,0)); }
    }

    const stride=Math.max(1, edgeStride|0);
    const rawEdgePairs=edges.length/2;
    const dsPairs=Math.max(1, Math.floor(rawEdgePairs/stride));
    let edgeIdx=new Uint32Array(dsPairs*2);
    for(let k=0,w=0; w<edgeIdx.length; k+=2*stride, w+=2){
      edgeIdx[w]=edges[k];
      edgeIdx[w+1]=edges[k+1];
    }

    const modL = applyModularLobes(nodeXY, edgeIdx, nodeCount, lobes, whiteMatter, maxR);
    nodeXY = modL.nodeXY; edgeIdx = modL.edgeIdx; nodeCount = modL.count; maxR = modL.maxR;

    postP(0.66, "Adjacency…");
    const neigh=Array.from({length:nodeCount}, ()=>[]);
    for(let i=0;i<edgeIdx.length;i+=2){
      const a=edgeIdx[i], b=edgeIdx[i+1];
      neigh[a].push(b); neigh[b].push(a);
    }
    for(let i=0;i<nodeCount;i++){
      if(neigh[i].length>degK) neigh[i].length=degK;
      if((i&8191)===0){ await new Promise(r=>setTimeout(r,0)); }
    }

    postP(0.78, "Packing neighbors…");
    let texW=1;
    while(texW*texW < nodeCount) texW<<=1;
    let texH=Math.ceil(nodeCount/texW);
    if(texH>texW){ texW<<=1; texH=Math.ceil(nodeCount/texW); }

    const neiW=texW*degK, neiH=texH;
    const neiBytes=new Uint8Array(neiW*neiH*4); neiBytes.fill(255);

    function writeNeighbor(i,j,nb){
      const baseX=(i%texW)+j*texW;
      const baseY=(i/texW)|0;
      const o=(baseY*neiW+baseX)*4;
      const u=(nb>>>0);
      neiBytes[o+0]=u&255; neiBytes[o+1]=(u>>>8)&255; neiBytes[o+2]=(u>>>16)&255; neiBytes[o+3]=(u>>>24)&255;
    }
    for(let i=0;i<nodeCount;i++){
      const arr=neigh[i];
      for(let j=0;j<degK;j++){
        const nb=(j<arr.length)?(arr[j]>>>0):0xFFFFFFFF;
        writeNeighbor(i,j,nb);
      }
      if((i&8191)===0){ await new Promise(r=>setTimeout(r,0)); if(STOP) break; }
    }

    postP(0.98, "Done.");
    const distBytes = computeAxonDistBytes(nodeXY, neigh, degK, texW, neiW, neiH);
    postMessage({type:"done", payload:{
      shape:"demihypercube",
      n, shells, mode,
      paircap, maxCand, targetMerge,
      edgeStride:stride, degK,
      rawCount, rawEdgePairs,
      nodeCount, texW, texH, maxR,
      nodeXY, edgeIdx, neiW, neiH, neiBytes, distBytes
    }}, [nodeXY.buffer, edgeIdx.buffer, neiBytes.buffer, distBytes.buffer]);
  };
  `;

  let worker=null;
  function ensureWorker(){
    if(worker) return;
    const blob=new Blob([workerSrc], {type:"application/javascript"});
    worker=new Worker(URL.createObjectURL(blob));
    worker.onmessage=(e)=>{
      const m=e.data;
      if(!m) return;
      if(m.type==="progress") setProgress(m.frac, m.text);
      else if(m.type==="error"){ setProgress(1,"Stopped."); setStatus(m.text); }
      else if(m.type==="done") applyBuild(m.payload);
    };
    worker.onerror=(err)=>{
      try{
        console.error('Worker error', err);
        setProgress(1,'Worker error.');
        setStatus('Worker error: ' + (err && (err.message || err.filename || err.type)));
      }catch(_){/* noop */}
    };
    worker.onmessageerror=(err)=>{
      try{
        console.error('Worker message error', err);
        setProgress(1,'Worker message error.');
        setStatus('Worker message error.');
      }catch(_){/* noop */}
    };
  }

  stopBtn.addEventListener('click', ()=>{
    if(worker) worker.postMessage({type:"stop"});
    setProgress(1, "Stop requested.");
  });

  function applyBuild(p){
    initFieldTextures();

    nodeCount = p.nodeCount;
    degK = p.degK;

    initGraphTextures(nodeCount);

    if(g_neiTexA) gl.deleteTexture(g_neiTexA);
    if(g_neiTexB) gl.deleteTexture(g_neiTexB);
    g_neiTexA = makeTexRGBA8UI(p.neiW, p.neiH, new Uint8Array(p.neiBytes));
    g_neiTexB = makeTexRGBA8UI(p.neiW, p.neiH, new Uint8Array(p.neiBytes));
    g_neiFlip = 0;

    // Axonal distance texture (per-edge normalized distance for conduction delays)
    if(g_axonDistTex) gl.deleteTexture(g_axonDistTex);
    if(p.distBytes){
      g_axonDistTex = makeTexRGBA8(p.neiW, p.neiH, new Uint8Array(p.distBytes));
    } else {
      g_axonDistTex = makeTexRGBA8(p.neiW, p.neiH, null);
    }

    initWeightTextures(p.neiW, p.neiH);

    lastNodeXY = new Float32Array(p.nodeXY);
    gl.bindBuffer(gl.ARRAY_BUFFER, nodeVBO);
    gl.bufferData(gl.ARRAY_BUFFER, lastNodeXY, gl.STATIC_DRAW);

    const edgeIdx = new Uint32Array(p.edgeIdx);
    edgeIndexCount = edgeIdx.length;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, edgeIBO);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, edgeIdx, gl.STATIC_DRAW);

    maxR = p.maxR || 1.0;
    uvScaleGlobal = 0.5 / Math.max(1e-9, maxR);

    // UV tex for node -> field lookup
    const lobes = parseInt(document.getElementById('lobes')?.value || 1, 10);
    const lobe0Count = Math.floor(nodeCount / Math.max(1, lobes));
    let l0minU=Infinity, l0minV=Infinity, l0maxU=-Infinity, l0maxV=-Infinity;

    const uvBytes = new Uint8Array(g_texW * g_texH * 4);
    for(let i=0;i<g_texW*g_texH;i++) uvBytes[i*4+3]=255;
    for(let i=0;i<nodeCount;i++){
      const x=lastNodeXY[i*3+0], y=lastNodeXY[i*3+1];
      const u = x*uvScaleGlobal + 0.5;
      const v = y*uvScaleGlobal + 0.5;

      if(i < lobe0Count){
        if(u<l0minU) l0minU=u; if(u>l0maxU) l0maxU=u;
        if(v<l0minV) l0minV=v; if(v>l0maxV) l0maxV=v;
      }

      packUV16(u, v, uvBytes, i*4);
    }
    window.lobe0UV = {x: l0minU, y: l0minV, w: (l0maxU - l0minU), h: (l0maxV - l0minV)};
    gl.bindTexture(gl.TEXTURE_2D, g_uvTexA);
    gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,g_texW,g_texH,gl.RGBA,gl.UNSIGNED_BYTE,uvBytes);
    gl.bindTexture(gl.TEXTURE_2D, g_uvTexB);
    gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,g_texW,g_texH,gl.RGBA,gl.UNSIGNED_BYTE,uvBytes);
    gl.bindTexture(gl.TEXTURE_2D,null);

    // splat VBO (uv, idx)
    const splatData = new Float32Array(nodeCount*3);
    for(let i=0;i<nodeCount;i++){
      const x=lastNodeXY[i*3+0], y=lastNodeXY[i*3+1];
      splatData[i*3+0]=x*uvScaleGlobal + 0.5;
      splatData[i*3+1]=y*uvScaleGlobal + 0.5;
      splatData[i*3+2]=i;
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, splatVBO);
    gl.bufferData(gl.ARRAY_BUFFER, splatData, gl.STATIC_DRAW);

    fitScale = 0.95 / Math.max(1e-9, maxR);
    resetView();

    clearInfluence();
    seedFieldVortex();
    seedGraphVortex(lastNodeXY);
    simTick=0;

    setProgress(1, "Done.");
    const shapeName = p.shape || "demihypercube";
    const tip =
      (shapeName==="simplex")
        ? "Tip: Simplex Aₙ projects to a regular (n+1)-gon here. Use chain/chain2 for readable wiring.\n"
        : "Tip: n=10 + ALL + Exact full ON should be symmetric (no collapse).\n";

    setStatus(
      `Built: ${shapeName}.\n`+
      (shapeName==="demihypercube" ? `Projection: robust Coxeter-plane Dₙ orthographic.\n` : `Projection: regular polygon (Aₙ simplex).\n`) +
      `mode=${p.mode}  n=${p.n} shells=${p.shells}\n`+
      `raw verts=${p.rawCount.toLocaleString()}  nodes=${p.nodeCount.toLocaleString()}\n`+
      `raw edges=${p.rawEdgePairs.toLocaleString()}  drawn edges=${(edgeIndexCount/2).toLocaleString()} (stride ${p.edgeStride})\n`+
      tip
    );

    running=true;
  }

  function requestBuild(){
    ensureWorker();
    setProgress(0.01, "Starting build…");
    setStatus("Building…");

    const shape = shapeEl.value || "demihypercube";
    const nRaw = (parseInt(nEl.value,10)|0) || 8;
    const n = (shape==="simplex") ? Math.max(2, nRaw) : Math.max(4, nRaw);

    const shells = Math.max(1, (parseInt(shellsEl.value,10)|0) || 8);
    const mode = pairsEl.value;
    const paircap = Math.max(0, (parseInt(paircapEl.value,10)|0) || 0);
    const maxCand = Math.max(256, (parseInt(candsEl.value,10)|0) || 4096);
    const targetMerge = Math.max(300, (parseInt(mergeQEl.value,10)|0) || 1200);
    const edgeStride = Math.max(1, (parseInt(edgeStrideEl.value,10)|0) || 1);
    degK = Math.max(4, Math.min(32, (parseInt(degKEl.value,10)|0) || 16));
    const exactFull = (!!exactFullEl.checked) && (shape==="demihypercube");

    const lobes = parseInt(document.getElementById('lobes')?.value || 1, 10);
    const whiteMatter = parseFloat(document.getElementById('whiteMatter')?.value || 0.010);

    worker.postMessage({ type:"build", shape, n, shells, mode, paircap, maxCand, targetMerge, edgeStride, degK, exactFull, lobes, whiteMatter });
  }

  buildBtn.addEventListener('click', requestBuild);

  let running=false;
  runBtn.addEventListener('click', ()=> running=true);
  pauseBtn.addEventListener('click', ()=> running=false);
  kickBtn.addEventListener('click', ()=>{ simTick += 10.0; });

  function decayInfluenceAndStep(steps){
    for(let s=0;s<steps;s++){
      decayInfluence();
      fieldStep();
      computeDefects();
      phiStep();
      neuromodStep();
      metaStep();
      uvStep();
      homeoStep();
      graphStep();
      stpStep();
      weightStep();
      if((s & 3) === 0) nodeWeightStep();
      simTick += 1.0;
    }
  }

  function updateHUD(fps, cpuMs){
    hudEl.innerHTML =
      `FPS ~ ${fps.toFixed(0)} | CPU/frame ~ ${cpuMs.toFixed(2)} ms<br>`+
      `nodes=${nodeCount.toLocaleString()} edges=${(edgeIndexCount/2).toLocaleString()} degK=${degK}<br>`+
      `shape=${shapeEl.value} | edgeDraw=${edgeFracEl.value}×${renderScale.toFixed(2)} | FieldOverlay=${f_showEl.checked?"ON":"OFF"} | Running=${running?"YES":"NO"}<br>`+
      `Hebbian=${hebb_onEl.checked?"ON":"OFF"} η=${parseFloat(hebb_lrEl.value).toFixed(4)} λ=${parseFloat(hebb_decayEl.value).toFixed(4)} w₀=${parseFloat(hebb_w0El.value).toFixed(2)}<br>`+
      `AxonDelay=${(axon_onEl&&axon_onEl.checked)?"ON":"OFF"} speed=${parseFloat(axon_speedEl.value).toFixed(2)}<br>`+
      (window.metaDebugHTML ? window.metaDebugHTML : "");
  }

  // ===== WEB AUDIO API: SYNTHETIC CONNECTOME SONIFICATION =====
  let audioCtx, masterGain, delayNode, filterNode, compressor;
  const synthNodes = [];
  const NUM_VOICES = 4;
  const readBuf = new Uint8Array(NUM_VOICES * 4); // 4 pixels (RGBA) for GPU readback

  function initAudio() {
    if (audioCtx) return;
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();

    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.0;

    // Deep, lush ambient echo
    delayNode = audioCtx.createDelay();
    delayNode.delayTime.value = 0.6; 
    const feedback = audioCtx.createGain();
    feedback.gain.value = 0.55; 
    delayNode.connect(feedback);
    feedback.connect(delayNode);

    // Dynamic Lowpass Filter
    filterNode = audioCtx.createBiquadFilter();
    filterNode.type = "lowpass";
    filterNode.frequency.value = 400;
    filterNode.Q.value = 2.0; // slight resonance

    // Soft Compressor to protect ears from loud clipping
    compressor = audioCtx.createDynamicsCompressor();
    compressor.threshold.value = -16;
    compressor.knee.value = 10;
    compressor.ratio.value = 4;
    compressor.attack.value = 0.05;
    compressor.release.value = 0.25;

    delayNode.connect(filterNode);
    filterNode.connect(compressor);
    masterGain.connect(delayNode); // Wet
    masterGain.connect(compressor); // Dry
    compressor.connect(audioCtx.destination);

    // Beautiful locked chord voicings: C3, G3, D4, E4 (CMaj9)
    const baseFreqs = [130.81, 196.22, 293.66, 329.63];

    for (let i = 0; i < NUM_VOICES; i++) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const pan = audioCtx.createStereoPanner ? audioCtx.createStereoPanner() : null;

      osc.type = "sine"; // Pure sine waves are much gentler
      osc.frequency.value = baseFreqs[i];
      gain.gain.value = 0; 

      osc.connect(gain);
      if (pan) {
        pan.pan.value = (i / (NUM_VOICES - 1)) * 2 - 1; // Spread stereo L to R
        gain.connect(pan);
        pan.connect(masterGain);
      } else {
        gain.connect(masterGain);
      }

      osc.start();
      synthNodes.push({ osc, gain, pan, baseFreq: baseFreqs[i] });
    }
  }

  const audio_onEl = document.getElementById('audio_on');
  audio_onEl?.addEventListener('change', (e) => {
    if (e.target.checked) {
      initAudio();
      audioCtx.resume();
      masterGain.gain.setTargetAtTime(0.4, audioCtx.currentTime, 1.0); // Gentle fade in
    } else if (masterGain) {
      masterGain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 1.0); // Gentle fade out
    }
  });

  function updateAudio() {
    if (!audioCtx || !audio_onEl?.checked || !g_thetaRing.length || nodeCount < NUM_VOICES) return;

    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, currTheta(g_thetaRing, g_thetaIdx), 0);
    gl.readPixels(0, 0, NUM_VOICES, 1, gl.RGBA, gl.UNSIGNED_BYTE, readBuf);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    const time = audioCtx.currentTime;
    let avgVel = 0;

    // Tap into the ATP Energy system we built earlier
    let atp = window.currentATP !== undefined ? window.currentATP : 1.0;

    for (let i = 0; i < NUM_VOICES; i++) {
      const r = readBuf[i * 4 + 0];
      const g = readBuf[i * 4 + 1];
      const b = readBuf[i * 4 + 2];
      const a = readBuf[i * 4 + 3];

      const phase01 = (r + 256.0 * g) / 65535.0;
      const vel01 = (b + 256.0 * a) / 65535.0;
      avgVel += vel01;

      // Discretized Pitch: Instead of a sliding wail, jump by octaves/fifths based on energy
      let freq = synthNodes[i].baseFreq;
      if (vel01 > 0.65) freq *= 2.0; // Octave jump 
      if (vel01 > 0.85) freq *= 1.5; // Fifth jump

      // Gentle biological vibrato
      const vibrato = 1.0 + 0.01 * Math.sin(phase01 * Math.PI * 2);

      // Volume swells based on the node's position in the Kuramoto cycle
      const vol = Math.pow(Math.sin(phase01 * Math.PI), 2) * (0.2 + vel01 * 0.8);

      synthNodes[i].osc.frequency.setTargetAtTime(freq * vibrato, time, 0.2); // Smooth portamento
      synthNodes[i].gain.gain.setTargetAtTime((vol * 0.5) / NUM_VOICES, time, 0.1);
    }

    // Filter tied to Global Brain State (ATP & Activity)
    // Low ATP (Sleep) = Muffled deep rumble. High ATP + Wakefulness = Bright sparkling overtones.
    const targetCutoff = 150 + (atp * 1000) + ((avgVel / NUM_VOICES) * 2000);
    filterNode.frequency.setTargetAtTime(targetCutoff, time, 0.3);
  }
  // ==========================================================
  // ===== EMBODIED COGNITION (Webcam / Image Retina) =====
  let videoEl = null;
  let retinaCanvas = null;
  let retinaCtx = null;
  let previewCtx = null;
  window.retinaTex = null;
  window.staticRetinaImg = null;

  function initRetina() {
    if(!window.retinaTex) {
      window.retinaTex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, window.retinaTex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0,0,0,255]));
    }
    if(!videoEl) {
      videoEl = document.createElement('video');
      videoEl.autoplay = true;
      videoEl.muted = true;
      videoEl.playsInline = true;
    }
    if(!retinaCanvas) {
      retinaCanvas = document.createElement('canvas');
      retinaCanvas.width = 128; 
      retinaCanvas.height = 128;
      retinaCtx = retinaCanvas.getContext('2d', {willReadFrequently: true});
    }
    if(retina_previewEl && !previewCtx) {
      previewCtx = retina_previewEl.getContext('2d');
    }
  }

  // Handle Webcam Toggle
  retina_camEl?.addEventListener('change', async (e) => {
    initRetina();
    if(e.target.checked) {
      if(retina_imgEl) retina_imgEl.checked = false; // Mutually exclusive
      if(retina_previewEl) retina_previewEl.style.display = 'block';
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: 128, height: 128 } });
        videoEl.srcObject = stream;
        setStatus("Webcam Retina Active.");
      } catch(err) {
        setStatus("Webcam Error: " + err.message);
        e.target.checked = false;
        if(retina_previewEl) retina_previewEl.style.display = 'none';
      }
    } else {
      if(videoEl && videoEl.srcObject) {
        videoEl.srcObject.getTracks().forEach(t => t.stop());
        videoEl.srcObject = null;
      }
      if(!(retina_imgEl && retina_imgEl.checked) && retina_previewEl) retina_previewEl.style.display = 'none';
    }
  });

  // Handle Image Toggle
  retina_imgEl?.addEventListener('change', (e) => {
    initRetina();
    if(e.target.checked) {
      if(retina_camEl) {
         retina_camEl.checked = false;
         if(videoEl && videoEl.srcObject) {
            videoEl.srcObject.getTracks().forEach(t => t.stop());
            videoEl.srcObject = null;
         }
      }
      if(retina_previewEl) retina_previewEl.style.display = 'block';
      if(!window.staticRetinaImg) setStatus("Image Retina ON, but no image uploaded yet.");
      else setStatus("Image Retina Active.");
    } else {
      if(!(retina_camEl && retina_camEl.checked) && retina_previewEl) retina_previewEl.style.display = 'none';
    }
  });

  // Handle Static Image Upload
  retina_fileEl?.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if(!file) return;
    initRetina();

    // Auto-enable Image toggle and disable Webcam
    if(retina_imgEl) retina_imgEl.checked = true;
    if(retina_camEl) {
       retina_camEl.checked = false;
       if(videoEl && videoEl.srcObject) {
          videoEl.srcObject.getTracks().forEach(t => t.stop());
          videoEl.srcObject = null;
       }
    }
    if(retina_previewEl) retina_previewEl.style.display = 'block';

    const reader = new FileReader();
    reader.onload = (event) => {
      const img = new Image();
      img.onload = () => {
        window.staticRetinaImg = img;
        setStatus("Static image loaded into Retina.");
      };
      img.src = event.target.result;
    };
    reader.readAsDataURL(file);
  });

  // Master write to GPU
  function updateRetinaTexture() {
    if(!retinaCanvas) return;
    let updated = false;

    if(retina_imgEl && retina_imgEl.checked && window.staticRetinaImg) {
      retinaCtx.clearRect(0, 0, 128, 128);
      retinaCtx.drawImage(window.staticRetinaImg, 0, 0, 128, 128);
      updated = true;
    } 
    else if(retina_camEl && retina_camEl.checked && videoEl && videoEl.readyState >= 2) {
      retinaCtx.drawImage(videoEl, 0, 0, retinaCanvas.width, retinaCanvas.height);
      updated = true;
    }

    if(updated) {
      if(previewCtx) previewCtx.drawImage(retinaCanvas, 0, 0); // Update UI preview
      gl.bindTexture(gl.TEXTURE_2D, window.retinaTex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, retinaCanvas);
    }
  }
  // ==========================================================

// ===== LOBE INSPECTOR TOOL (Spatial GPU Readback) =====
  window.inspectorActive = false;
  window.inspectorUV = {x:0.5, y:0.5};
  const inspBuf = new Uint8Array(4);

  function read1x1(tex, uvX, uvY){
      if(!tex) return null;
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
      const px = Math.max(0, Math.min(f_N - 1, Math.floor(uvX * f_N)));
      const py = Math.max(0, Math.min(f_N - 1, Math.floor(uvY * f_N)));
      gl.readPixels(px, py, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, inspBuf);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      return inspBuf;
  }

  function updateInspectorImmediate(){
      if(!window.inspectorActive) return;

      const meta = read1x1(currentMetaTex(), window.inspectorUV.x, window.inspectorUV.y);
      if(meta){
          const atp = meta[0]/255.0;
          document.getElementById('insp_atp').textContent = atp.toFixed(3);
          document.getElementById('insp_atp_bar').style.width = (atp*100)+'%';
      }

      const nm = read1x1(currentNeuromodTex(), window.inspectorUV.x, window.inspectorUV.y);
      if(nm){
          const da = nm[0]/255.0;
          const glu = nm[1]/255.0;
          const gaba = nm[2]/255.0;
          document.getElementById('insp_da').textContent = da.toFixed(3);
          document.getElementById('insp_da_bar').style.width = (da*100)+'%';
          document.getElementById('insp_glu').textContent = glu.toFixed(3);
          document.getElementById('insp_glu_bar').style.width = (glu*100)+'%';
          document.getElementById('insp_gaba').textContent = gaba.toFixed(3);
          document.getElementById('insp_gaba_bar').style.width = (gaba*100)+'%';
      }

      const phiPx = read1x1(currentPhiTex(), window.inspectorUV.x, window.inspectorUV.y);
      if(phiPx){
          const phi = (phiPx[0]/255.0)*16.0 - 8.0;
          const vel = (phiPx[1]/255.0)*30.0 - 15.0;
          document.getElementById('insp_phi').textContent = phi.toFixed(2);
          document.getElementById('insp_act').textContent = vel.toFixed(2);
      }
      gl.viewport(0,0,canvas.width,canvas.height);
  }

  function updateInspectorPosition() {
      if(!window.inspectorActive) return;
      const wx = (window.inspectorUV.x - 0.5) / uvScaleGlobal;
      const wy = (window.inspectorUV.y - 0.5) / uvScaleGlobal;
      const w = canvas.width, h = canvas.height, aspect = w/h;
      const ndcX = (wx - centerX) * scale / aspect;
      const ndcY = (wy - centerY) * scale;

      const rect = canvas.getBoundingClientRect();
      const px = ((ndcX + 1) / 2) * rect.width + rect.left;
      const py = ((1 - ndcY) / 2) * rect.height + rect.top;

      const inspEl = document.getElementById('inspector');
      inspEl.style.left = px + 'px';
      inspEl.style.top = py + 'px';
  }

// ===== THERMODYNAMICS (ATP) & INTRINSIC PLASTICITY TRACKER =====
  let metaActivityEMA = 0.4;
  let atpMeanEst = 1.0;
  let atpMeanCounter = 0;
  const ATP_MEAN_EVERY = 12; // mean-estimate cadence in meta readback ticks

  // GPU readback for thermodynamics/homeostasis:
  // Keep the sample small + throttled (readPixels can stall the pipeline).
  const META_W = 8, META_H = 8;
  const META_SAMPLES = META_W * META_H;
  const metaReadBuf = new Uint8Array(META_SAMPLES * 4);
  // EMA time constant (seconds). Tuned to roughly match the previous per-frame smoothing.
  const META_TAU = 0.18;
  let metaSampleX = 0, metaSampleY = 0;

  function updateMetaParameters(dt){
    const homeoOn = homeo_onEl && homeo_onEl.checked;
    const atpOn = atp_onEl && atp_onEl.checked;

    // --- Metabolic readout (HUD/audio only) ---
    if(atpOn){
      atpMeanCounter++;
      if(atpMeanCounter % ATP_MEAN_EVERY === 0){
        try { updateATPMetaEstimate(); } catch(e) {}
      }
    } else {
      atpMeanEst = 1.0;
    }
    window.currentATP = atpOn ? atpMeanEst : 1.0;

    if(!homeoOn && !atpOn){
      window.metaDebugHTML = "<span style='color:var(--muted);'>Meta: OFF</span>";
      return;
    }

    // If homeostasis is off, we can skip the homeo readback but still show ATP.
    if(!homeoOn){
      if(atpOn){
        const atpPct = Math.round(atpMeanEst*100);
        const atpClr = (atpMeanEst < 0.25) ? "var(--warn)" : (atpMeanEst < 0.5) ? "var(--mid)" : "var(--ok)";
        const atpBar = `<span style="color:var(--muted)">ATP Energy:</span> <span style="color:${atpClr}">${atpPct}%</span> <span class="bar" style="--p:${atpPct};"></span>`;
        window.metaDebugHTML = `${atpBar}<br><span style='color:var(--muted);'>Intrinsic Plasticity: OFF</span>`;
      } else {
        window.metaDebugHTML = "<span style='color:var(--muted);'>Intrinsic Plasticity: OFF</span>";
      }
      return;
    }

    // --- HOMEOSTASIS READBACK (GPU -> CPU, small sample) ---
    if(!g_homeoTexA || !g_homeoTexB || nodeCount < 1){
      window.metaDebugHTML = "<span style='color:var(--muted);'>Meta: waiting for textures...</span>";
      return;
    }

    const META_SAMPLES = 64; // 8x8 readback
    const readW = 8, readH = 8;

    const tex = currentHomeoTex();
gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    gl.readPixels(0,0,readW,readH, gl.RGBA, gl.UNSIGNED_BYTE, metaReadBuf);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    let sumH = 0.0, sumA = 0.0;
    for(let i=0;i<META_SAMPLES;i++){
      const off = i*4;
      const r = metaReadBuf[off];
      const g = metaReadBuf[off+1];
      const b = metaReadBuf[off+2];
      const a = metaReadBuf[off+3];
      const H = ((r + (g<<8)) / 65535.0) * 4.0;
      const A = ((b + (a<<8)) / 65535.0); // 0..1
      sumH += H;
      sumA += A;
    }

    const avgH = sumH / META_SAMPLES;
    const avgAct = sumA / META_SAMPLES;

    // Global order parameter proxy (cheap): map activity trace into R/psi
    const R = 1.0 - Math.abs(avgAct * 2.0 - 1.0);
    const psi = avgAct * 6.28318530718;
    gGlobR = R;
gGlobPsi = psi;
metaActivityEMA = metaActivityEMA*0.92 + avgAct*0.08;

    let target = homeo_targetEl ? parseFloat(homeo_targetEl.value) : 0.30;
    if(!isFinite(target)) target = 0.30;
const err = (target - metaActivityEMA);

    let state = "BALANCED";
    if(metaActivityEMA < target - 0.08) state = "WAKE-UP";
    else if(metaActivityEMA > target + 0.08) state = "SLEEP-DOWN";

    const clr = (state==="BALANCED") ? "var(--ok)" : (state==="WAKE-UP") ? "var(--mid)" : "var(--warn)";
    const homeoStr = `<span style="color:var(--muted)">Intrinsic Plasticity:</span> <span style="color:${clr}">${state}</span> | <span style="color:var(--muted)">Ā</span> ${metaActivityEMA.toFixed(3)} <span style="color:var(--muted)">H̄</span> ${avgH.toFixed(3)} <span style="color:var(--muted)">err</span> ${err.toFixed(3)}`;

    let atpStr = "<span style='color:var(--muted);'>ATP: OFF</span>";
    if(atpOn){
      const atpPct = Math.round(atpMeanEst*100);
      const atpClr = (atpMeanEst < 0.25) ? "var(--warn)" : (atpMeanEst < 0.5) ? "var(--mid)" : "var(--ok)";
      atpStr = `<span style="color:var(--muted)">ATP Energy:</span> <span style="color:${atpClr}">${atpPct}%</span> <span class="bar" style="--p:${atpPct};"></span>`;
    }

    window.metaDebugHTML = `${atpStr}<br>${homeoStr}`;
  }



  // Timing / FPS
  let lastSec = performance.now()*0.001;
  let accum = 0, frames = 0, lastCpuMs = 0;

  // Adaptive stepping to reduce stutter on slower frames.
  let stepScale = 1.0;
  const TARGET_CPU_MS = 16.7; // ~60fps budget
  const MIN_STEP_SCALE = 0.25;
  const MAX_STEP_SCALE = 1.0;
  let cpuEMA = 0.0;

  // Adaptive edge render cost control (render-only)
  let renderScale = 1.0;
  const MIN_RENDER_SCALE = 0.25;
  const MAX_RENDER_SCALE = 1.0;

  // Throttled meta-parameter sampling accumulator
  let metaAccumDT = 0.0;
  let metaFrameCounter = 0;
  const META_EVERY = 8;

  function frame(tms){
    const t0=performance.now();
    resize();
    const now = tms*0.001;
    const dt = now - lastSec;
    lastSec = now;

    // Update global curvature mean estimate infrequently to avoid stalls.
    phiMeanCounter = (phiMeanCounter + 1) | 0;
    if (phiGlobalOnEl && phiGlobalOnEl.checked && (phiMeanCounter % 60) === 0) { updatePhiMeanEstimate(); }

    if(running && nodeCount>0 && g_neiTexA && f_thetaRing.length){
      if(typeof updateRetinaTexture === 'function') updateRetinaTexture();

      const stepsWanted = Math.max(1, (parseInt(stepsEl.value,10)|0));
      const cpuRef = (cpuEMA>0.0?cpuEMA:lastCpuMs);
      if(cpuRef > TARGET_CPU_MS * 1.15) stepScale *= 0.88;
      else if(cpuRef < TARGET_CPU_MS * 0.75) stepScale *= 1.04;
      stepScale = Math.min(MAX_STEP_SCALE, Math.max(MIN_STEP_SCALE, stepScale));

      // If we're already minimizing sim steps but still over budget, reduce edge draw cost too.
      if (edgeAdaptiveEl && edgeAdaptiveEl.checked) {
        if (cpuRef > TARGET_CPU_MS * 1.25 && stepScale <= MIN_STEP_SCALE + 1e-4) renderScale *= 0.92;
        else if (cpuRef < TARGET_CPU_MS * 0.75) renderScale *= 1.02;
        renderScale = Math.min(MAX_RENDER_SCALE, Math.max(MIN_RENDER_SCALE, renderScale));
      } else {
        renderScale = 1.0; // Locked strictly to 100% of defined edges
      }

      const steps = Math.max(1, Math.round(stepsWanted * stepScale));
      decayInfluenceAndStep(steps);
    }

    gl.clearColor(0,0,0,1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    drawField(now);
    drawEdges(now);

    if (typeof updateAudio === 'function') updateAudio();
    if (typeof updateMetaParameters === 'function') {
      metaAccumDT += dt;
      metaFrameCounter = (metaFrameCounter + 1) | 0;
      if ((metaFrameCounter % META_EVERY) === 0) {
        updateMetaParameters(metaAccumDT);
        metaAccumDT = 0.0;
        if(window.inspectorActive) updateInspectorImmediate(); // Synchronize with the HUD update rate
      }
    }

    lastCpuMs = performance.now()-t0;
    cpuEMA = (cpuEMA===0.0) ? lastCpuMs : (0.9*cpuEMA + 0.1*lastCpuMs);

    accum += dt; frames++;
    if(accum > 1.0){
      const fps = frames/accum;
      frames=0; accum=0;
      updateHUD(fps, cpuEMA);
    }

    syncFieldToggleBtn();
    if(typeof updateInspectorPosition === 'function') updateInspectorPosition();
    requestAnimationFrame(frame);
  }

  setProgress(0,"Idle.");
  setStatus("Ready.\nTap ⚙️ to open/close settings. Hold ⚙️ to toggle field overlay.\n");
  initFieldTextures();
  setTimeout(()=>requestBuild(), 50);
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>